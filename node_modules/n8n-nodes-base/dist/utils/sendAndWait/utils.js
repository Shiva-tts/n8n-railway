"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSendAndWaitProperties = getSendAndWaitProperties;
exports.sendAndWaitWebhook = sendAndWaitWebhook;
exports.getSendAndWaitConfig = getSendAndWaitConfig;
exports.createButton = createButton;
exports.createEmail = createEmail;
exports.configureWaitTillDate = configureWaitTillDate;
const n8n_workflow_1 = require("n8n-workflow");
const email_templates_1 = require("./email-templates");
const Form_node_1 = require("../../nodes/Form/Form.node");
const utils_1 = require("../../nodes/Form/utils");
const utilities_1 = require("../utilities");
const INPUT_FIELD_IDENTIFIER = 'field-0';
const limitWaitTimeProperties = {
    displayName: 'Limit Wait Time',
    name: 'limitWaitTime',
    type: 'fixedCollection',
    description: 'Whether the workflow will automatically resume execution after the specified limit type',
    default: { values: { limitType: 'afterTimeInterval', resumeAmount: 45, resumeUnit: 'minutes' } },
    options: [
        {
            displayName: 'Values',
            name: 'values',
            values: [
                {
                    displayName: 'Limit Type',
                    name: 'limitType',
                    type: 'options',
                    default: 'afterTimeInterval',
                    description: 'Sets the condition for the execution to resume. Can be a specified date or after some time.',
                    options: [
                        {
                            name: 'After Time Interval',
                            description: 'Waits for a certain amount of time',
                            value: 'afterTimeInterval',
                        },
                        {
                            name: 'At Specified Time',
                            description: 'Waits until the set date and time to continue',
                            value: 'atSpecifiedTime',
                        },
                    ],
                },
                {
                    displayName: 'Amount',
                    name: 'resumeAmount',
                    type: 'number',
                    displayOptions: {
                        show: {
                            limitType: ['afterTimeInterval'],
                        },
                    },
                    typeOptions: {
                        minValue: 0,
                        numberPrecision: 2,
                    },
                    default: 1,
                    description: 'The time to wait',
                },
                {
                    displayName: 'Unit',
                    name: 'resumeUnit',
                    type: 'options',
                    displayOptions: {
                        show: {
                            limitType: ['afterTimeInterval'],
                        },
                    },
                    options: [
                        {
                            name: 'Minutes',
                            value: 'minutes',
                        },
                        {
                            name: 'Hours',
                            value: 'hours',
                        },
                        {
                            name: 'Days',
                            value: 'days',
                        },
                    ],
                    default: 'hours',
                    description: 'Unit of the interval value',
                },
                {
                    displayName: 'Max Date and Time',
                    name: 'maxDateAndTime',
                    type: 'dateTime',
                    displayOptions: {
                        show: {
                            limitType: ['atSpecifiedTime'],
                        },
                    },
                    default: '',
                    description: 'Continue execution after the specified date and time',
                },
            ],
        },
    ],
};
function getSendAndWaitProperties(targetProperties, resource = 'message', additionalProperties = [], options) {
    const buttonStyle = {
        displayName: 'Button Style',
        name: 'buttonStyle',
        type: 'options',
        default: 'primary',
        options: [
            {
                name: 'Primary',
                value: 'primary',
            },
            {
                name: 'Secondary',
                value: 'secondary',
            },
        ],
    };
    const approvalOptionsValues = [
        {
            displayName: 'Type of Approval',
            name: 'approvalType',
            type: 'options',
            placeholder: 'Add option',
            default: 'single',
            options: [
                {
                    name: 'Approve Only',
                    value: 'single',
                },
                {
                    name: 'Approve and Disapprove',
                    value: 'double',
                },
            ],
        },
        {
            displayName: 'Approve Button Label',
            name: 'approveLabel',
            type: 'string',
            default: options?.defaultApproveLabel || 'Approve',
            displayOptions: {
                show: {
                    approvalType: ['single', 'double'],
                },
            },
        },
        ...[
            options?.noButtonStyle
                ? {}
                : {
                    ...buttonStyle,
                    displayName: 'Approve Button Style',
                    name: 'buttonApprovalStyle',
                    displayOptions: {
                        show: {
                            approvalType: ['single', 'double'],
                        },
                    },
                },
        ],
        {
            displayName: 'Disapprove Button Label',
            name: 'disapproveLabel',
            type: 'string',
            default: options?.defaultDisapproveLabel || 'Decline',
            displayOptions: {
                show: {
                    approvalType: ['double'],
                },
            },
        },
        ...[
            options?.noButtonStyle
                ? {}
                : {
                    ...buttonStyle,
                    displayName: 'Disapprove Button Style',
                    name: 'buttonDisapprovalStyle',
                    default: 'secondary',
                    displayOptions: {
                        show: {
                            approvalType: ['double'],
                        },
                    },
                },
        ],
    ].filter((p) => Object.keys(p).length);
    const sendAndWait = [
        ...targetProperties,
        {
            displayName: 'Subject',
            name: 'subject',
            type: 'string',
            default: '',
            required: true,
            placeholder: 'e.g. Approval required',
        },
        {
            displayName: 'Message',
            name: 'message',
            type: 'string',
            default: '',
            required: true,
            typeOptions: {
                rows: 4,
            },
        },
        {
            displayName: 'Response Type',
            name: 'responseType',
            type: 'options',
            default: 'approval',
            options: [
                {
                    name: 'Approval',
                    value: 'approval',
                    description: 'User can approve/disapprove from within the message',
                },
                {
                    name: 'Free Text',
                    value: 'freeText',
                    description: 'User can submit a response via a form',
                },
                {
                    name: 'Custom Form',
                    value: 'customForm',
                    description: 'User can submit a response via a custom form',
                },
            ],
        },
        ...(0, n8n_workflow_1.updateDisplayOptions)({
            show: {
                responseType: ['customForm'],
            },
        }, Form_node_1.formFieldsProperties),
        {
            displayName: 'Approval Options',
            name: 'approvalOptions',
            type: 'fixedCollection',
            placeholder: 'Add option',
            default: {},
            options: [
                {
                    displayName: 'Values',
                    name: 'values',
                    values: approvalOptionsValues,
                },
            ],
            displayOptions: {
                show: {
                    responseType: ['approval'],
                },
            },
        },
        {
            displayName: 'Options',
            name: 'options',
            type: 'collection',
            placeholder: 'Add option',
            default: {},
            options: [limitWaitTimeProperties],
            displayOptions: {
                show: {
                    responseType: ['approval'],
                },
            },
        },
        {
            displayName: 'Options',
            name: 'options',
            type: 'collection',
            placeholder: 'Add option',
            default: {},
            options: [
                {
                    displayName: 'Message Button Label',
                    name: 'messageButtonLabel',
                    type: 'string',
                    default: 'Respond',
                },
                {
                    displayName: 'Response Form Title',
                    name: 'responseFormTitle',
                    description: 'Title of the form that the user can access to provide their response',
                    type: 'string',
                    default: '',
                },
                {
                    displayName: 'Response Form Description',
                    name: 'responseFormDescription',
                    description: 'Description of the form that the user can access to provide their response',
                    type: 'string',
                    default: '',
                },
                {
                    displayName: 'Response Form Button Label',
                    name: 'responseFormButtonLabel',
                    type: 'string',
                    default: 'Submit',
                },
                limitWaitTimeProperties,
            ],
            displayOptions: {
                show: {
                    responseType: ['freeText', 'customForm'],
                },
            },
        },
        ...additionalProperties,
    ];
    return (0, n8n_workflow_1.updateDisplayOptions)({
        show: {
            resource: [resource],
            operation: [n8n_workflow_1.SEND_AND_WAIT_OPERATION],
        },
    }, sendAndWait);
}
const getFormResponseCustomizations = (context) => {
    const message = context.getNodeParameter('message', '');
    const options = context.getNodeParameter('options', {});
    let formTitle = '';
    if (options.responseFormTitle) {
        formTitle = options.responseFormTitle;
    }
    let formDescription = message;
    if (options.responseFormDescription) {
        formDescription = options.responseFormDescription;
    }
    formDescription = formDescription.replace(/\\n/g, '\n').replace(/<br>/g, '\n');
    let buttonLabel = 'Submit';
    if (options.responseFormButtonLabel) {
        buttonLabel = options.responseFormButtonLabel;
    }
    return {
        formTitle,
        formDescription,
        buttonLabel,
    };
};
async function sendAndWaitWebhook() {
    const method = this.getRequestObject().method;
    const res = this.getResponseObject();
    const responseType = this.getNodeParameter('responseType', 'approval');
    if (responseType === 'freeText') {
        if (method === 'GET') {
            const { formTitle, formDescription, buttonLabel } = getFormResponseCustomizations(this);
            const data = (0, utils_1.prepareFormData)({
                formTitle,
                formDescription,
                formSubmittedHeader: 'Got it, thanks',
                formSubmittedText: 'This page can be closed now',
                buttonLabel,
                redirectUrl: undefined,
                formFields: [
                    {
                        fieldLabel: 'Response',
                        fieldType: 'textarea',
                        requiredField: true,
                    },
                ],
                testRun: false,
                query: {},
            });
            res.render('form-trigger', data);
            return {
                noWebhookResponse: true,
            };
        }
        if (method === 'POST') {
            const data = this.getBodyData().data;
            return {
                webhookResponse: email_templates_1.ACTION_RECORDED_PAGE,
                workflowData: [[{ json: { data: { text: data[INPUT_FIELD_IDENTIFIER] } } }]],
            };
        }
    }
    if (responseType === 'customForm') {
        const defineForm = this.getNodeParameter('defineForm', 'fields');
        let fields = [];
        if (defineForm === 'json') {
            try {
                const jsonOutput = this.getNodeParameter('jsonOutput', '', {
                    rawExpressions: true,
                });
                fields = (0, n8n_workflow_1.tryToParseJsonToFormFields)((0, utils_1.resolveRawData)(this, jsonOutput));
            }
            catch (error) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), error.message, {
                    description: error.message,
                });
            }
        }
        else {
            fields = this.getNodeParameter('formFields.values', []);
        }
        if (method === 'GET') {
            const { formTitle, formDescription, buttonLabel } = getFormResponseCustomizations(this);
            const data = (0, utils_1.prepareFormData)({
                formTitle,
                formDescription,
                formSubmittedHeader: 'Got it, thanks',
                formSubmittedText: 'This page can be closed now',
                buttonLabel,
                redirectUrl: undefined,
                formFields: fields,
                testRun: false,
                query: {},
            });
            res.render('form-trigger', data);
            return {
                noWebhookResponse: true,
            };
        }
        if (method === 'POST') {
            const returnItem = await (0, utils_1.prepareFormReturnItem)(this, fields, 'production', true);
            const json = returnItem.json;
            delete json.submittedAt;
            delete json.formMode;
            returnItem.json = { data: json };
            return {
                webhookResponse: email_templates_1.ACTION_RECORDED_PAGE,
                workflowData: [[returnItem]],
            };
        }
    }
    const query = this.getRequestObject().query;
    const approved = query.approved === 'true';
    return {
        webhookResponse: email_templates_1.ACTION_RECORDED_PAGE,
        workflowData: [[{ json: { data: { approved } } }]],
    };
}
function getSendAndWaitConfig(context) {
    const message = (0, utilities_1.escapeHtml)(context.getNodeParameter('message', 0, '').trim())
        .replace(/\\n/g, '\n')
        .replace(/<br>/g, '\n');
    const subject = (0, utilities_1.escapeHtml)(context.getNodeParameter('subject', 0, ''));
    const resumeUrl = context.evaluateExpression('{{ $execution?.resumeUrl }}', 0);
    const nodeId = context.evaluateExpression('{{ $nodeId }}', 0);
    const approvalOptions = context.getNodeParameter('approvalOptions.values', 0, {});
    const config = {
        title: subject,
        message,
        url: `${resumeUrl}/${nodeId}`,
        options: [],
    };
    const responseType = context.getNodeParameter('responseType', 0, 'approval');
    if (responseType === 'freeText' || responseType === 'customForm') {
        const label = context.getNodeParameter('options.messageButtonLabel', 0, 'Respond');
        config.options.push({
            label,
            value: 'true',
            style: 'primary',
        });
    }
    else if (approvalOptions.approvalType === 'double') {
        const approveLabel = (0, utilities_1.escapeHtml)(approvalOptions.approveLabel || 'Approve');
        const buttonApprovalStyle = approvalOptions.buttonApprovalStyle || 'primary';
        const disapproveLabel = (0, utilities_1.escapeHtml)(approvalOptions.disapproveLabel || 'Disapprove');
        const buttonDisapprovalStyle = approvalOptions.buttonDisapprovalStyle || 'secondary';
        config.options.push({
            label: disapproveLabel,
            value: 'false',
            style: buttonDisapprovalStyle,
        });
        config.options.push({
            label: approveLabel,
            value: 'true',
            style: buttonApprovalStyle,
        });
    }
    else {
        const label = (0, utilities_1.escapeHtml)(approvalOptions.approveLabel || 'Approve');
        const style = approvalOptions.buttonApprovalStyle || 'primary';
        config.options.push({
            label,
            value: 'true',
            style,
        });
    }
    return config;
}
function createButton(url, label, approved, style) {
    let buttonStyle = email_templates_1.BUTTON_STYLE_PRIMARY;
    if (style === 'secondary') {
        buttonStyle = email_templates_1.BUTTON_STYLE_SECONDARY;
    }
    return `<a href="${url}?approved=${approved}" target="_blank" style="${buttonStyle}">${label}</a>`;
}
function createEmail(context) {
    const to = context.getNodeParameter('sendTo', 0, '').trim();
    const config = getSendAndWaitConfig(context);
    if (to.indexOf('@') === -1 || (to.match(/@/g) || []).length > 1) {
        const description = `The email address '${to}' in the 'To' field isn't valid or contains multiple addresses. Please provide only a single email address.`;
        throw new n8n_workflow_1.NodeOperationError(context.getNode(), 'Invalid email address', {
            description,
            itemIndex: 0,
        });
    }
    const buttons = [];
    for (const option of config.options) {
        buttons.push(createButton(config.url, option.label, option.value, option.style));
    }
    const instanceId = context.getInstanceId();
    const email = {
        to,
        subject: config.title,
        body: '',
        htmlBody: (0, email_templates_1.createEmailBody)(config.message, buttons.join('\n'), instanceId),
    };
    return email;
}
function configureWaitTillDate(context) {
    let waitTill = n8n_workflow_1.WAIT_INDEFINITELY;
    const limitWaitTime = context.getNodeParameter('options.limitWaitTime.values', 0, {});
    if (Object.keys(limitWaitTime).length) {
        try {
            if (limitWaitTime.limitType === 'afterTimeInterval') {
                let waitAmount = limitWaitTime.resumeAmount;
                if (limitWaitTime.resumeUnit === 'minutes') {
                    waitAmount *= 60;
                }
                if (limitWaitTime.resumeUnit === 'hours') {
                    waitAmount *= 60 * 60;
                }
                if (limitWaitTime.resumeUnit === 'days') {
                    waitAmount *= 60 * 60 * 24;
                }
                waitAmount *= 1000;
                waitTill = new Date(new Date().getTime() + waitAmount);
            }
            else {
                waitTill = new Date(limitWaitTime.maxDateAndTime);
            }
            if (isNaN(waitTill.getTime())) {
                throw new n8n_workflow_1.ApplicationError('Invalid date format');
            }
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(context.getNode(), 'Could not configure Limit Wait Time', {
                description: error.message,
            });
        }
    }
    return waitTill;
}
//# sourceMappingURL=utils.js.map