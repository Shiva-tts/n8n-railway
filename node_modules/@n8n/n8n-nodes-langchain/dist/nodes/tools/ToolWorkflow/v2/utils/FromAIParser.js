"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AIParametersParser = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const zod_1 = require("zod");
class AIParametersParser {
    constructor(ctx) {
        this.ctx = ctx;
    }
    generateZodSchema(placeholder) {
        let schema;
        switch (placeholder.type?.toLowerCase()) {
            case 'string':
                schema = zod_1.z.string();
                break;
            case 'number':
                schema = zod_1.z.number();
                break;
            case 'boolean':
                schema = zod_1.z.boolean();
                break;
            case 'json':
                schema = zod_1.z.record(zod_1.z.any());
                break;
            default:
                schema = zod_1.z.string();
        }
        if (placeholder.description) {
            schema = schema.describe(`${schema.description ?? ''} ${placeholder.description}`.trim());
        }
        if (placeholder.defaultValue !== undefined) {
            schema = schema.default(placeholder.defaultValue);
        }
        return schema;
    }
    traverseNodeParameters(payload, collectedArgs) {
        if (typeof payload === 'string') {
            const fromAICalls = this.extractFromAICalls(payload);
            fromAICalls.forEach((call) => collectedArgs.push(call));
        }
        else if (Array.isArray(payload)) {
            payload.forEach((item) => this.traverseNodeParameters(item, collectedArgs));
        }
        else if (typeof payload === 'object' && payload !== null) {
            Object.values(payload).forEach((value) => this.traverseNodeParameters(value, collectedArgs));
        }
    }
    extractFromAICalls(str) {
        const args = [];
        const pattern = /\$fromAI\s*\(\s*/gi;
        let match;
        while ((match = pattern.exec(str)) !== null) {
            const startIndex = match.index + match[0].length;
            let current = startIndex;
            let inQuotes = false;
            let quoteChar = '';
            let parenthesesCount = 1;
            let argsString = '';
            while (current < str.length && parenthesesCount > 0) {
                const char = str[current];
                if (inQuotes) {
                    if (char === '\\' && current + 1 < str.length) {
                        argsString += char + str[current + 1];
                        current += 2;
                        continue;
                    }
                    if (char === quoteChar) {
                        inQuotes = false;
                        quoteChar = '';
                    }
                    argsString += char;
                }
                else {
                    if (['"', "'", '`'].includes(char)) {
                        inQuotes = true;
                        quoteChar = char;
                    }
                    else if (char === '(') {
                        parenthesesCount++;
                    }
                    else if (char === ')') {
                        parenthesesCount--;
                    }
                    if (parenthesesCount > 0 || char !== ')') {
                        argsString += char;
                    }
                }
                current++;
            }
            if (parenthesesCount === 0) {
                try {
                    const parsedArgs = this.parseArguments(argsString);
                    args.push(parsedArgs);
                }
                catch (error) {
                    throw new n8n_workflow_1.NodeOperationError(this.ctx.getNode(), `Failed to parse $fromAI arguments: ${argsString}: ${error}`);
                }
            }
            else {
                throw new n8n_workflow_1.NodeOperationError(this.ctx.getNode(), `Unbalanced parentheses while parsing $fromAI call: ${str.slice(startIndex)}`);
            }
        }
        return args;
    }
    parseArguments(argsString) {
        const args = [];
        let currentArg = '';
        let inQuotes = false;
        let quoteChar = '';
        let escapeNext = false;
        for (let i = 0; i < argsString.length; i++) {
            const char = argsString[i];
            if (escapeNext) {
                currentArg += char;
                escapeNext = false;
                continue;
            }
            if (char === '\\') {
                escapeNext = true;
                continue;
            }
            if (['"', "'", '`'].includes(char)) {
                if (!inQuotes) {
                    inQuotes = true;
                    quoteChar = char;
                    currentArg += char;
                }
                else if (char === quoteChar) {
                    inQuotes = false;
                    quoteChar = '';
                    currentArg += char;
                }
                else {
                    currentArg += char;
                }
                continue;
            }
            if (char === ',' && !inQuotes) {
                args.push(currentArg.trim());
                currentArg = '';
                continue;
            }
            currentArg += char;
        }
        if (currentArg) {
            args.push(currentArg.trim());
        }
        const cleanArgs = args.map((arg) => {
            const trimmed = arg.trim();
            if ((trimmed.startsWith("'") && trimmed.endsWith("'")) ||
                (trimmed.startsWith('`') && trimmed.endsWith('`')) ||
                (trimmed.startsWith('"') && trimmed.endsWith('"'))) {
                return trimmed
                    .slice(1, -1)
                    .replace(/\\'/g, "'")
                    .replace(/\\`/g, '`')
                    .replace(/\\"/g, '"')
                    .replace(/\\\\/g, '\\');
            }
            return trimmed;
        });
        const type = cleanArgs?.[2] || 'string';
        if (!['string', 'number', 'boolean', 'json'].includes(type.toLowerCase())) {
            throw new n8n_workflow_1.NodeOperationError(this.ctx.getNode(), `Invalid type: ${type}`);
        }
        return {
            key: cleanArgs[0] || '',
            description: cleanArgs[1],
            type: (cleanArgs?.[2] ?? 'string'),
            defaultValue: this.parseDefaultValue(cleanArgs[3]),
        };
    }
    parseDefaultValue(value) {
        if (value === undefined || value === '')
            return undefined;
        const lowerValue = value.toLowerCase();
        if (lowerValue === 'true')
            return true;
        if (lowerValue === 'false')
            return false;
        if (!isNaN(Number(value)))
            return Number(value);
        try {
            return (0, n8n_workflow_1.jsonParse)(value);
        }
        catch {
            return value;
        }
    }
}
exports.AIParametersParser = AIParametersParser;
//# sourceMappingURL=FromAIParser.js.map