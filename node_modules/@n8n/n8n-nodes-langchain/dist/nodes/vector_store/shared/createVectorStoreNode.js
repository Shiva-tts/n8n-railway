"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVectorStoreNode = void 0;
const tools_1 = require("langchain/tools");
const n8n_workflow_1 = require("n8n-workflow");
const helpers_1 = require("../../../utils/helpers");
const logWrapper_1 = require("../../../utils/logWrapper");
const N8nJsonLoader_1 = require("../../../utils/N8nJsonLoader");
const sharedFields_1 = require("../../../utils/sharedFields");
const processDocuments_1 = require("./processDocuments");
const DEFAULT_OPERATION_MODES = [
    'load',
    'insert',
    'retrieve',
    'retrieve-as-tool',
];
function transformDescriptionForOperationMode(fields, mode) {
    return fields.map((field) => ({
        ...field,
        displayOptions: { show: { mode: Array.isArray(mode) ? mode : [mode] } },
    }));
}
function isUpdateSupported(args) {
    return args.meta.operationModes?.includes('update') ?? false;
}
function getOperationModeOptions(args) {
    const enabledOperationModes = args.meta.operationModes ?? DEFAULT_OPERATION_MODES;
    const allOptions = [
        {
            name: 'Get Many',
            value: 'load',
            description: 'Get many ranked documents from vector store for query',
            action: 'Get ranked documents from vector store',
        },
        {
            name: 'Insert Documents',
            value: 'insert',
            description: 'Insert documents into vector store',
            action: 'Add documents to vector store',
        },
        {
            name: 'Retrieve Documents (As Vector Store for Chain/Tool)',
            value: 'retrieve',
            description: 'Retrieve documents from vector store to be used as vector store with AI nodes',
            action: 'Retrieve documents for Chain/Tool as Vector Store',
            outputConnectionType: "ai_vectorStore",
        },
        {
            name: 'Retrieve Documents (As Tool for AI Agent)',
            value: 'retrieve-as-tool',
            description: 'Retrieve documents from vector store to be used as tool with AI nodes',
            action: 'Retrieve documents for AI Agent as Tool',
            outputConnectionType: "ai_tool",
        },
        {
            name: 'Update Documents',
            value: 'update',
            description: 'Update documents in vector store by ID',
            action: 'Update vector store documents',
        },
    ];
    return allOptions.filter(({ value }) => enabledOperationModes.includes(value));
}
const createVectorStoreNode = (args) => class VectorStoreNodeType {
    constructor() {
        this.description = {
            displayName: args.meta.displayName,
            name: args.meta.name,
            description: args.meta.description,
            icon: args.meta.icon,
            iconColor: args.meta.iconColor,
            group: ['transform'],
            version: 1,
            defaults: {
                name: args.meta.displayName,
            },
            codex: {
                categories: ['AI'],
                subcategories: {
                    AI: ['Vector Stores', 'Tools', 'Root Nodes'],
                    Tools: ['Other Tools'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: args.meta.docsUrl,
                        },
                    ],
                },
            },
            credentials: args.meta.credentials,
            inputs: `={{
			((parameters) => {
				const mode = parameters?.mode;
				const inputs = [{ displayName: "Embedding", type: "${"ai_embedding"}", required: true, maxConnections: 1}]

				if (mode === 'retrieve-as-tool') {
					return inputs;
				}

				if (['insert', 'load', 'update'].includes(mode)) {
					inputs.push({ displayName: "", type: "${"main"}"})
				}

				if (['insert'].includes(mode)) {
					inputs.push({ displayName: "Document", type: "${"ai_document"}", required: true, maxConnections: 1})
				}
				return inputs
			})($parameter)
		}}`,
            outputs: `={{
			((parameters) => {
				const mode = parameters?.mode ?? 'retrieve';

				if (mode === 'retrieve-as-tool') {
					return [{ displayName: "Tool", type: "${"ai_tool"}"}]
				}

				if (mode === 'retrieve') {
					return [{ displayName: "Vector Store", type: "${"ai_vectorStore"}"}]
				}
				return [{ displayName: "", type: "${"main"}"}]
			})($parameter)
		}}`,
            properties: [
                {
                    displayName: 'Operation Mode',
                    name: 'mode',
                    type: 'options',
                    noDataExpression: true,
                    default: 'retrieve',
                    options: getOperationModeOptions(args),
                },
                {
                    ...(0, sharedFields_1.getConnectionHintNoticeField)(["ai_retriever"]),
                    displayOptions: {
                        show: {
                            mode: ['retrieve'],
                        },
                    },
                },
                {
                    displayName: 'Name',
                    name: 'toolName',
                    type: 'string',
                    default: '',
                    required: true,
                    description: 'Name of the vector store',
                    placeholder: 'e.g. company_knowledge_base',
                    validateType: 'string-alphanumeric',
                    displayOptions: {
                        show: {
                            mode: ['retrieve-as-tool'],
                        },
                    },
                },
                {
                    displayName: 'Description',
                    name: 'toolDescription',
                    type: 'string',
                    default: '',
                    required: true,
                    typeOptions: { rows: 2 },
                    description: 'Explain to the LLM what this tool does, a good, specific description would allow LLMs to produce expected results much more often',
                    placeholder: `e.g. ${args.meta.description}`,
                    displayOptions: {
                        show: {
                            mode: ['retrieve-as-tool'],
                        },
                    },
                },
                ...args.sharedFields,
                ...transformDescriptionForOperationMode(args.insertFields ?? [], 'insert'),
                {
                    displayName: 'Prompt',
                    name: 'prompt',
                    type: 'string',
                    default: '',
                    required: true,
                    description: 'Search prompt to retrieve matching documents from the vector store using similarity-based ranking',
                    displayOptions: {
                        show: {
                            mode: ['load'],
                        },
                    },
                },
                {
                    displayName: 'Limit',
                    name: 'topK',
                    type: 'number',
                    default: 4,
                    description: 'Number of top results to fetch from vector store',
                    displayOptions: {
                        show: {
                            mode: ['load', 'retrieve-as-tool'],
                        },
                    },
                },
                {
                    displayName: 'Include Metadata',
                    name: 'includeDocumentMetadata',
                    type: 'boolean',
                    default: true,
                    description: 'Whether or not to include document metadata',
                    displayOptions: {
                        show: {
                            mode: ['load', 'retrieve-as-tool'],
                        },
                    },
                },
                {
                    displayName: 'ID',
                    name: 'id',
                    type: 'string',
                    default: '',
                    required: true,
                    description: 'ID of an embedding entry',
                    displayOptions: {
                        show: {
                            mode: ['update'],
                        },
                    },
                },
                ...transformDescriptionForOperationMode(args.loadFields ?? [], [
                    'load',
                    'retrieve-as-tool',
                ]),
                ...transformDescriptionForOperationMode(args.retrieveFields ?? [], 'retrieve'),
                ...transformDescriptionForOperationMode(args.updateFields ?? [], 'update'),
            ],
        };
        this.methods = args.methods;
    }
    async execute() {
        const mode = this.getNodeParameter('mode', 0);
        const embeddings = (await this.getInputConnectionData("ai_embedding", 0));
        if (mode === 'load') {
            const items = this.getInputData(0);
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const filter = (0, helpers_1.getMetadataFiltersValues)(this, itemIndex);
                const vectorStore = await args.getVectorStoreClient(this, undefined, embeddings, itemIndex);
                try {
                    const prompt = this.getNodeParameter('prompt', itemIndex);
                    const topK = this.getNodeParameter('topK', itemIndex, 4);
                    const embeddedPrompt = await embeddings.embedQuery(prompt);
                    const docs = await vectorStore.similaritySearchVectorWithScore(embeddedPrompt, topK, filter);
                    const includeDocumentMetadata = this.getNodeParameter('includeDocumentMetadata', itemIndex, true);
                    const serializedDocs = docs.map(([doc, score]) => {
                        const document = {
                            pageContent: doc.pageContent,
                            ...(includeDocumentMetadata ? { metadata: doc.metadata } : {}),
                        };
                        return {
                            json: { document, score },
                            pairedItem: {
                                item: itemIndex,
                            },
                        };
                    });
                    resultData.push(...serializedDocs);
                    (0, helpers_1.logAiEvent)(this, 'ai-vector-store-searched', { query: prompt });
                }
                finally {
                    args.releaseVectorStoreClient?.(vectorStore);
                }
            }
            return [resultData];
        }
        if (mode === 'insert') {
            const items = this.getInputData();
            const documentInput = (await this.getInputConnectionData("ai_document", 0));
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                if (this.getExecutionCancelSignal()?.aborted) {
                    break;
                }
                const itemData = items[itemIndex];
                const { processedDocuments, serializedDocuments } = await (0, processDocuments_1.processDocument)(documentInput, itemData, itemIndex);
                resultData.push(...serializedDocuments);
                await args.populateVectorStore(this, embeddings, processedDocuments, itemIndex);
                (0, helpers_1.logAiEvent)(this, 'ai-vector-store-populated');
            }
            return [resultData];
        }
        if (mode === 'update') {
            if (!isUpdateSupported(args)) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Update operation is not implemented for this Vector Store');
            }
            const items = this.getInputData();
            const loader = new N8nJsonLoader_1.N8nJsonLoader(this);
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const itemData = items[itemIndex];
                const documentId = this.getNodeParameter('id', itemIndex, '', {
                    extractValue: true,
                });
                const vectorStore = await args.getVectorStoreClient(this, undefined, embeddings, itemIndex);
                try {
                    const { processedDocuments, serializedDocuments } = await (0, processDocuments_1.processDocument)(loader, itemData, itemIndex);
                    if (processedDocuments?.length !== 1) {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Single document per item expected');
                    }
                    resultData.push(...serializedDocuments);
                    await vectorStore.addDocuments(processedDocuments, {
                        ids: [documentId],
                    });
                    (0, helpers_1.logAiEvent)(this, 'ai-vector-store-updated');
                }
                finally {
                    args.releaseVectorStoreClient?.(vectorStore);
                }
            }
            return [resultData];
        }
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Only the "load", "update" and "insert" operation modes are supported with execute');
    }
    async supplyData(itemIndex) {
        const mode = this.getNodeParameter('mode', 0);
        const filter = (0, helpers_1.getMetadataFiltersValues)(this, itemIndex);
        const embeddings = (await this.getInputConnectionData("ai_embedding", 0));
        if (mode === 'retrieve') {
            const vectorStore = await args.getVectorStoreClient(this, filter, embeddings, itemIndex);
            return {
                response: (0, logWrapper_1.logWrapper)(vectorStore, this),
                closeFunction: async () => {
                    args.releaseVectorStoreClient?.(vectorStore);
                },
            };
        }
        if (mode === 'retrieve-as-tool') {
            const toolDescription = this.getNodeParameter('toolDescription', itemIndex);
            const toolName = this.getNodeParameter('toolName', itemIndex);
            const topK = this.getNodeParameter('topK', itemIndex, 4);
            const includeDocumentMetadata = this.getNodeParameter('includeDocumentMetadata', itemIndex, true);
            const vectorStoreTool = new tools_1.DynamicTool({
                name: toolName,
                description: toolDescription,
                func: async (input) => {
                    const vectorStore = await args.getVectorStoreClient(this, filter, embeddings, itemIndex);
                    try {
                        const embeddedPrompt = await embeddings.embedQuery(input);
                        const documents = await vectorStore.similaritySearchVectorWithScore(embeddedPrompt, topK, filter);
                        return documents
                            .map((document) => {
                            if (includeDocumentMetadata) {
                                return { type: 'text', text: JSON.stringify(document[0]) };
                            }
                            return {
                                type: 'text',
                                text: JSON.stringify({ pageContent: document[0].pageContent }),
                            };
                        })
                            .filter((document) => !!document);
                    }
                    finally {
                        args.releaseVectorStoreClient?.(vectorStore);
                    }
                },
            });
            return {
                response: (0, logWrapper_1.logWrapper)(vectorStoreTool, this),
            };
        }
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Only the "retrieve" and "retrieve-as-tool" operation mode is supported to supply data');
    }
};
exports.createVectorStoreNode = createVectorStoreNode;
//# sourceMappingURL=createVectorStoreNode.js.map