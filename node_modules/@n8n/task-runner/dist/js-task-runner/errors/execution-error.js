"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionError = void 0;
const serializable_error_1 = require("./serializable-error");
const VM_WRAPPER_FN_NAME = 'VmCodeWrapper';
class ExecutionError extends serializable_error_1.SerializableError {
    constructor(error, itemIndex) {
        super(error.message);
        this.description = null;
        this.itemIndex = undefined;
        this.context = undefined;
        this.lineNumber = undefined;
        this.itemIndex = itemIndex;
        if (this.itemIndex !== undefined) {
            this.context = { itemIndex: this.itemIndex };
        }
        Object.defineProperty(this, 'stack', {
            value: error.stack,
            enumerable: true,
        });
        this.populateFromStack();
    }
    populateFromStack() {
        const stackRows = (this.stack ?? '').split('\n');
        if (stackRows.length === 0) {
            this.message = 'Unknown error';
            return;
        }
        const messageRow = stackRows.find((line) => line.includes('Error:'));
        const lineNumberRow = stackRows.find((line) => line.includes(`at ${VM_WRAPPER_FN_NAME} `));
        const lineNumberDisplay = this.toLineNumberDisplay(lineNumberRow);
        if (!messageRow) {
            this.message = `Unknown error ${lineNumberDisplay}`;
            return;
        }
        const [errorDetails, errorType] = this.toErrorDetailsAndType(messageRow);
        if (errorType)
            this.description = errorType;
        if (!errorDetails) {
            this.message = `Unknown error ${lineNumberDisplay}`;
            return;
        }
        this.message = `${errorDetails} ${lineNumberDisplay}`;
    }
    toLineNumberDisplay(lineNumberRow) {
        if (!lineNumberRow)
            return '';
        const regex = new RegExp(`at ${VM_WRAPPER_FN_NAME} \\(evalmachine\\.<anonymous>:(?<lineNumber>\\d+):`);
        const errorLineNumberMatch = lineNumberRow.match(regex);
        if (!errorLineNumberMatch?.groups?.lineNumber)
            return null;
        const lineNumber = errorLineNumberMatch.groups.lineNumber;
        if (!lineNumber)
            return '';
        this.lineNumber = Number(lineNumber);
        return this.itemIndex === undefined
            ? `[line ${lineNumber}]`
            : `[line ${lineNumber}, for item ${this.itemIndex}]`;
    }
    toErrorDetailsAndType(messageRow) {
        if (!messageRow)
            return [null, null];
        const [errorDetails, errorType] = messageRow
            .split(':')
            .reverse()
            .map((i) => i.trim());
        return [errorDetails, errorType === 'Error' ? null : errorType];
    }
}
exports.ExecutionError = ExecutionError;
//# sourceMappingURL=execution-error.js.map