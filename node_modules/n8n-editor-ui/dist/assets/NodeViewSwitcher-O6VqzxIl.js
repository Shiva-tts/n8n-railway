const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/RunDataTable-DGMN5nF6.js","assets/index-DablXALM.js","assets/index-Bs_8II2j.css","assets/useExecutionHelpers-F_WL-Kvp.js","assets/RunDataTable-CX7gToH4.css","assets/RunDataJson-wyo45w7C.js","assets/useCanvasOperations-CEPzjX8I.js","assets/usePinnedData-BEOJK2e-.js","assets/useCanvasOperations-CEWecDkR.css","assets/useRunWorkflow-CoRVHZg2.js","assets/useRunWorkflow-DWoFsQdi.css","assets/FileSaver.min-DRMcruyG.js","assets/useWorkflowActivate-wvqU9rPU.js","assets/pushConnection.store-DmLr_C_P.js","assets/useExecutionDebugging-Pzj1BQ1f.js","assets/useBeforeUnload-C9Q3IFHU.js","assets/easyAiWorkflowUtils-BLdDr_bc.js","assets/RunDataJson-Txw0lqay.css","assets/RunDataSearch-B3EyVssL.js","assets/RunDataSearch-R6qtl0Jf.css","assets/NodeCreation-KBmCqr6_.js","assets/NodeCreation-RKvezEeg.css","assets/CanvasControls-Crujpx17.js","assets/CanvasControls-DTjEPKS0.css","assets/SetupWorkflowCredentialsButton-Cro6GHxL.js"])))=>i.map(i=>d[i]);
import { d as defineComponent, r as ref, q as computed, c as openBlock, h as createElementBlock, j as createBaseVNode, i as createVNode, br as _sfc_main$z, n as normalizeClass, w as withCtx, k as createTextVNode, t as toDisplayString, e as createBlock, f as createCommentVNode, l as unref, G as withKeys, I as withModifiers, g as useI18n, y as nextTick, m as resolveComponent, _ as _export_sfc, as as useNDVStore, T as useWorkflowsStore, bs as isCommunityPackageName, bt as NPM_PACKAGE_DOCS_BASE_URL, bu as BUILTIN_NODES_DOCS_URL, bv as COMMUNITY_NODES_INSTALLATION_DOCS_URL, bh as NodeConnectionType, aT as useExternalHooks, aj as useTelemetry, b as useRouter, b6 as useClipboard, a4 as useWorkflowHelpers, a as useToast, bw as OPEN_URL_PANEL_TRIGGER_NODE_TYPES, H as watch, F as Fragment, A as renderList, bx as PRODUCTION_ONLY_TRIGGER_NODE_TYPES, by as FORM_TRIGGER_NODE_TYPE, b7 as CHAT_TRIGGER_NODE_TYPE, E as onClickOutside, ap as h, bz as toValue, bA as toRef, bB as tryOnScopeDispose, bC as isIOS, bD as noop, bE as isObject, bF as isClient, bo as useNodeTypesStore, bp as useNodeHelpers, J as useDebounce, B as normalizeStyle, bG as nodeIssuesToString, be as getNodeInputs, bH as TitledList, K as useUIStore, a$ as mergeProps, bI as MANUAL_TRIGGER_NODE_TYPE, bJ as WEBHOOK_NODE_TYPE, bK as AI_TRANSFORM_NODE_TYPE, bL as AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT, bM as generateCodeForAiTransform, bN as AI_TRANSFORM_JS_CODE, ac as nodeViewEventBus, ak as useMessage, ae as MODAL_CONFIRM, bO as SWITCH_NODE_TYPE, bP as isEqual, bQ as captureException, p as useSettingsStore, au as usePostHog, bR as useCredentialsStore, u as useUsersStore, a1 as useProjectsStore, bS as OPEN_AI_API_CREDENTIAL_TYPE, bT as AI_CREDITS_EXPERIMENT, bU as useHistoryStore, o as onMounted, bV as importCurlEventBus, bW as ndvEventBus, x as onBeforeUnmount, bX as CUSTOM_NODES_DOCS_URL, ax as withDirectives, ay as vShow, bY as NodeCredentials, bZ as _sfc_main$A, b_ as ProjectTypes, bf as getConnectionTypes, bj as get, b$ as getNodeParameters, c0 as deepCopy, c1 as set, c2 as unset, c3 as RenameNodeCommand, c4 as isINodePropertyCollectionList, c5 as isINodePropertiesList, c6 as isINodePropertyOptionsList, c7 as displayParameter, c8 as Draggable, c9 as useThrottleFn, ca as useSlots, aI as useStorage, cb as LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH, s as renderSlot, cc as MAIN_NODE_PANEL_WIDTH, cd as requireVue, ce as getDefaultExportFromCjs, cf as sanitizeHtmlExports, cg as sanitizeHtml, ch as jsonParse, aO as N8nLink, ci as N8nText, aQ as _sfc_main$B, aP as N8nTooltip, a0 as useSourceControlStore, Z as useRootStore, U as useRoute, cj as toRef$1, ck as storeToRefs, cl as dataPinningEventBus, cm as MAX_DISPLAY_DATA_SIZE_SCHEMA_VIEW, cn as MAX_DISPLAY_DATA_SIZE, co as HTML_NODE_TYPE, cp as DATA_PINNING_DOCS_URL, cq as N8nCallout, cr as Suspense, cs as N8nRadioButtons, ct as N8nButton, cu as N8nSelect, cv as N8nTabs, cw as _sfc_main$C, cx as JsonEditor, cy as DATA_EDITING_DOCS_URL, cz as InfoTip, cA as _sfc_main$E, cB as N8nBlockUi, cC as defineAsyncComponent, cD as TRIMMED_TASK_DATA_CONNECTIONS_KEY, cE as executionDataToJson, cF as NODE_TYPES_EXCLUDED_FROM_OUTPUT_NAME_APPEND, cG as isEmpty, bg as getNodeOutputs, cH as getNodeHints, cI as getGenericHints, cJ as LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG, cK as LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG, cL as clearJsonKey, cM as searchInObject, cN as isObject$1, cO as resolveDirective, cP as TEST_PIN_DATA, ar as __vitePreload, aS as createSlots, cQ as waitingNodeTooltip, cR as isPresent, cS as truncate, cT as createStaticVNode, b0 as resolveDynamicComponent, cU as uniqBy, cV as START_NODE_TYPE, cW as CRON_NODE_TYPE, cX as INTERVAL_NODE_TYPE, cY as CopyInput, cZ as Transition, C as createEventBus, c_ as isTriggerPanelObject, c$ as getTriggerNodeServiceName, V as VIEWS, af as WORKFLOW_SETTINGS_MODAL_KEY, d0 as useDeviceSupport, d1 as APP_MODALS_ELEMENT_ID, d2 as useStyles, d3 as EXECUTABLE_TRIGGER_NODE_TYPES, aB as STICKY_NODE_TYPE, d4 as BASE_NODE_SURVEY_URL, a8 as EnterpriseEditionFeature, d5 as getCurrentInstance, d6 as getAnchorPosition, d7 as isValidNodeConnectionType, d8 as getEndpointScope, d9 as getInputEndpointUUID, da as getInputEndpointStyle, db as getScope, dc as getInputNameOverlay, dd as NODE_INSERT_SPACER_BETWEEN_INPUT_GROUPS, de as NODE_MIN_INPUT_ITEMS_COUNT, df as getOutputEndpointUUID, dg as getOutputEndpointStyle, dh as getOutputNameOverlay, di as NO_OP_NODE_TYPE, dj as NODE_CONNECTION_TYPE_ALLOW_MULTIPLE, dk as GRID_SIZE, dl as isString, dm as isNumber, dn as assert, dp as CUSTOM_API_CALL_KEY, dq as FontAwesomeIcon, dr as xss, ds as WAIT_NODE_TYPE, dt as SEND_AND_WAIT_OPERATION, du as FORM_NODE_TYPE, dv as WAIT_INDEFINITELY, dw as SIMULATE_NODE_TYPE, dx as SIMULATE_TRIGGER_NODE_TYPE, dy as reactive, b4 as onUnmounted, $ as useCanvasStore, dz as getMousePosition, dA as getRelativePosition, dB as MOUSE_EVENT_BUTTON, dC as MOUSE_EVENT_BUTTONS, dD as KeyboardShortcutTooltip, a3 as useDocumentTitle, dE as NODE_CREATOR_OPEN_SOURCES, dF as mapStores, a2 as useNpsSurveyStore, at as useExecutionsStore, dG as useExternalSecretsStore, dH as useWorkflowsEEStore, dI as useEnvironmentsStore, aM as useTemplatesStore, D as useTagsStore, dJ as getBackgroundStyles, b8 as MANUAL_CHAT_TRIGGER_NODE_TYPE, al as getResourcePermissions, dK as getNodeViewTab, X as PLACEHOLDER_EMPTY_WORKFLOW_ID, an as MAIN_HEADER_TABS, dL as ready, aE as sourceControlEventBus, dM as historyBus, dN as generateNodesGraph, dO as N8nAddInputEndpointType, dP as TRIGGER_NODE_CREATOR_VIEW, dQ as getFixedNodesList, dR as tryToParseNumber, dS as MoveNodeCommand, ah as VALID_WORKFLOW_IMPORT_URL_REGEX, dT as UPDATE_WEBHOOK_ID_NODE_TYPES, bk as v4, dU as getNewNodePosition, dV as DRAG_EVENT_DATA_KEY, dW as getConnectorLengths, dX as MAX_X_TO_PUSH_DOWNSTREAM_NODES, dY as PUSH_NODES_OFFSET, dZ as NODE_SIZE, d_ as generateOffsets, d$ as nodeConnectionTypes, e0 as resetConnectionAfterPull, e1 as resetConnection, e2 as moveBackInputLabelPosition, e3 as hideOutputNameLabel, e4 as addConnectionActionsOverlay, e5 as getOverlay, e6 as OVERLAY_ENDPOINT_ARROW_ID, e7 as getConnectorPaintStyleData, e8 as AddConnectionCommand, e9 as addConnectionTestData, ea as showOrHideItemsLabel, eb as showOrHideMidpointArrow, ec as isJSPlumbConnection, ed as hideConnectionActions, ee as showConnectionActions, ef as resetInputLabelPosition, eg as getConnectionInfo, eh as showOutputNameLabel, ei as RemoveConnectionCommand, ej as isJSPlumbEndpointElement, ek as isElementIntersection, el as calculateElementIntersection, em as showDropConnectionState, en as showPullConnectionState, eo as AI_NODE_CREATOR_VIEW, ep as EVENT_CONNECTION_ABORT, eq as INTERCEPT_BEFORE_DROP, er as EVENT_CONNECTION, es as EVENT_DRAG_MOVE, et as EVENT_CONNECTION_MOUSEOVER, eu as EVENT_CONNECTION_MOUSEOUT, ev as EVENT_CONNECTION_MOVED, ew as EVENT_ENDPOINT_MOUSEOVER, ex as EVENT_ENDPOINT_MOUSEOUT, ey as EVENT_CONNECTION_DETACHED, ez as EVENT_CONNECTION_DRAG, eA as EVENT_PLUS_ENDPOINT_CLICK, eB as EVENT_ADD_INPUT_ENDPOINT_CLICK, eC as N8nPlusEndpointType, eD as CANVAS_AUTO_ADD_MANUAL_TRIGGER_EXPERIMENT, eE as MODAL_CANCEL, eF as addClassesToOverlays, eG as getJSPlumbEndpoints, eH as REGULAR_NODE_CREATOR_VIEW, eI as isSubNodeType, eJ as useDataSchema, eK as OVERLAY_RUN_ITEMS_ID, eL as RemoveNodeCommand, aa as useCssModule, eM as NEW_WORKFLOW_ID, eN as CanvasNodeRenderType, aw as onBeforeMount, eO as onActivated, eP as onDeactivated, eQ as CanvasConnectionMode, av as useLocalStorage, eR as onBeforeRouteLeave } from "./index-DablXALM.js";
import { u as useContextMenu, a as useNodeCreatorStore, C as ContextMenu, b as useUniqueNodeName, c as useViewStacks, d as useVueFlow, e as useCanvasMapping, _ as __unplugin_components_0$1, f as useCanvasOperations, g as createCanvasConnectionHandleString } from "./useCanvasOperations-CEPzjX8I.js";
import { u as usePinnedData, a as useNodeType } from "./usePinnedData-BEOJK2e-.js";
import { u as useRunWorkflow, _ as _sfc_main$D, R as RunDataAi } from "./useRunWorkflow-CoRVHZg2.js";
import { F as FileSaver_minExports } from "./FileSaver.min-DRMcruyG.js";
import { u as useExecutionHelpers, c as convertToDisplayDateComponents } from "./useExecutionHelpers-F_WL-Kvp.js";
import { u as useWorkflowActivate } from "./useWorkflowActivate-wvqU9rPU.js";
import { g as globalLinkActionsEventBus, u as usePushConnectionStore } from "./pushConnection.store-DmLr_C_P.js";
import { u as useExecutionDebugging } from "./useExecutionDebugging-Pzj1BQ1f.js";
import { u as useBeforeUnload } from "./useBeforeUnload-C9Q3IFHU.js";
import { g as getEasyAiWorkflowJson } from "./easyAiWorkflowUtils-BLdDr_bc.js";
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "NodeTitle",
  props: {
    modelValue: { default: "" },
    nodeType: { default: void 0 },
    readOnly: { type: Boolean, default: false }
  },
  emits: ["update:model-value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const editName = ref(false);
    const newName = ref("");
    const input = ref();
    const i18n = useI18n();
    const editable = computed(() => !props.readOnly && window === window.parent);
    async function onEdit() {
      newName.value = props.modelValue;
      editName.value = true;
      await nextTick();
      if (input.value) {
        input.value.focus();
      }
    }
    function onRename() {
      if (newName.value.trim() !== "") {
        emit("update:model-value", newName.value.trim());
      }
      editName.value = false;
    }
    return (_ctx, _cache) => {
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_n8n_input = resolveComponent("n8n-input");
      const _component_n8n_button = resolveComponent("n8n-button");
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_popover = resolveComponent("n8n-popover");
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(_ctx.$style.container),
        "data-test-id": "node-title-container",
        onClick: onEdit
      }, [
        createBaseVNode("span", {
          class: normalizeClass(_ctx.$style.iconWrapper)
        }, [
          createVNode(_sfc_main$z, {
            "node-type": _ctx.nodeType,
            size: 18
          }, null, 8, ["node-type"])
        ], 2),
        createVNode(_component_n8n_popover, {
          placement: "right",
          width: "200",
          visible: editName.value,
          disabled: !editable.value
        }, {
          reference: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass({ [_ctx.$style.title]: true, [_ctx.$style.hoverable]: editable.value })
            }, [
              createTextVNode(toDisplayString(_ctx.modelValue) + " ", 1),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.editIconContainer)
              }, [
                editable.value ? (openBlock(), createBlock(_component_font_awesome_icon, {
                  key: 0,
                  class: normalizeClass(_ctx.$style.editIcon),
                  icon: "pencil-alt"
                }, null, 8, ["class"])) : createCommentVNode("", true)
              ], 2)
            ], 2)
          ]),
          default: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.editContainer),
              onKeydown: [
                withKeys(onRename, ["enter"]),
                _cache[3] || (_cache[3] = withModifiers(() => {
                }, ["stop"])),
                _cache[4] || (_cache[4] = withKeys(($event) => editName.value = false, ["esc"]))
              ]
            }, [
              createVNode(_component_n8n_text, {
                bold: true,
                color: "text-base",
                tag: "div"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("ndv.title.renameNode")), 1)
                ]),
                _: 1
              }),
              createVNode(_component_n8n_input, {
                ref_key: "input",
                ref: input,
                modelValue: newName.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => newName.value = $event),
                size: "small",
                "data-test-id": "node-rename-input"
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.editButtons)
              }, [
                createVNode(_component_n8n_button, {
                  type: "secondary",
                  size: "small",
                  label: unref(i18n).baseText("ndv.title.cancel"),
                  onClick: _cache[1] || (_cache[1] = ($event) => editName.value = false),
                  onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers(() => {
                  }, ["stop"]), ["enter"]))
                }, null, 8, ["label"]),
                createVNode(_component_n8n_button, {
                  type: "primary",
                  size: "small",
                  label: unref(i18n).baseText("ndv.title.rename"),
                  onClick: onRename
                }, null, 8, ["label"])
              ], 2)
            ], 34)
          ]),
          _: 1
        }, 8, ["visible", "disabled"])
      ], 2);
    };
  }
});
const container$3 = "_container_1hchx_123";
const title$3 = "_title_1hchx_133";
const hoverable = "_hoverable_1hchx_141";
const editIcon = "_editIcon_1hchx_144";
const iconWrapper = "_iconWrapper_1hchx_148";
const editIconContainer = "_editIconContainer_1hchx_161";
const editButtons = "_editButtons_1hchx_167";
const editContainer = "_editContainer_1hchx_175";
const style0$f = {
  container: container$3,
  title: title$3,
  hoverable,
  editIcon,
  iconWrapper,
  editIconContainer,
  editButtons,
  editContainer
};
const cssModules$h = {
  "$style": style0$f
};
const NodeTitle = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__cssModules", cssModules$h]]);
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "NodeSettingsTabs",
  props: {
    modelValue: { default: "params" },
    nodeType: { default: void 0 },
    pushRef: { default: "" }
  },
  emits: ["update:model-value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const externalHooks = useExternalHooks();
    const ndvStore = useNDVStore();
    const workflowsStore = useWorkflowsStore();
    const i18n = useI18n();
    const telemetry = useTelemetry();
    const activeNode = computed(() => ndvStore.activeNode);
    const isCommunityNode = computed(() => {
      const nodeType = props.nodeType;
      if (nodeType) {
        return isCommunityPackageName(nodeType.name);
      }
      return false;
    });
    const packageName = computed(() => props.nodeType?.name.split(".")[0] ?? "");
    const documentationUrl = computed(() => {
      const nodeType = props.nodeType;
      if (!nodeType) {
        return "";
      }
      if (nodeType.documentationUrl && nodeType.documentationUrl.startsWith("http")) {
        return nodeType.documentationUrl;
      }
      const utmParams = new URLSearchParams({
        utm_source: "n8n_app",
        utm_medium: "node_settings_modal-credential_link",
        utm_campaign: nodeType.name
      });
      const primaryDocUrl = nodeType.codex?.resources?.primaryDocumentation?.[0]?.url;
      if (primaryDocUrl) {
        return `${primaryDocUrl}?${utmParams.toString()}`;
      }
      if (isCommunityNode.value) {
        return `${NPM_PACKAGE_DOCS_BASE_URL}${packageName.value}`;
      }
      return `${BUILTIN_NODES_DOCS_URL}?${utmParams.toString()}`;
    });
    const options = computed(() => {
      const options2 = [
        {
          label: i18n.baseText("nodeSettings.parameters"),
          value: "params"
        },
        {
          label: i18n.baseText("nodeSettings.settings"),
          value: "settings"
        }
      ];
      if (isCommunityNode.value) {
        options2.push({
          icon: "cube",
          value: "communityNode",
          align: "right",
          tooltip: i18n.baseText("generic.communityNode.tooltip", {
            interpolate: {
              docUrl: COMMUNITY_NODES_INSTALLATION_DOCS_URL,
              packageName: packageName.value
            }
          })
        });
      }
      if (documentationUrl.value) {
        options2.push({
          label: i18n.baseText("nodeSettings.docs"),
          value: "docs",
          href: documentationUrl.value,
          align: "right"
        });
      }
      return options2;
    });
    function onTabSelect(tab) {
      if (tab === "docs" && props.nodeType) {
        void externalHooks.run("dataDisplay.onDocumentationUrlClick", {
          nodeType: props.nodeType,
          documentationUrl: documentationUrl.value
        });
        telemetry.track("User clicked ndv link", {
          node_type: activeNode.value?.type,
          workflow_id: workflowsStore.workflowId,
          push_ref: props.pushRef,
          pane: NodeConnectionType.Main,
          type: "docs"
        });
      }
      if (tab === "settings" && props.nodeType) {
        telemetry.track("User viewed node settings", {
          node_type: props.nodeType.name,
          workflow_id: workflowsStore.workflowId
        });
      }
      if (tab === "settings" || tab === "params") {
        emit("update:model-value", tab);
      }
    }
    function onTooltipClick(tab, event) {
      if (tab === "communityNode" && event.target.localName === "a") {
        telemetry.track("user clicked cnr docs link", { source: "node details view" });
      }
    }
    return (_ctx, _cache) => {
      const _component_N8nTabs = resolveComponent("N8nTabs");
      return openBlock(), createBlock(_component_N8nTabs, {
        options: options.value,
        "model-value": _ctx.modelValue,
        "onUpdate:modelValue": onTabSelect,
        onTooltipClick
      }, null, 8, ["options", "model-value"]);
    };
  }
});
const _hoisted_1$h = {
  key: 0,
  class: "webhooks"
};
const _hoisted_2$b = ["title"];
const _hoisted_3$8 = {
  key: 0,
  class: "node-webhooks"
};
const _hoisted_4$7 = {
  key: 0,
  class: "url-selection"
};
const _hoisted_5$7 = {
  key: 0,
  class: "webhook-wrapper"
};
const _hoisted_6$7 = { class: "http-field" };
const _hoisted_7$5 = { class: "http-method" };
const _hoisted_8$5 = { class: "url-field" };
const _hoisted_9$4 = ["onClick"];
const _hoisted_10$3 = {
  key: 1,
  class: "webhook-wrapper"
};
const _hoisted_11$3 = { class: "url-field-full-width" };
const _hoisted_12$2 = ["onClick"];
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "NodeWebhooks",
  props: {
    node: {},
    nodeTypeDescription: {}
  },
  setup(__props) {
    const props = __props;
    const router = useRouter();
    const clipboard = useClipboard();
    const workflowHelpers = useWorkflowHelpers({ router });
    const toast = useToast();
    const i18n = useI18n();
    const telemetry = useTelemetry();
    const isMinimized = ref(
      props.nodeTypeDescription && !OPEN_URL_PANEL_TRIGGER_NODE_TYPES.includes(props.nodeTypeDescription.name)
    );
    const showUrlFor = ref("test");
    const isProductionOnly = computed(() => {
      return props.nodeTypeDescription && PRODUCTION_ONLY_TRIGGER_NODE_TYPES.includes(props.nodeTypeDescription.name);
    });
    const urlOptions = computed(() => [
      ...isProductionOnly.value ? [] : [{ label: baseText.value.testUrl, value: "test" }],
      {
        label: baseText.value.productionUrl,
        value: "production"
      }
    ]);
    const visibleWebhookUrls = computed(() => {
      return webhooksNode.value.filter((webhook) => {
        if (typeof webhook.ndvHideUrl === "string") {
          return !workflowHelpers.getWebhookExpressionValue(webhook, "ndvHideUrl");
        }
        return !webhook.ndvHideUrl;
      });
    });
    const webhooksNode = computed(() => {
      if (props.nodeTypeDescription?.webhooks === void 0) {
        return [];
      }
      return props.nodeTypeDescription.webhooks.filter(
        (webhookData) => webhookData.restartWebhook !== true
      );
    });
    const baseText = computed(() => {
      const nodeType = props.nodeTypeDescription?.name;
      switch (nodeType) {
        case CHAT_TRIGGER_NODE_TYPE:
          return {
            toggleTitle: i18n.baseText("nodeWebhooks.webhookUrls.chatTrigger"),
            clickToDisplay: i18n.baseText("nodeWebhooks.clickToDisplayWebhookUrls.formTrigger"),
            clickToHide: i18n.baseText("nodeWebhooks.clickToHideWebhookUrls.chatTrigger"),
            clickToCopy: i18n.baseText("nodeWebhooks.clickToCopyWebhookUrls.chatTrigger"),
            testUrl: i18n.baseText("nodeWebhooks.testUrl"),
            productionUrl: i18n.baseText("nodeWebhooks.productionUrl"),
            copyTitle: i18n.baseText("nodeWebhooks.showMessage.title.chatTrigger"),
            copyMessage: i18n.baseText("nodeWebhooks.showMessage.message.chatTrigger")
          };
        case FORM_TRIGGER_NODE_TYPE:
          return {
            toggleTitle: i18n.baseText("nodeWebhooks.webhookUrls.formTrigger"),
            clickToDisplay: i18n.baseText("nodeWebhooks.clickToDisplayWebhookUrls.formTrigger"),
            clickToHide: i18n.baseText("nodeWebhooks.clickToHideWebhookUrls.formTrigger"),
            clickToCopy: i18n.baseText("nodeWebhooks.clickToCopyWebhookUrls.formTrigger"),
            testUrl: i18n.baseText("nodeWebhooks.testUrl"),
            productionUrl: i18n.baseText("nodeWebhooks.productionUrl"),
            copyTitle: i18n.baseText("nodeWebhooks.showMessage.title.formTrigger"),
            copyMessage: i18n.baseText("nodeWebhooks.showMessage.message.formTrigger")
          };
        default:
          return {
            toggleTitle: i18n.baseText("nodeWebhooks.webhookUrls"),
            clickToDisplay: i18n.baseText("nodeWebhooks.clickToDisplayWebhookUrls"),
            clickToHide: i18n.baseText("nodeWebhooks.clickToHideWebhookUrls"),
            clickToCopy: i18n.baseText("nodeWebhooks.clickToCopyWebhookUrls"),
            testUrl: i18n.baseText("nodeWebhooks.testUrl"),
            productionUrl: i18n.baseText("nodeWebhooks.productionUrl"),
            copyTitle: i18n.baseText("nodeWebhooks.showMessage.title"),
            copyMessage: void 0
          };
      }
    });
    function copyWebhookUrl(webhookData) {
      const webhookUrl = getWebhookUrlDisplay(webhookData);
      void clipboard.copy(webhookUrl);
      toast.showMessage({
        title: baseText.value.copyTitle,
        message: baseText.value.copyMessage,
        type: "success"
      });
      telemetry.track("User copied webhook URL", {
        pane: "parameters",
        type: `${showUrlFor.value} url`
      });
    }
    function getWebhookUrlDisplay(webhookData) {
      if (props.node) {
        return workflowHelpers.getWebhookUrl(
          webhookData,
          props.node,
          isProductionOnly.value ? "production" : showUrlFor.value
        );
      }
      return "";
    }
    function isWebhookMethodVisible(webhook) {
      try {
        const method = workflowHelpers.getWebhookExpressionValue(webhook, "httpMethod", false);
        if (Array.isArray(method) && method.length !== 1) {
          return false;
        }
      } catch (error) {
      }
      if (typeof webhook.ndvHideMethod === "string") {
        return !workflowHelpers.getWebhookExpressionValue(webhook, "ndvHideMethod");
      }
      return !webhook.ndvHideMethod;
    }
    function getWebhookHttpMethod(webhook) {
      const method = workflowHelpers.getWebhookExpressionValue(webhook, "httpMethod", false);
      if (Array.isArray(method)) {
        return method[0];
      }
      return method;
    }
    watch(
      () => props.node,
      () => {
        isMinimized.value = props.nodeTypeDescription && !OPEN_URL_PANEL_TRIGGER_NODE_TYPES.includes(props.nodeTypeDescription.name);
      }
    );
    return (_ctx, _cache) => {
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_radio_buttons = resolveComponent("n8n-radio-buttons");
      const _component_el_col = resolveComponent("el-col");
      const _component_el_row = resolveComponent("el-row");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
      return webhooksNode.value.length && visibleWebhookUrls.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$h, [
        createBaseVNode("div", {
          class: normalizeClass(["clickable headline", { expanded: !isMinimized.value }]),
          title: isMinimized.value ? baseText.value.clickToDisplay : baseText.value.clickToHide,
          onClick: _cache[0] || (_cache[0] = ($event) => isMinimized.value = !isMinimized.value)
        }, [
          createVNode(_component_font_awesome_icon, {
            icon: "angle-right",
            class: "minimize-button minimize-icon"
          }),
          createTextVNode(" " + toDisplayString(baseText.value.toggleTitle), 1)
        ], 10, _hoisted_2$b),
        createVNode(_component_el_collapse_transition, null, {
          default: withCtx(() => [
            !isMinimized.value ? (openBlock(), createElementBlock("div", _hoisted_3$8, [
              !isProductionOnly.value ? (openBlock(), createElementBlock("div", _hoisted_4$7, [
                createVNode(_component_el_row, null, {
                  default: withCtx(() => [
                    createVNode(_component_el_col, { span: 24 }, {
                      default: withCtx(() => [
                        createVNode(_component_n8n_radio_buttons, {
                          modelValue: showUrlFor.value,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => showUrlFor.value = $event),
                          options: urlOptions.value
                        }, null, 8, ["modelValue", "options"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(visibleWebhookUrls.value, (webhook, index) => {
                return openBlock(), createBlock(_component_n8n_tooltip, {
                  key: index,
                  class: "item",
                  content: baseText.value.clickToCopy,
                  placement: "left"
                }, {
                  default: withCtx(() => [
                    isWebhookMethodVisible(webhook) ? (openBlock(), createElementBlock("div", _hoisted_5$7, [
                      createBaseVNode("div", _hoisted_6$7, [
                        createBaseVNode("div", _hoisted_7$5, [
                          createTextVNode(toDisplayString(getWebhookHttpMethod(webhook)), 1),
                          _cache[2] || (_cache[2] = createBaseVNode("br", null, null, -1))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_8$5, [
                        createBaseVNode("div", {
                          class: "webhook-url left-ellipsis clickable",
                          onClick: ($event) => copyWebhookUrl(webhook)
                        }, [
                          createTextVNode(toDisplayString(getWebhookUrlDisplay(webhook)), 1),
                          _cache[3] || (_cache[3] = createBaseVNode("br", null, null, -1))
                        ], 8, _hoisted_9$4)
                      ])
                    ])) : (openBlock(), createElementBlock("div", _hoisted_10$3, [
                      createBaseVNode("div", _hoisted_11$3, [
                        createBaseVNode("div", {
                          class: "webhook-url left-ellipsis clickable",
                          onClick: ($event) => copyWebhookUrl(webhook)
                        }, [
                          createTextVNode(toDisplayString(getWebhookUrlDisplay(webhook)), 1),
                          _cache[4] || (_cache[4] = createBaseVNode("br", null, null, -1))
                        ], 8, _hoisted_12$2)
                      ])
                    ]))
                  ]),
                  _: 2
                }, 1032, ["content"]);
              }), 128))
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ])) : createCommentVNode("", true);
    };
  }
});
const NodeWebhooks = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-b6179980"]]);
const OnClickOutside = /* @__PURE__ */ defineComponent({
  name: "OnClickOutside",
  props: ["as", "options"],
  emits: ["trigger"],
  setup(props, { slots, emit }) {
    const target = ref();
    onClickOutside(target, (e) => {
      emit("trigger", e);
    }, props.options);
    return () => {
      if (slots.default)
        return h(props.as || "div", { ref: target }, slots.default());
    };
  }
});
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
  const isLocked = ref(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef(element), (el) => {
    const target = resolveElement(toValue(el));
    if (target) {
      const ele = target;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = () => {
    const el = resolveElement(toValue(element));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        el,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  };
  const unlock = () => {
    const el = resolveElement(toValue(element));
    if (!el || !isLocked.value)
      return;
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  };
  tryOnScopeDispose(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v) {
      if (v)
        lock();
      else unlock();
    }
  });
}
function onScrollLock() {
  let isMounted = false;
  const state2 = ref(false);
  return (el, binding) => {
    state2.value = binding.value;
    if (isMounted)
      return;
    isMounted = true;
    const isLocked = useScrollLock(el, binding.value);
    watch(state2, (v) => isLocked.value = v);
  };
}
onScrollLock();
const _hoisted_1$g = ["data-test-id"];
const _hoisted_2$a = ["textContent"];
const _hoisted_3$7 = ["onClick"];
const _hoisted_4$6 = ["onClick"];
const _hoisted_5$6 = ["data-node-name"];
const _hoisted_6$6 = ["onClick"];
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "NDVSubConnections",
  props: {
    rootNode: {}
  },
  emits: ["switchSelectedNode", "openConnectionNodeCreator"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const nodeHelpers = useNodeHelpers();
    const i18n = useI18n();
    const { debounce } = useDebounce();
    const emit = __emit;
    const possibleConnections = ref([]);
    const expandedGroups = ref([]);
    const shouldShowNodeInputIssues = ref(false);
    const nodeType = computed(
      () => nodeTypesStore.getNodeType(props.rootNode.type, props.rootNode.typeVersion)
    );
    const nodeData = computed(() => workflowsStore.getNodeByName(props.rootNode.name));
    const workflow = computed(() => workflowsStore.getCurrentWorkflow());
    const nodeInputIssues = computed(() => {
      const issues = nodeHelpers.getNodeIssues(nodeType.value, props.rootNode, workflow.value, [
        "typeUnknown",
        "parameters",
        "credentials",
        "execution"
      ]);
      return issues?.input ?? {};
    });
    const connectedNodes2 = computed(() => {
      return possibleConnections.value.reduce(
        (acc, connection) => {
          const nodes = getINodesFromNames(
            workflow.value.getParentNodes(props.rootNode.name, connection.type)
          );
          return { ...acc, [connection.type]: nodes };
        },
        {}
      );
    });
    function getConnectionConfig(connectionType2) {
      return possibleConnections.value.find((c) => c.type === connectionType2);
    }
    function isMultiConnection(connectionType2) {
      const connectionConfig = getConnectionConfig(connectionType2);
      return connectionConfig?.maxConnections !== 1;
    }
    function shouldShowConnectionTooltip(connectionType2) {
      return isMultiConnection(connectionType2) && !expandedGroups.value.includes(connectionType2);
    }
    function expandConnectionGroup(connectionType2, isExpanded) {
      if (!isMultiConnection(connectionType2)) {
        return;
      }
      if (isExpanded) {
        expandedGroups.value = [...expandedGroups.value, connectionType2];
      } else {
        expandedGroups.value = expandedGroups.value.filter((g) => g !== connectionType2);
      }
    }
    function getINodesFromNames(names) {
      return names.map((name) => {
        const node2 = workflowsStore.getNodeByName(name);
        if (node2) {
          const matchedNodeType = nodeTypesStore.getNodeType(node2.type);
          if (matchedNodeType) {
            const issues = nodeHelpers.getNodeIssues(matchedNodeType, node2, workflow.value);
            const stringifiedIssues = issues ? nodeIssuesToString(issues, node2) : "";
            return { node: node2, nodeType: matchedNodeType, issues: stringifiedIssues };
          }
        }
        return null;
      }).filter((n) => n !== null);
    }
    function hasInputIssues(connectionType2) {
      return shouldShowNodeInputIssues.value && (nodeInputIssues.value[connectionType2] ?? []).length > 0;
    }
    function isNodeInputConfiguration(connectionConfig) {
      if (typeof connectionConfig === "string") return false;
      return "type" in connectionConfig;
    }
    function getPossibleSubInputConnections() {
      if (!nodeType.value || !props.rootNode) return [];
      const inputs = getNodeInputs(workflow.value, props.rootNode, nodeType.value);
      const nonMainInputs = inputs.filter((input) => {
        if (!isNodeInputConfiguration(input)) return false;
        return input.type !== "main";
      });
      return nonMainInputs;
    }
    function onNodeClick(nodeName, connectionType2) {
      if (isMultiConnection(connectionType2) && !expandedGroups.value.includes(connectionType2)) {
        expandConnectionGroup(connectionType2, true);
        return;
      }
      emit("switchSelectedNode", nodeName);
    }
    function onPlusClick(connectionType2) {
      const connectionNodes = connectedNodes2.value[connectionType2];
      if (isMultiConnection(connectionType2) && !expandedGroups.value.includes(connectionType2) && connectionNodes.length >= 1) {
        expandConnectionGroup(connectionType2, true);
        return;
      }
      emit("openConnectionNodeCreator", props.rootNode.name, connectionType2);
    }
    function showNodeInputsIssues() {
      shouldShowNodeInputIssues.value = false;
      setTimeout(() => {
        shouldShowNodeInputIssues.value = true;
      }, 0);
    }
    watch(
      nodeData,
      debounce(
        () => setTimeout(() => {
          expandedGroups.value = [];
          possibleConnections.value = getPossibleSubInputConnections();
        }, 0),
        { debounceTime: 1e3 }
      ),
      { immediate: true }
    );
    __expose({
      showNodeInputsIssues
    });
    return (_ctx, _cache) => {
      const _component_n8n_icon_button = resolveComponent("n8n-icon-button");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return possibleConnections.value.length ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.$style.container)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.connections),
          style: normalizeStyle(`--possible-connections: ${possibleConnections.value.length}`)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(possibleConnections.value, (connection) => {
            return openBlock(), createElementBlock("div", {
              key: connection.type,
              "data-test-id": `subnode-connection-group-${connection.type}`
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.connectionType)
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({
                    [_ctx.$style.connectionLabel]: true,
                    [_ctx.$style.hasIssues]: hasInputIssues(connection.type)
                  }),
                  textContent: toDisplayString(`${connection.displayName}${connection.required ? " *" : ""}`)
                }, null, 10, _hoisted_2$a),
                createVNode(unref(OnClickOutside), {
                  onTrigger: ($event) => expandConnectionGroup(connection.type, false)
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      ref_for: true,
                      ref: "connectedNodesWrapper",
                      class: normalizeClass({
                        [_ctx.$style.connectedNodesWrapper]: true,
                        [_ctx.$style.connectedNodesWrapperExpanded]: expandedGroups.value.includes(connection.type)
                      }),
                      style: normalizeStyle(`--nodes-length: ${connectedNodes2.value[connection.type].length}`),
                      onClick: ($event) => expandConnectionGroup(connection.type, true)
                    }, [
                      (connectedNodes2.value[connection.type].length >= 1 ? connection.maxConnections !== 1 : true) ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass({
                          [_ctx.$style.plusButton]: true,
                          [_ctx.$style.hasIssues]: hasInputIssues(connection.type)
                        }),
                        onClick: ($event) => onPlusClick(connection.type)
                      }, [
                        createVNode(_component_n8n_tooltip, {
                          placement: "top",
                          teleported: true,
                          offset: 10,
                          "show-after": 300,
                          disabled: shouldShowConnectionTooltip(connection.type) && connectedNodes2.value[connection.type].length >= 1
                        }, {
                          content: withCtx(() => [
                            createTextVNode(" Add " + toDisplayString(connection.displayName) + " ", 1),
                            hasInputIssues(connection.type) ? (openBlock(), createBlock(TitledList, {
                              key: 0,
                              title: `${unref(i18n).baseText("node.issues")}:`,
                              items: nodeInputIssues.value[connection.type]
                            }, null, 8, ["title", "items"])) : createCommentVNode("", true)
                          ]),
                          default: withCtx(() => [
                            createVNode(_component_n8n_icon_button, {
                              size: "medium",
                              icon: "plus",
                              type: "tertiary",
                              "data-test-id": `add-subnode-${connection.type}`
                            }, null, 8, ["data-test-id"])
                          ]),
                          _: 2
                        }, 1032, ["disabled"])
                      ], 10, _hoisted_4$6)) : createCommentVNode("", true),
                      connectedNodes2.value[connection.type].length > 0 ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        class: normalizeClass({
                          [_ctx.$style.connectedNodes]: true,
                          [_ctx.$style.connectedNodesMultiple]: connectedNodes2.value[connection.type].length > 1
                        })
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(connectedNodes2.value[connection.type], (node2, index) => {
                          return openBlock(), createElementBlock("div", {
                            key: node2.node.name,
                            class: normalizeClass({ [_ctx.$style.nodeWrapper]: true, [_ctx.$style.hasIssues]: node2.issues }),
                            "data-test-id": "floating-subnode",
                            "data-node-name": node2.node.name,
                            style: normalizeStyle(`--node-index: ${index}`)
                          }, [
                            (openBlock(), createBlock(_component_n8n_tooltip, {
                              key: node2.node.name,
                              placement: "top",
                              teleported: true,
                              offset: 10,
                              "show-after": 300,
                              disabled: shouldShowConnectionTooltip(connection.type)
                            }, {
                              content: withCtx(() => [
                                createTextVNode(toDisplayString(node2.node.name) + " ", 1),
                                node2.issues ? (openBlock(), createBlock(TitledList, {
                                  key: 0,
                                  title: `${unref(i18n).baseText("node.issues")}:`,
                                  items: node2.issues
                                }, null, 8, ["title", "items"])) : createCommentVNode("", true)
                              ]),
                              default: withCtx(() => [
                                createBaseVNode("div", {
                                  class: normalizeClass(_ctx.$style.connectedNode),
                                  onClick: ($event) => onNodeClick(node2.node.name, connection.type)
                                }, [
                                  createVNode(_sfc_main$z, {
                                    "node-type": node2.nodeType,
                                    "node-name": node2.node.name,
                                    "tooltip-position": "top",
                                    size: 20,
                                    circle: ""
                                  }, null, 8, ["node-type", "node-name"])
                                ], 10, _hoisted_6$6)
                              ]),
                              _: 2
                            }, 1032, ["disabled"]))
                          ], 14, _hoisted_5$6);
                        }), 128))
                      ], 2)) : createCommentVNode("", true)
                    ], 14, _hoisted_3$7)
                  ]),
                  _: 2
                }, 1032, ["onTrigger"])
              ], 2)
            ], 8, _hoisted_1$g);
          }), 128))
        ], 6)
      ], 2)) : createCommentVNode("", true);
    };
  }
});
const container$2 = "_container_ac466_140";
const connections = "_connections_ac466_148";
const connectionType = "_connectionType_ac466_160";
const connectionLabel = "_connectionLabel_ac466_167";
const hasIssues = "_hasIssues_ac466_173";
const connectedNodesWrapper = "_connectedNodesWrapper_ac466_177";
const plusButton = "_plusButton_ac466_185";
const connectedNodesWrapperExpanded = "_connectedNodesWrapperExpanded_ac466_203";
const connectedNodesMultiple = "_connectedNodesMultiple_ac466_209";
const connectedNode$1 = "_connectedNode_ac466_177";
const connectedNodes = "_connectedNodes_ac466_177";
const nodeWrapper = "_nodeWrapper_ac466_247";
const style0$e = {
  container: container$2,
  connections,
  connectionType,
  connectionLabel,
  hasIssues,
  connectedNodesWrapper,
  plusButton,
  "horizontal-shake": "_horizontal-shake_ac466_1",
  connectedNodesWrapperExpanded,
  connectedNodesMultiple,
  connectedNode: connectedNode$1,
  connectedNodes,
  nodeWrapper
};
const cssModules$g = {
  "$style": style0$e
};
const NDVSubConnections = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__cssModules", cssModules$g]]);
const NODE_TEST_STEP_POPUP_COUNT_KEY = "N8N_NODE_TEST_STEP_POPUP_COUNT";
const MAX_POPUP_COUNT = 10;
const POPUP_UPDATE_DELAY = 3e3;
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "NodeExecuteButton",
  props: {
    nodeName: {},
    telemetrySource: {},
    disabled: { type: Boolean, default: false },
    label: {},
    type: {},
    size: {},
    transparent: { type: Boolean, default: false },
    hideIcon: { type: Boolean },
    tooltip: {}
  },
  emits: ["stopExecution", "execute", "valueChanged"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const lastPopupCountUpdate = ref(0);
    const codeGenerationInProgress = ref(false);
    const router = useRouter();
    const { runWorkflow, stopCurrentExecution } = useRunWorkflow({ router });
    const workflowsStore = useWorkflowsStore();
    const externalHooks = useExternalHooks();
    const toast = useToast();
    const ndvStore = useNDVStore();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const i18n = useI18n();
    const message = useMessage();
    const telemetry = useTelemetry();
    const node2 = computed(() => workflowsStore.getNodeByName(props.nodeName));
    const pinnedData = usePinnedData(node2);
    const nodeType = computed(() => {
      return node2.value ? nodeTypesStore.getNodeType(node2.value.type, node2.value.typeVersion) : null;
    });
    const isNodeRunning = computed(() => {
      if (!uiStore.isActionActive["workflowRunning"] || codeGenerationInProgress.value) return false;
      const triggeredNode = workflowsStore.executedNode;
      return workflowsStore.isNodeExecuting(node2.value?.name ?? "") || triggeredNode === node2.value?.name;
    });
    const isTriggerNode = computed(() => {
      return node2.value ? nodeTypesStore.isTriggerNode(node2.value.type) : false;
    });
    const isWorkflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const isManualTriggerNode = computed(
      () => nodeType.value ? nodeType.value.name === MANUAL_TRIGGER_NODE_TYPE : false
    );
    const isChatNode = computed(
      () => nodeType.value ? nodeType.value.name === CHAT_TRIGGER_NODE_TYPE : false
    );
    const isChatChild = computed(() => workflowsStore.checkIfNodeHasChatParent(props.nodeName));
    const isFormTriggerNode = computed(
      () => nodeType.value ? nodeType.value.name === FORM_TRIGGER_NODE_TYPE : false
    );
    const isPollingTypeNode = computed(() => !!nodeType.value?.polling);
    const isScheduleTrigger = computed(() => !!nodeType.value?.group.includes("schedule"));
    const isWebhookNode = computed(
      () => nodeType.value ? nodeType.value.name === WEBHOOK_NODE_TYPE : false
    );
    const isListeningForEvents = computed(() => {
      const waitingOnWebhook = workflowsStore.executionWaitingForWebhook;
      const executedNode = workflowsStore.executedNode;
      return !!node2.value && !node2.value.disabled && isTriggerNode.value && waitingOnWebhook && (!executedNode || executedNode === props.nodeName);
    });
    const isListeningForWorkflowEvents = computed(() => {
      return isNodeRunning.value && isTriggerNode.value && !isScheduleTrigger.value && !isManualTriggerNode.value;
    });
    const hasIssues2 = computed(
      () => Boolean(node2.value?.issues && (node2.value.issues.parameters || node2.value.issues.credentials))
    );
    const disabledHint = computed(() => {
      if (isListeningForEvents.value) {
        return "";
      }
      if (codeGenerationInProgress.value) {
        return i18n.baseText("ndv.execute.generatingCode");
      }
      if (isTriggerNode.value && node2?.value?.disabled) {
        return i18n.baseText("ndv.execute.nodeIsDisabled");
      }
      if (isTriggerNode.value && hasIssues2.value) {
        const activeNode = ndvStore.activeNode;
        if (activeNode && activeNode.name !== props.nodeName) {
          return i18n.baseText("ndv.execute.fixPrevious");
        }
        return i18n.baseText("ndv.execute.requiredFieldsMissing");
      }
      if (isWorkflowRunning.value && !isNodeRunning.value) {
        return i18n.baseText("ndv.execute.workflowAlreadyRunning");
      }
      return "";
    });
    const tooltipText = computed(() => {
      if (shouldGenerateCode.value) {
        return i18n.baseText("ndv.execute.generateCodeAndTestNode.description");
      }
      if (disabledHint.value) return disabledHint.value;
      if (props.tooltip && !isLoading.value && testStepButtonPopupCount() < MAX_POPUP_COUNT) {
        return props.tooltip;
      }
      return "";
    });
    const buttonLabel = computed(() => {
      if (isListeningForEvents.value || isListeningForWorkflowEvents.value) {
        return i18n.baseText("ndv.execute.stopListening");
      }
      if (props.label) {
        return props.label;
      }
      if (isChatNode.value) {
        return i18n.baseText("ndv.execute.testChat");
      }
      if (isWebhookNode.value) {
        return i18n.baseText("ndv.execute.listenForTestEvent");
      }
      if (isFormTriggerNode.value) {
        return i18n.baseText("ndv.execute.testStep");
      }
      if (isPollingTypeNode.value || nodeType.value?.mockManualExecution) {
        return i18n.baseText("ndv.execute.fetchEvent");
      }
      return i18n.baseText("ndv.execute.testNode");
    });
    const isLoading = computed(
      () => codeGenerationInProgress.value || isNodeRunning.value && !isListeningForEvents.value && !isListeningForWorkflowEvents.value
    );
    const buttonIcon = computed(() => {
      if (shouldGenerateCode.value) return "terminal";
      if (!isListeningForEvents.value && !props.hideIcon) return "flask";
      return void 0;
    });
    const shouldGenerateCode = computed(() => {
      if (node2.value?.type !== AI_TRANSFORM_NODE_TYPE) {
        return false;
      }
      if (!node2.value?.parameters?.instructions) {
        return false;
      }
      if (!node2.value?.parameters?.jsCode) {
        return true;
      }
      if (node2.value?.parameters[AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT] && (node2.value?.parameters?.instructions).trim() !== (node2.value?.parameters?.[AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT]).trim()) {
        return true;
      }
      return false;
    });
    async function stopWaitingForWebhook() {
      try {
        await workflowsStore.removeTestWebhook(workflowsStore.workflowId);
      } catch (error) {
        toast.showError(error, "Error stopping webhook");
      }
    }
    function testStepButtonPopupCount() {
      return Number(localStorage.getItem(NODE_TEST_STEP_POPUP_COUNT_KEY));
    }
    function onMouseOver() {
      const count = testStepButtonPopupCount();
      if (count < MAX_POPUP_COUNT && !disabledHint.value && tooltipText.value) {
        const now = Date.now();
        if (!lastPopupCountUpdate.value || now - lastPopupCountUpdate.value >= POPUP_UPDATE_DELAY) {
          localStorage.setItem(NODE_TEST_STEP_POPUP_COUNT_KEY, `${count + 1}`);
          lastPopupCountUpdate.value = now;
        }
      }
    }
    async function onClick() {
      if (shouldGenerateCode.value) {
        codeGenerationInProgress.value = true;
        try {
          toast.showMessage({
            title: i18n.baseText("ndv.execute.generateCode.title"),
            message: i18n.baseText("ndv.execute.generateCode.message", {
              interpolate: { nodeName: node2.value?.name }
            }),
            type: "success"
          });
          const prompt2 = node2.value?.parameters?.instructions;
          const updateInformation = await generateCodeForAiTransform(
            prompt2,
            `parameters.${AI_TRANSFORM_JS_CODE}`,
            5
          );
          if (!updateInformation) return;
          emit("valueChanged", updateInformation);
          emit("valueChanged", {
            name: `parameters.${AI_TRANSFORM_CODE_GENERATED_FOR_PROMPT}`,
            value: prompt2
          });
          useTelemetry().trackAiTransform("generationFinished", {
            prompt: prompt2,
            code: updateInformation.value
          });
        } catch (error) {
          useTelemetry().trackAiTransform("generationFinished", {
            prompt,
            code: "",
            hasError: true
          });
          toast.showMessage({
            type: "error",
            title: i18n.baseText("codeNodeEditor.askAi.generationFailed"),
            message: error.message
          });
        }
        codeGenerationInProgress.value = false;
      }
      if (isChatNode.value || isChatChild.value && ndvStore.isInputPanelEmpty) {
        ndvStore.setActiveNodeName(null);
        workflowsStore.chatPartialExecutionDestinationNode = props.nodeName;
        nodeViewEventBus.emit("openChat");
      } else if (isListeningForEvents.value) {
        await stopWaitingForWebhook();
      } else if (isListeningForWorkflowEvents.value) {
        await stopCurrentExecution();
        emit("stopExecution");
      } else {
        let shouldUnpinAndExecute = false;
        if (pinnedData.hasData.value) {
          const confirmResult = await message.confirm(
            i18n.baseText("ndv.pinData.unpinAndExecute.description"),
            i18n.baseText("ndv.pinData.unpinAndExecute.title"),
            {
              confirmButtonText: i18n.baseText("ndv.pinData.unpinAndExecute.confirm"),
              cancelButtonText: i18n.baseText("ndv.pinData.unpinAndExecute.cancel")
            }
          );
          shouldUnpinAndExecute = confirmResult === MODAL_CONFIRM;
          if (shouldUnpinAndExecute && node2.value) {
            pinnedData.unsetData("unpin-and-execute-modal");
          }
        }
        if (!pinnedData.hasData.value || shouldUnpinAndExecute) {
          const telemetryPayload = {
            node_type: nodeType.value ? nodeType.value.name : null,
            workflow_id: workflowsStore.workflowId,
            source: props.telemetrySource,
            push_ref: ndvStore.pushRef
          };
          telemetry.track("User clicked execute node button", telemetryPayload);
          await externalHooks.run("nodeExecuteButton.onClick", telemetryPayload);
          await runWorkflow({
            destinationNode: props.nodeName,
            source: "RunData.ExecuteNodeButton"
          });
          emit("execute");
        }
      }
    }
    return (_ctx, _cache) => {
      const _component_n8n_button = resolveComponent("n8n-button");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_n8n_tooltip, {
          placement: "right",
          disabled: !tooltipText.value
        }, {
          content: withCtx(() => [
            createBaseVNode("div", null, toDisplayString(tooltipText.value), 1)
          ]),
          default: withCtx(() => [
            createBaseVNode("div", null, [
              createVNode(_component_n8n_button, mergeProps(_ctx.$attrs, {
                loading: isLoading.value,
                disabled: _ctx.disabled || !!disabledHint.value,
                label: buttonLabel.value,
                type: _ctx.type,
                size: _ctx.size,
                icon: buttonIcon.value,
                "transparent-background": _ctx.transparent,
                title: !isTriggerNode.value && !tooltipText.value ? unref(i18n).baseText("ndv.execute.testNode.description") : "",
                onMouseover: onMouseOver,
                onClick
              }), null, 16, ["loading", "disabled", "label", "type", "size", "icon", "transparent-background", "title"])
            ])
          ]),
          _: 1
        }, 8, ["disabled"])
      ]);
    };
  }
});
function updateDynamicConnections(node2, workflowConnections, parameterData) {
  const connections2 = { ...workflowConnections };
  try {
    if (parameterData.name.includes("conditions") || !connections2[node2.name]?.main) return null;
    if (node2.type === SWITCH_NODE_TYPE && parameterData.name === "parameters.numberOutputs") {
      const curentNumberOutputs = node2.parameters?.numberOutputs;
      const newNumberOutputs = parameterData.value;
      if (newNumberOutputs < curentNumberOutputs) {
        connections2[node2.name].main = connections2[node2.name].main.slice(0, newNumberOutputs);
        return connections2;
      }
    }
    if (node2.type === SWITCH_NODE_TYPE && parameterData.name === "parameters.options.fallbackOutput") {
      const curentFallbackOutput = node2.parameters?.options?.fallbackOutput;
      if (curentFallbackOutput === "extra") {
        if (!parameterData.value || parameterData.value !== "extra") {
          connections2[node2.name].main = connections2[node2.name].main.slice(0, -1);
          return connections2;
        }
      }
    }
    if (node2.type === SWITCH_NODE_TYPE && parameterData.name.includes("parameters.rules.values")) {
      const { fallbackOutput } = node2.parameters?.options;
      if (parameterData.value === void 0) {
        let extractIndex = function(path) {
          const match = path.match(/parameters\.rules\.values\[(\d+)\]$/);
          return match ? parseInt(match[1], 10) : null;
        };
        const index = extractIndex(parameterData.name);
        if (index !== null) {
          connections2[node2.name].main.splice(index, 1);
          return connections2;
        }
        if (parameterData.name === "parameters.rules.values") {
          if (fallbackOutput === "extra") {
            connections2[node2.name].main = [
              connections2[node2.name].main[connections2[node2.name].main.length - 1]
            ];
          } else {
            connections2[node2.name].main = [];
          }
          return connections2;
        }
      } else if (parameterData.name === "parameters.rules.values") {
        const curentRulesvalues = node2.parameters?.rules?.values;
        let lastConnection = void 0;
        if (fallbackOutput === "extra" && connections2[node2.name].main.length === curentRulesvalues.length + 1) {
          lastConnection = connections2[node2.name].main.pop();
        }
        const currentRulesLength = node2.parameters?.rules?.values?.length;
        const newRulesLength = parameterData.value?.length;
        if (newRulesLength - currentRulesLength === 1) {
          connections2[node2.name].main = [...connections2[node2.name].main, []];
          if (lastConnection) {
            connections2[node2.name].main.push(lastConnection);
          }
          return connections2;
        } else {
          const newRulesvalues = parameterData.value;
          const updatedConnectionsIndex = [];
          for (const rule of curentRulesvalues) {
            const index = newRulesvalues.findIndex((newRule) => isEqual(rule, newRule));
            if (index !== -1) {
              updatedConnectionsIndex.push(index);
            }
          }
          const reorderedConnections = [];
          for (const index of updatedConnectionsIndex) {
            reorderedConnections.push(connections2[node2.name].main[index] ?? []);
          }
          if (lastConnection) {
            reorderedConnections.push(lastConnection);
          }
          connections2[node2.name].main = reorderedConnections;
          return connections2;
        }
      }
    }
  } catch (error) {
    captureException(error);
  }
  return null;
}
const _hoisted_1$f = { class: "mt-xs" };
const LANGCHAIN_NODES_PREFIX = "@n8n/n8n-nodes-langchain.";
const N8N_NODES_PREFIX = "@n8n/n8n-nodes.";
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "FreeAiCreditsCallout",
  setup(__props) {
    const NODES_WITH_OPEN_AI_API_CREDENTIAL = [
      `${LANGCHAIN_NODES_PREFIX}openAi`,
      `${LANGCHAIN_NODES_PREFIX}embeddingsOpenAi`,
      `${LANGCHAIN_NODES_PREFIX}lmChatOpenAi`,
      `${N8N_NODES_PREFIX}openAi`
    ];
    const showSuccessCallout = ref(false);
    const claimingCredits = ref(false);
    const settingsStore = useSettingsStore();
    const posthogStore = usePostHog();
    const credentialsStore = useCredentialsStore();
    const usersStore = useUsersStore();
    const ndvStore = useNDVStore();
    const projectsStore = useProjectsStore();
    const telemetry = useTelemetry();
    const i18n = useI18n();
    const toast = useToast();
    const userHasOpenAiCredentialAlready = computed(
      () => !!credentialsStore.allCredentials.filter(
        (credential) => credential.type === OPEN_AI_API_CREDENTIAL_TYPE
      ).length
    );
    const userHasClaimedAiCreditsAlready = computed(
      () => !!usersStore.currentUser?.settings?.userClaimedAiCredits
    );
    const activeNodeHasOpenAiApiCredential = computed(
      () => ndvStore.activeNode?.type && NODES_WITH_OPEN_AI_API_CREDENTIAL.includes(ndvStore.activeNode.type)
    );
    const userCanClaimOpenAiCredits = computed(() => {
      return settingsStore.isAiCreditsEnabled && activeNodeHasOpenAiApiCredential.value && posthogStore.getVariant(AI_CREDITS_EXPERIMENT.name) === AI_CREDITS_EXPERIMENT.variant && !userHasOpenAiCredentialAlready.value && !userHasClaimedAiCreditsAlready.value;
    });
    const onClaimCreditsClicked = async () => {
      claimingCredits.value = true;
      try {
        await credentialsStore.claimFreeAiCredits(projectsStore.currentProject?.id);
        if (usersStore?.currentUser?.settings) {
          usersStore.currentUser.settings.userClaimedAiCredits = true;
        }
        telemetry.track("User claimed OpenAI credits");
        showSuccessCallout.value = true;
      } catch (e) {
        toast.showError(
          e,
          i18n.baseText("freeAi.credits.showError.claim.title"),
          i18n.baseText("freeAi.credits.showError.claim.message")
        );
      } finally {
        claimingCredits.value = false;
      }
    };
    return (_ctx, _cache) => {
      const _component_n8n_button = resolveComponent("n8n-button");
      const _component_n8n_callout = resolveComponent("n8n-callout");
      const _component_n8n_text = resolveComponent("n8n-text");
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        userCanClaimOpenAiCredits.value && !showSuccessCallout.value ? (openBlock(), createBlock(_component_n8n_callout, {
          key: 0,
          theme: "secondary",
          icon: "exclamation-circle"
        }, {
          trailingContent: withCtx(() => [
            createVNode(_component_n8n_button, {
              type: "tertiary",
              size: "small",
              label: unref(i18n).baseText("freeAi.credits.callout.claim.button.label"),
              loading: claimingCredits.value,
              onClick: onClaimCreditsClicked
            }, null, 8, ["label", "loading"])
          ]),
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(i18n).baseText("freeAi.credits.callout.claim.title", {
              interpolate: { credits: unref(settingsStore).aiCreditsQuota }
            })) + " ", 1)
          ]),
          _: 1
        })) : showSuccessCallout.value ? (openBlock(), createBlock(_component_n8n_callout, {
          key: 1,
          theme: "success",
          icon: "check-circle"
        }, {
          default: withCtx(() => [
            createVNode(_component_n8n_text, null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("freeAi.credits.callout.success.title.part1", {
                  interpolate: { credits: unref(settingsStore).aiCreditsQuota }
                })), 1)
              ]),
              _: 1
            }),
            _cache[0] || (_cache[0] = createTextVNode("  ")),
            createVNode(_component_n8n_text, { bold: true }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("freeAi.credits.callout.success.title.part2")), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$e = { class: "header-side-menu" };
const _hoisted_2$9 = { key: 1 };
const _hoisted_3$6 = {
  key: 0,
  class: "node-is-not-valid"
};
const _hoisted_4$5 = { class: "missingNodeTitleContainer mt-s mb-xs" };
const _hoisted_5$5 = { class: "mb-l" };
const _hoisted_6$5 = ["href"];
const _hoisted_7$4 = ["href", "textContent"];
const _hoisted_8$4 = {
  key: 1,
  class: "node-parameters-wrapper",
  "data-test-id": "node-parameters"
};
const _hoisted_9$3 = {
  key: 1,
  class: "no-parameters"
};
const _hoisted_10$2 = {
  key: 2,
  class: "parameter-item parameter-notice",
  "data-test-id": "node-parameters-http-notice"
};
const _hoisted_11$2 = {
  class: "node-version",
  "data-test-id": "node-version"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "NodeSettings",
  props: {
    eventBus: {},
    dragging: { type: Boolean },
    pushRef: {},
    nodeType: {},
    readOnly: { type: Boolean, default: false },
    foreignCredentials: { default: () => [] },
    blockUI: { type: Boolean, default: false },
    executable: { type: Boolean, default: true },
    inputSize: { default: 0 }
  },
  emits: ["stopExecution", "redrawRequired", "valueChanged", "switchSelectedNode", "openConnectionNodeCreator", "activate", "execute"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const workflowsStore = useWorkflowsStore();
    const credentialsStore = useCredentialsStore();
    const historyStore = useHistoryStore();
    const telemetry = useTelemetry();
    const nodeHelpers = useNodeHelpers();
    const externalHooks = useExternalHooks();
    const i18n = useI18n();
    const nodeValid = ref(true);
    const openPanel = ref("params");
    const nodeValues = ref({
      color: "#ff0000",
      alwaysOutputData: false,
      executeOnce: false,
      notesInFlow: false,
      onError: "stopWorkflow",
      retryOnFail: false,
      maxTries: 3,
      waitBetweenTries: 1e3,
      notes: "",
      parameters: {}
    });
    const nodeValuesInitialized = ref(false);
    const hiddenIssuesInputs = ref([]);
    const nodeSettings = ref([]);
    const subConnections = ref(null);
    const currentWorkflowInstance = computed(() => workflowsStore.getCurrentWorkflow());
    const currentWorkflow = computed(
      () => workflowsStore.getWorkflowById(currentWorkflowInstance.value.id)
    );
    const hasForeignCredential = computed(() => props.foreignCredentials.length > 0);
    const isHomeProjectTeam = computed(
      () => currentWorkflow.value?.homeProject?.type === ProjectTypes.Team
    );
    const isReadOnly = computed(
      () => props.readOnly || hasForeignCredential.value && !isHomeProjectTeam.value
    );
    const node2 = computed(() => ndvStore.activeNode);
    const isTriggerNode = computed(() => !!node2.value && nodeTypesStore.isTriggerNode(node2.value.type));
    const isExecutable = computed(() => {
      if (props.nodeType && node2.value) {
        const workflowNode = currentWorkflowInstance.value.getNode(node2.value.name);
        const inputs = getNodeInputs(
          currentWorkflowInstance.value,
          workflowNode,
          props.nodeType
        );
        const inputNames = getConnectionTypes(inputs);
        if (!inputNames.includes(NodeConnectionType.Main) && !isTriggerNode.value) {
          return false;
        }
      }
      return props.executable || props.foreignCredentials.length > 0;
    });
    const nodeTypeVersions = computed(() => {
      if (!node2.value) return [];
      return nodeTypesStore.getNodeVersions(node2.value.type);
    });
    const latestVersion = computed(() => Math.max(...nodeTypeVersions.value));
    const isLatestNodeVersion = computed(
      () => !node2.value?.typeVersion || latestVersion.value === node2.value.typeVersion
    );
    const executeButtonTooltip = computed(() => {
      if (node2.value && isLatestNodeVersion.value && props.inputSize > 1 && !nodeHelpers.isSingleExecution(node2.value.type, node2.value.parameters)) {
        return i18n.baseText("nodeSettings.executeButtonTooltip.times", {
          interpolate: { inputSize: props.inputSize }
        });
      }
      return "";
    });
    const nodeVersionTag = computed(() => {
      if (!props.nodeType || props.nodeType.hidden) {
        return i18n.baseText("nodeSettings.deprecated");
      }
      if (isLatestNodeVersion.value) {
        return i18n.baseText("nodeSettings.latest");
      }
      return i18n.baseText("nodeSettings.latestVersion", {
        interpolate: { version: latestVersion.value.toString() }
      });
    });
    const parameters = computed(() => {
      if (props.nodeType === null) {
        return [];
      }
      return props.nodeType?.properties ?? [];
    });
    const parametersSetting = computed(() => parameters.value.filter((item) => item.isNodeSetting));
    const parametersNoneSetting = computed(
      () => parameters.value.filter((item) => !item.isNodeSetting)
    );
    const outputPanelEditMode = computed(() => ndvStore.outputPanelEditMode);
    const isCommunityNode = computed(() => !!node2.value && isCommunityPackageName(node2.value.type));
    const usedCredentials = computed(
      () => Object.values(workflowsStore.usedCredentials).filter(
        (credential) => Object.values(node2.value?.credentials || []).find(
          (nodeCredential) => nodeCredential.id === credential.id
        )
      )
    );
    const credentialOwnerName = computed(() => {
      const credential = usedCredentials.value ? Object.values(usedCredentials.value).find(
        (credential2) => credential2.id === props.foreignCredentials[0]
      ) : void 0;
      return credentialsStore.getCredentialOwnerName(credential);
    });
    const setValue = (name, value) => {
      const nameParts = name.split(".");
      let lastNamePart = nameParts.pop();
      let isArray = false;
      if (lastNamePart !== void 0 && lastNamePart.includes("[")) {
        const lastNameParts = lastNamePart.match(/(.*)\[(\d+)\]$/);
        if (lastNameParts) {
          nameParts.push(lastNameParts[1]);
          lastNamePart = lastNameParts[2];
          isArray = true;
        }
      }
      if (nameParts.length === 0) {
        if (value === null) {
          if (lastNamePart) {
            const { [lastNamePart]: removedNodeValue, ...remainingNodeValues } = nodeValues.value;
            nodeValues.value = remainingNodeValues;
          }
        } else {
          nodeValues.value = {
            ...nodeValues.value,
            [lastNamePart]: value
          };
        }
      } else {
        if (value === null) {
          let tempValue = get(nodeValues.value, nameParts.join("."));
          if (lastNamePart && !Array.isArray(tempValue)) {
            const { [lastNamePart]: removedNodeValue, ...remainingNodeValues } = tempValue;
            tempValue = remainingNodeValues;
          }
          if (isArray && Array.isArray(tempValue) && tempValue.length === 0) {
            lastNamePart = nameParts.pop();
            tempValue = get(nodeValues.value, nameParts.join("."));
            if (lastNamePart) {
              const { [lastNamePart]: removedArrayNodeValue, ...remainingArrayNodeValues } = tempValue;
              tempValue = remainingArrayNodeValues;
            }
          }
        } else {
          if (typeof value === "object") {
            set(
              get(nodeValues.value, nameParts.join(".")),
              lastNamePart,
              deepCopy(value)
            );
          } else {
            set(
              get(nodeValues.value, nameParts.join(".")),
              lastNamePart,
              value
            );
          }
        }
      }
      nodeValues.value = { ...nodeValues.value };
    };
    const removeMismatchedOptionValues = (nodeType, nodeParameterValues, updatedParameter) => {
      nodeType.properties.forEach((prop) => {
        const displayOptions = prop.displayOptions;
        if (!nodeParameterValues?.hasOwnProperty(prop.name) || !displayOptions || !prop.options) {
          return;
        }
        const showCondition = displayOptions.show?.[updatedParameter.name];
        const hideCondition = displayOptions.hide?.[updatedParameter.name];
        if (showCondition === void 0 && hideCondition === void 0) {
          return;
        }
        let hasValidOptions = true;
        if (isINodePropertyCollectionList(prop.options) || isINodePropertiesList(prop.options)) {
          hasValidOptions = Object.keys(nodeParameterValues).every(
            (key) => (prop.options ?? []).find((option) => option.name === key) !== void 0
          );
        } else if (isINodePropertyOptionsList(prop.options)) {
          hasValidOptions = !!prop.options.find(
            (option) => option.value === nodeParameterValues[prop.name]
          );
        }
        if (!hasValidOptions && displayParameter(nodeParameterValues, prop, node2.value)) {
          unset(nodeParameterValues, prop.name);
        }
      });
    };
    const valueChanged = (parameterData) => {
      let newValue;
      if (parameterData.hasOwnProperty("value")) {
        newValue = parameterData.value;
      } else {
        newValue = get(nodeValues.value, parameterData.name);
      }
      const nodeNameBefore = parameterData.node || node2.value?.name;
      if (!nodeNameBefore) {
        return;
      }
      const _node = workflowsStore.getNodeByName(nodeNameBefore);
      if (_node === null) {
        return;
      }
      if (parameterData.name === "onError") {
        emit("redrawRequired");
      }
      if (parameterData.name === "name") {
        const sendData = {
          value: newValue,
          oldValue: nodeNameBefore,
          name: parameterData.name
        };
        emit("valueChanged", sendData);
      } else if (parameterData.name === "parameters") {
        const nodeType = nodeTypesStore.getNodeType(_node.type, _node.typeVersion);
        if (!nodeType) {
          return;
        }
        let nodeParameters = getNodeParameters(
          nodeType.properties,
          _node.parameters,
          false,
          false,
          _node
        );
        const oldNodeParameters = Object.assign({}, nodeParameters);
        nodeParameters = deepCopy(nodeParameters);
        if (parameterData.value && typeof parameterData.value === "object") {
          for (const parameterName of Object.keys(parameterData.value)) {
            newValue = parameterData.value[parameterName];
            const parameterPath = parameterName.split(".").slice(1).join(".");
            const parameterPathArray = parameterPath.match(/(.*)\[(\d+)\]$/);
            if (parameterData[parameterName] === void 0 && parameterPathArray !== null) {
              const path = parameterPathArray[1];
              const index = parameterPathArray[2];
              const data = get(nodeParameters, path);
              if (Array.isArray(data)) {
                data.splice(parseInt(index, 10), 1);
                set(nodeParameters, path, data);
              }
            } else {
              if (newValue === void 0) {
                unset(nodeParameters, parameterPath);
              } else {
                set(nodeParameters, parameterPath, newValue);
              }
            }
            void externalHooks.run("nodeSettings.valueChanged", {
              parameterPath,
              newValue,
              parameters: parameters.value,
              oldNodeParameters
            });
          }
        }
        nodeParameters = getNodeParameters(
          nodeType.properties,
          nodeParameters,
          true,
          false,
          _node
        );
        for (const key of Object.keys(nodeParameters)) {
          if (nodeParameters && nodeParameters[key] !== null && nodeParameters[key] !== void 0) {
            setValue(`parameters.${key}`, nodeParameters[key]);
          }
        }
        if (nodeParameters) {
          const updateInformation = {
            name: _node.name,
            value: nodeParameters
          };
          workflowsStore.setNodeParameters(updateInformation);
          nodeHelpers.updateNodeParameterIssuesByName(_node.name);
          nodeHelpers.updateNodeCredentialIssuesByName(_node.name);
        }
      } else if (parameterData.name.startsWith("parameters.")) {
        const nodeType = nodeTypesStore.getNodeType(_node.type, _node.typeVersion);
        if (!nodeType) {
          return;
        }
        let nodeParameters = getNodeParameters(
          nodeType.properties,
          _node.parameters,
          false,
          false,
          _node
        );
        const oldNodeParameters = Object.assign({}, nodeParameters);
        nodeParameters = deepCopy(nodeParameters);
        const parameterPath = parameterData.name.split(".").slice(1).join(".");
        const parameterPathArray = parameterPath.match(/(.*)\[(\d+)\]$/);
        if (parameterData.value === void 0 && parameterPathArray !== null) {
          const path = parameterPathArray[1];
          const index = parameterPathArray[2];
          const data = get(nodeParameters, path);
          if (Array.isArray(data)) {
            data.splice(parseInt(index, 10), 1);
            set(nodeParameters, path, data);
          }
        } else {
          if (newValue === void 0) {
            unset(nodeParameters, parameterPath);
          } else {
            set(nodeParameters, parameterPath, newValue);
          }
          removeMismatchedOptionValues(nodeType, nodeParameters, {
            name: parameterPath,
            value: newValue
          });
        }
        nodeParameters = getNodeParameters(
          nodeType.properties,
          nodeParameters,
          true,
          false,
          _node
        );
        for (const key of Object.keys(nodeParameters)) {
          if (nodeParameters && nodeParameters[key] !== null && nodeParameters[key] !== void 0) {
            setValue(`parameters.${key}`, nodeParameters[key]);
          }
        }
        const updateInformation = {
          name: _node.name,
          value: nodeParameters
        };
        const connections2 = workflowsStore.allConnections;
        const updatedConnections = updateDynamicConnections(_node, connections2, parameterData);
        if (updatedConnections) {
          workflowsStore.setConnections(updatedConnections, true);
        }
        workflowsStore.setNodeParameters(updateInformation);
        void externalHooks.run("nodeSettings.valueChanged", {
          parameterPath,
          newValue,
          parameters: parameters.value,
          oldNodeParameters
        });
        nodeHelpers.updateNodeParameterIssuesByName(_node.name);
        nodeHelpers.updateNodeCredentialIssuesByName(_node.name);
        telemetry.trackNodeParametersValuesChange(nodeType.name, parameterData);
      } else {
        nodeValues.value = {
          ...nodeValues.value,
          [parameterData.name]: newValue
        };
        const updateInformation = {
          name: _node.name,
          key: parameterData.name,
          value: newValue
        };
        workflowsStore.setNodeValue(updateInformation);
      }
    };
    const setHttpNodeParameters = (parameters2) => {
      try {
        valueChanged({
          node: node2.value?.name,
          name: "parameters",
          value: parameters2
        });
      } catch {
      }
    };
    const onSwitchSelectedNode = (node22) => {
      emit("switchSelectedNode", node22);
    };
    const onOpenConnectionNodeCreator = (nodeName, connectionType2) => {
      emit("openConnectionNodeCreator", nodeName, connectionType2);
    };
    const populateHiddenIssuesSet = () => {
      if (!node2.value || !workflowsStore.isNodePristine(node2.value.name)) return;
      hiddenIssuesInputs.value.push("credentials");
      parametersNoneSetting.value.forEach((parameter) => {
        hiddenIssuesInputs.value.push(parameter.name);
      });
      workflowsStore.setNodePristine(node2.value.name, false);
    };
    const populateSettings = () => {
      if (isExecutable.value && !isTriggerNode.value) {
        nodeSettings.value.push(
          ...[
            {
              displayName: i18n.baseText("nodeSettings.alwaysOutputData.displayName"),
              name: "alwaysOutputData",
              type: "boolean",
              default: false,
              noDataExpression: true,
              description: i18n.baseText("nodeSettings.alwaysOutputData.description")
            },
            {
              displayName: i18n.baseText("nodeSettings.executeOnce.displayName"),
              name: "executeOnce",
              type: "boolean",
              default: false,
              noDataExpression: true,
              description: i18n.baseText("nodeSettings.executeOnce.description")
            },
            {
              displayName: i18n.baseText("nodeSettings.retryOnFail.displayName"),
              name: "retryOnFail",
              type: "boolean",
              default: false,
              noDataExpression: true,
              description: i18n.baseText("nodeSettings.retryOnFail.description")
            },
            {
              displayName: i18n.baseText("nodeSettings.maxTries.displayName"),
              name: "maxTries",
              type: "number",
              typeOptions: {
                minValue: 2,
                maxValue: 5
              },
              default: 3,
              displayOptions: {
                show: {
                  retryOnFail: [true]
                }
              },
              noDataExpression: true,
              description: i18n.baseText("nodeSettings.maxTries.description")
            },
            {
              displayName: i18n.baseText("nodeSettings.waitBetweenTries.displayName"),
              name: "waitBetweenTries",
              type: "number",
              typeOptions: {
                minValue: 0,
                maxValue: 5e3
              },
              default: 1e3,
              displayOptions: {
                show: {
                  retryOnFail: [true]
                }
              },
              noDataExpression: true,
              description: i18n.baseText("nodeSettings.waitBetweenTries.description")
            },
            {
              displayName: i18n.baseText("nodeSettings.onError.displayName"),
              name: "onError",
              type: "options",
              options: [
                {
                  name: i18n.baseText("nodeSettings.onError.options.stopWorkflow.displayName"),
                  value: "stopWorkflow",
                  description: i18n.baseText("nodeSettings.onError.options.stopWorkflow.description")
                },
                {
                  name: i18n.baseText("nodeSettings.onError.options.continueRegularOutput.displayName"),
                  value: "continueRegularOutput",
                  description: i18n.baseText(
                    "nodeSettings.onError.options.continueRegularOutput.description"
                  )
                },
                {
                  name: i18n.baseText("nodeSettings.onError.options.continueErrorOutput.displayName"),
                  value: "continueErrorOutput",
                  description: i18n.baseText(
                    "nodeSettings.onError.options.continueErrorOutput.description"
                  )
                }
              ],
              default: "stopWorkflow",
              description: i18n.baseText("nodeSettings.onError.description"),
              noDataExpression: true
            }
          ]
        );
      }
      nodeSettings.value.push(
        ...[
          {
            displayName: i18n.baseText("nodeSettings.notes.displayName"),
            name: "notes",
            type: "string",
            typeOptions: {
              rows: 5
            },
            default: "",
            noDataExpression: true,
            description: i18n.baseText("nodeSettings.notes.description")
          },
          {
            displayName: i18n.baseText("nodeSettings.notesInFlow.displayName"),
            name: "notesInFlow",
            type: "boolean",
            default: false,
            noDataExpression: true,
            description: i18n.baseText("nodeSettings.notesInFlow.description")
          }
        ]
      );
    };
    const onParameterBlur = (parameterName) => {
      hiddenIssuesInputs.value = hiddenIssuesInputs.value.filter((name) => name !== parameterName);
    };
    const onWorkflowActivate = () => {
      hiddenIssuesInputs.value = [];
      emit("activate");
    };
    const onNodeExecute = () => {
      hiddenIssuesInputs.value = [];
      subConnections.value?.showNodeInputsIssues();
      emit("execute");
    };
    const credentialSelected = (updateInformation) => {
      workflowsStore.updateNodeProperties(updateInformation);
      const node22 = workflowsStore.getNodeByName(updateInformation.name);
      if (node22) {
        nodeHelpers.updateNodeCredentialIssues(node22);
      }
      void externalHooks.run("nodeSettings.credentialSelected", { updateInformation });
    };
    const nameChanged = (name) => {
      if (node2.value) {
        historyStore.pushCommandToUndo(new RenameNodeCommand(node2.value.name, name));
      }
      valueChanged({
        value: name,
        name: "name"
      });
    };
    const setNodeValues = () => {
      if (!node2.value) {
        nodeValuesInitialized.value = true;
        return;
      }
      if (props.nodeType !== null) {
        nodeValid.value = true;
        const foundNodeSettings = [];
        if (node2.value.color) {
          foundNodeSettings.push("color");
          nodeValues.value = {
            ...nodeValues.value,
            color: node2.value.color
          };
        }
        if (node2.value.notes) {
          foundNodeSettings.push("notes");
          nodeValues.value = {
            ...nodeValues.value,
            notes: node2.value.notes
          };
        }
        if (node2.value.alwaysOutputData) {
          foundNodeSettings.push("alwaysOutputData");
          nodeValues.value = {
            ...nodeValues.value,
            alwaysOutputData: node2.value.alwaysOutputData
          };
        }
        if (node2.value.executeOnce) {
          foundNodeSettings.push("executeOnce");
          nodeValues.value = {
            ...nodeValues.value,
            executeOnce: node2.value.executeOnce
          };
        }
        if (node2.value.continueOnFail) {
          foundNodeSettings.push("onError");
          nodeValues.value = {
            ...nodeValues.value,
            onError: "continueRegularOutput"
          };
        }
        if (node2.value.onError) {
          foundNodeSettings.push("onError");
          nodeValues.value = {
            ...nodeValues.value,
            onError: node2.value.onError
          };
        }
        if (node2.value.notesInFlow) {
          foundNodeSettings.push("notesInFlow");
          nodeValues.value = {
            ...nodeValues.value,
            notesInFlow: node2.value.notesInFlow
          };
        }
        if (node2.value.retryOnFail) {
          foundNodeSettings.push("retryOnFail");
          nodeValues.value = {
            ...nodeValues.value,
            retryOnFail: node2.value.retryOnFail
          };
        }
        if (node2.value.maxTries) {
          foundNodeSettings.push("maxTries");
          nodeValues.value = {
            ...nodeValues.value,
            maxTries: node2.value.maxTries
          };
        }
        if (node2.value.waitBetweenTries) {
          foundNodeSettings.push("waitBetweenTries");
          nodeValues.value = {
            ...nodeValues.value,
            waitBetweenTries: node2.value.waitBetweenTries
          };
        }
        for (const nodeSetting of nodeSettings.value) {
          if (!foundNodeSettings.includes(nodeSetting.name)) {
            nodeValues.value = {
              ...nodeValues.value,
              [nodeSetting.name]: nodeSetting.default
            };
          }
        }
        nodeValues.value = {
          ...nodeValues.value,
          parameters: deepCopy(node2.value.parameters)
        };
      } else {
        nodeValid.value = false;
      }
      nodeValuesInitialized.value = true;
    };
    const onMissingNodeTextClick = (event) => {
      if (event.target.localName === "a") {
        telemetry.track("user clicked cnr browse button", {
          source: "cnr missing node modal"
        });
      }
    };
    const onMissingNodeLearnMoreLinkClick = () => {
      telemetry.track("user clicked cnr docs link", {
        source: "missing node modal source",
        package_name: node2.value?.type.split(".")[0],
        node_type: node2.value?.type
      });
    };
    const onStopExecution = () => {
      emit("stopExecution");
    };
    const openSettings = () => {
      openPanel.value = "settings";
    };
    const onTabSelect = (tab) => {
      openPanel.value = tab;
    };
    watch(node2, () => {
      setNodeValues();
    });
    onMounted(() => {
      populateHiddenIssuesSet();
      populateSettings();
      setNodeValues();
      props.eventBus?.on("openSettings", openSettings);
      nodeHelpers.updateNodeParameterIssues(node2.value, props.nodeType);
      importCurlEventBus.on("setHttpNodeParameters", setHttpNodeParameters);
      ndvEventBus.on("updateParameterValue", valueChanged);
    });
    onBeforeUnmount(() => {
      props.eventBus?.off("openSettings", openSettings);
      importCurlEventBus.off("setHttpNodeParameters", setHttpNodeParameters);
      ndvEventBus.off("updateParameterValue", valueChanged);
    });
    return (_ctx, _cache) => {
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_i18n_t = resolveComponent("i18n-t");
      const _component_n8n_link = resolveComponent("n8n-link");
      const _component_n8n_notice = resolveComponent("n8n-notice");
      const _component_n8n_block_ui = resolveComponent("n8n-block-ui");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({
          "node-settings": true,
          dragging: _ctx.dragging
        }),
        onKeydown: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop"]))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.header)
        }, [
          createBaseVNode("div", _hoisted_1$e, [
            node2.value ? (openBlock(), createBlock(NodeTitle, {
              key: 0,
              class: "node-name",
              "model-value": node2.value.name,
              "node-type": _ctx.nodeType,
              "read-only": isReadOnly.value,
              "onUpdate:modelValue": nameChanged
            }, null, 8, ["model-value", "node-type", "read-only"])) : createCommentVNode("", true),
            isExecutable.value ? (openBlock(), createElementBlock("div", _hoisted_2$9, [
              !_ctx.blockUI && node2.value && nodeValid.value ? (openBlock(), createBlock(_sfc_main$u, {
                key: 0,
                "data-test-id": "node-execute-button",
                "node-name": node2.value.name,
                disabled: outputPanelEditMode.value.enabled && !isTriggerNode.value,
                tooltip: executeButtonTooltip.value,
                size: "small",
                "telemetry-source": "parameters",
                onExecute: onNodeExecute,
                onStopExecution,
                onValueChanged: valueChanged
              }, null, 8, ["node-name", "disabled", "tooltip"])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ]),
          node2.value && nodeValid.value ? (openBlock(), createBlock(_sfc_main$x, {
            key: 0,
            "model-value": openPanel.value,
            "node-type": _ctx.nodeType,
            "push-ref": _ctx.pushRef,
            "onUpdate:modelValue": onTabSelect
          }, null, 8, ["model-value", "node-type", "push-ref"])) : createCommentVNode("", true)
        ], 2),
        node2.value && !nodeValid.value ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
          createBaseVNode("p", {
            class: normalizeClass(_ctx.$style.warningIcon)
          }, [
            createVNode(_component_font_awesome_icon, { icon: "exclamation-triangle" })
          ], 2),
          createBaseVNode("div", _hoisted_4$5, [
            createVNode(_component_n8n_text, {
              size: "large",
              color: "text-dark",
              bold: ""
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("nodeSettings.communityNodeUnknown.title")), 1)
              ]),
              _: 1
            })
          ]),
          isCommunityNode.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.$style.descriptionContainer)
          }, [
            createBaseVNode("div", _hoisted_5$5, [
              createVNode(_component_i18n_t, {
                keypath: "nodeSettings.communityNodeUnknown.description",
                tag: "span",
                onClick: onMissingNodeTextClick
              }, {
                action: withCtx(() => [
                  createBaseVNode("a", {
                    href: `https://www.npmjs.com/package/${node2.value.type.split(".")[0]}`,
                    target: "_blank"
                  }, toDisplayString(node2.value.type.split(".")[0]), 9, _hoisted_6$5)
                ]),
                _: 1
              })
            ]),
            createVNode(_component_n8n_link, {
              to: unref(COMMUNITY_NODES_INSTALLATION_DOCS_URL),
              onClick: onMissingNodeLearnMoreLinkClick
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("nodeSettings.communityNodeUnknown.installLink.text")), 1)
              ]),
              _: 1
            }, 8, ["to"])
          ], 2)) : (openBlock(), createBlock(_component_i18n_t, {
            key: 1,
            keypath: "nodeSettings.nodeTypeUnknown.description",
            tag: "span"
          }, {
            action: withCtx(() => [
              createBaseVNode("a", {
                href: unref(CUSTOM_NODES_DOCS_URL),
                target: "_blank",
                textContent: toDisplayString(unref(i18n).baseText("nodeSettings.nodeTypeUnknown.description.customNode"))
              }, null, 8, _hoisted_7$4)
            ]),
            _: 1
          }))
        ])) : createCommentVNode("", true),
        node2.value && nodeValid.value ? (openBlock(), createElementBlock("div", _hoisted_8$4, [
          hasForeignCredential.value && !isHomeProjectTeam.value ? (openBlock(), createBlock(_component_n8n_notice, {
            key: 0,
            content: unref(i18n).baseText("nodeSettings.hasForeignCredential", {
              interpolate: { owner: credentialOwnerName.value }
            })
          }, null, 8, ["content"])) : createCommentVNode("", true),
          createVNode(_sfc_main$t),
          withDirectives(createBaseVNode("div", null, [
            createVNode(NodeWebhooks, {
              node: node2.value,
              "node-type-description": _ctx.nodeType
            }, null, 8, ["node", "node-type-description"]),
            nodeValuesInitialized.value ? (openBlock(), createBlock(_sfc_main$A, {
              key: 0,
              parameters: parametersNoneSetting.value,
              "hide-delete": true,
              "node-values": nodeValues.value,
              "is-read-only": isReadOnly.value,
              "hidden-issues-inputs": hiddenIssuesInputs.value,
              path: "parameters",
              onValueChanged: valueChanged,
              onActivate: onWorkflowActivate,
              onParameterBlur
            }, {
              default: withCtx(() => [
                createVNode(NodeCredentials, {
                  node: node2.value,
                  readonly: isReadOnly.value,
                  "show-all": true,
                  "hide-issues": hiddenIssuesInputs.value.includes("credentials"),
                  onCredentialSelected: credentialSelected,
                  onValueChanged: valueChanged,
                  onBlur: onParameterBlur
                }, null, 8, ["node", "readonly", "hide-issues"])
              ]),
              _: 1
            }, 8, ["parameters", "node-values", "is-read-only", "hidden-issues-inputs"])) : createCommentVNode("", true),
            parametersNoneSetting.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
              createVNode(_component_n8n_text, null, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("nodeSettings.thisNodeDoesNotHaveAnyParameters")), 1)
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true),
            unref(nodeHelpers).isCustomApiCallSelected(nodeValues.value) ? (openBlock(), createElementBlock("div", _hoisted_10$2, [
              createVNode(_component_n8n_notice, {
                content: unref(i18n).baseText("nodeSettings.useTheHttpRequestNode", {
                  interpolate: { nodeTypeDisplayName: _ctx.nodeType?.displayName ?? "" }
                })
              }, null, 8, ["content"])
            ])) : createCommentVNode("", true)
          ], 512), [
            [vShow, openPanel.value === "params"]
          ]),
          withDirectives(createBaseVNode("div", null, [
            createVNode(_sfc_main$A, {
              parameters: parametersSetting.value,
              "node-values": nodeValues.value,
              "is-read-only": isReadOnly.value,
              "hide-delete": true,
              "hidden-issues-inputs": hiddenIssuesInputs.value,
              path: "parameters",
              onValueChanged: valueChanged,
              onParameterBlur
            }, null, 8, ["parameters", "node-values", "is-read-only", "hidden-issues-inputs"]),
            createVNode(_sfc_main$A, {
              parameters: nodeSettings.value,
              "hide-delete": true,
              "node-values": nodeValues.value,
              "is-read-only": isReadOnly.value,
              "hidden-issues-inputs": hiddenIssuesInputs.value,
              path: "",
              onValueChanged: valueChanged,
              onParameterBlur
            }, null, 8, ["parameters", "node-values", "is-read-only", "hidden-issues-inputs"]),
            createBaseVNode("div", _hoisted_11$2, [
              createTextVNode(toDisplayString(unref(i18n).baseText("nodeSettings.nodeVersion", {
                interpolate: {
                  node: _ctx.nodeType?.displayName,
                  version: (node2.value.typeVersion ?? latestVersion.value).toString()
                }
              })) + " ", 1),
              createBaseVNode("span", null, "(" + toDisplayString(nodeVersionTag.value) + ")", 1)
            ])
          ], 512), [
            [vShow, openPanel.value === "settings"]
          ])
        ])) : createCommentVNode("", true),
        node2.value ? (openBlock(), createBlock(NDVSubConnections, {
          key: 2,
          ref_key: "subConnections",
          ref: subConnections,
          "root-node": node2.value,
          onSwitchSelectedNode,
          onOpenConnectionNodeCreator
        }, null, 8, ["root-node"])) : createCommentVNode("", true),
        createVNode(_component_n8n_block_ui, { show: _ctx.blockUI }, null, 8, ["show"])
      ], 34);
    };
  }
});
const header$2 = "_header_13al3_123";
const warningIcon = "_warningIcon_13al3_127";
const descriptionContainer = "_descriptionContainer_13al3_132";
const style0$d = {
  header: header$2,
  warningIcon,
  descriptionContainer
};
const cssModules$f = {
  "$style": style0$d
};
const NodeSettings = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__cssModules", cssModules$f], ["__scopeId", "data-v-1d71f962"]]);
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "PanelDragButton",
  props: {
    canMoveRight: { type: Boolean },
    canMoveLeft: { type: Boolean }
  },
  emits: ["drag", "dragstart", "dragend"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const onDrag = (e) => {
      emit("drag", e);
    };
    const onDragEnd = () => {
      emit("dragend");
    };
    const onDragStart = () => {
      emit("dragstart");
    };
    return (_ctx, _cache) => {
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      return openBlock(), createBlock(Draggable, {
        type: "panel-resize",
        class: normalizeClass(_ctx.$style.dragContainer),
        onDrag,
        onDragstart: onDragStart,
        onDragend: onDragEnd
      }, {
        default: withCtx(({ isDragging }) => [
          createBaseVNode("div", {
            class: normalizeClass({ [_ctx.$style.dragButton]: true }),
            "data-test-id": "panel-drag-button"
          }, [
            _ctx.canMoveLeft ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass({ [_ctx.$style.leftArrow]: true, [_ctx.$style.visible]: isDragging })
            }, [
              createVNode(_component_font_awesome_icon, { icon: "arrow-left" })
            ], 2)) : createCommentVNode("", true),
            _ctx.canMoveRight ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass({ [_ctx.$style.rightArrow]: true, [_ctx.$style.visible]: isDragging })
            }, [
              createVNode(_component_font_awesome_icon, { icon: "arrow-right" })
            ], 2)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.grid)
            }, _cache[0] || (_cache[0] = [
              createBaseVNode("div", null, [
                createBaseVNode("div"),
                createBaseVNode("div"),
                createBaseVNode("div"),
                createBaseVNode("div"),
                createBaseVNode("div")
              ], -1),
              createBaseVNode("div", null, [
                createBaseVNode("div"),
                createBaseVNode("div"),
                createBaseVNode("div"),
                createBaseVNode("div"),
                createBaseVNode("div")
              ], -1)
            ]), 2)
          ], 2)
        ]),
        _: 1
      }, 8, ["class"]);
    };
  }
});
const dragContainer = "_dragContainer_16elv_123";
const dragButton = "_dragButton_16elv_127";
const leftArrow = "_leftArrow_16elv_141 _arrow_16elv_150";
const rightArrow = "_rightArrow_16elv_142 _arrow_16elv_150";
const visible$1 = "_visible_16elv_146";
const arrow = "_arrow_16elv_150";
const grid = "_grid_16elv_168";
const style0$c = {
  dragContainer,
  dragButton,
  leftArrow,
  rightArrow,
  visible: visible$1,
  arrow,
  grid
};
const cssModules$e = {
  "$style": style0$c
};
const PanelDragButton = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__cssModules", cssModules$e]]);
const _hoisted_1$d = ["data-node-name", "data-node-placement", "onClick"];
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "NDVFloatingNodes",
  props: {
    rootNode: {}
  },
  emits: ["switchSelectedNode"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const workflow = workflowsStore.getCurrentWorkflow();
    const emit = __emit;
    function moveNodeDirection(direction) {
      const matchedDirectionNode = connectedNodes2.value[direction][0];
      if (matchedDirectionNode) {
        emit("switchSelectedNode", matchedDirectionNode.node.name);
      }
    }
    function onKeyDown(e) {
      if (e.shiftKey && e.altKey && (e.ctrlKey || e.metaKey)) {
        const mapper = {
          ArrowUp: "outputSub",
          ArrowRight: "outputMain",
          ArrowLeft: "inputMain"
          /* left */
        };
        const matchingDirection = mapper[e.key] || null;
        if (matchingDirection) {
          moveNodeDirection(matchingDirection);
        }
      }
    }
    function getINodesFromNames(names) {
      return names.map((name) => {
        const node2 = workflowsStore.getNodeByName(name);
        if (node2) {
          const nodeType = nodeTypesStore.getNodeType(node2.type);
          if (nodeType) {
            return { node: node2, nodeType };
          }
        }
        return null;
      }).filter((n) => n !== null);
    }
    const connectedNodes2 = computed(() => {
      const rootName = props.rootNode.name;
      return {
        [
          "outputSub"
          /* top */
        ]: getINodesFromNames(
          workflow.getChildNodes(rootName, "ALL_NON_MAIN")
        ),
        [
          "outputMain"
          /* right */
        ]: getINodesFromNames(
          workflow.getChildNodes(rootName, NodeConnectionType.Main, 1)
        ).reverse(),
        [
          "inputMain"
          /* left */
        ]: getINodesFromNames(
          workflow.getParentNodes(rootName, NodeConnectionType.Main, 1)
        )
      };
    });
    const connectionGroups = [
      "outputSub",
      "outputMain",
      "inputMain"
      /* left */
    ];
    const tooltipPositionMapper = {
      [
        "outputSub"
        /* top */
      ]: "bottom",
      [
        "outputMain"
        /* right */
      ]: "left",
      [
        "inputMain"
        /* left */
      ]: "right"
    };
    onMounted(() => {
      document.addEventListener("keydown", onKeyDown, true);
    });
    onBeforeUnmount(() => {
      document.removeEventListener("keydown", onKeyDown, true);
    });
    __expose({
      moveNodeDirection
    });
    return (_ctx, _cache) => {
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createElementBlock("aside", {
        class: normalizeClass(_ctx.$style.floatingNodes)
      }, [
        (openBlock(), createElementBlock(Fragment, null, renderList(connectionGroups, (connectionGroup) => {
          return createBaseVNode("ul", {
            key: connectionGroup,
            class: normalizeClass([_ctx.$style.nodesList, _ctx.$style[connectionGroup]])
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(connectedNodes2.value[connectionGroup], ({ node: node2, nodeType }) => {
              return openBlock(), createElementBlock(Fragment, null, [
                node2 && nodeType ? (openBlock(), createBlock(_component_n8n_tooltip, {
                  key: node2.name,
                  placement: tooltipPositionMapper[connectionGroup],
                  teleported: false,
                  offset: 60
                }, {
                  content: withCtx(() => [
                    createTextVNode(toDisplayString(node2.name), 1)
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("li", {
                      class: normalizeClass(_ctx.$style.connectedNode),
                      "data-test-id": "floating-node",
                      "data-node-name": node2.name,
                      "data-node-placement": connectionGroup,
                      onClick: ($event) => emit("switchSelectedNode", node2.name)
                    }, [
                      createVNode(_sfc_main$z, {
                        "node-type": nodeType,
                        "node-name": node2.name,
                        "tooltip-position": tooltipPositionMapper[connectionGroup],
                        size: 35,
                        circle: ""
                      }, null, 8, ["node-type", "node-name", "tooltip-position"])
                    ], 10, _hoisted_1$d)
                  ]),
                  _: 2
                }, 1032, ["placement"])) : createCommentVNode("", true)
              ], 64);
            }), 256))
          ], 2);
        }), 64))
      ], 2);
    };
  }
});
const floatingNodes = "_floatingNodes_1tkq5_123";
const nodesList = "_nodesList_1tkq5_137";
const inputSub = "_inputSub_1tkq5_151";
const outputSub = "_outputSub_1tkq5_151";
const outputMain = "_outputMain_1tkq5_162";
const inputMain = "_inputMain_1tkq5_162";
const connectedNode = "_connectedNode_1tkq5_185";
const style0$b = {
  floatingNodes,
  nodesList,
  inputSub,
  outputSub,
  outputMain,
  inputMain,
  connectedNode
};
const cssModules$d = {
  "$style": style0$b
};
const NDVFloatingNodes = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__cssModules", cssModules$d]]);
const SIDE_MARGIN = 24;
const SIDE_PANELS_MARGIN = 80;
const MIN_PANEL_WIDTH = 310;
const PANEL_WIDTH = 350;
const PANEL_WIDTH_LARGE = 420;
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "NDVDraggablePanels",
  props: {
    isDraggable: { type: Boolean },
    hideInputAndOutput: { type: Boolean },
    nodeType: {}
  },
  emits: ["init", "dragstart", "dragend", "switchSelectedNode", "close"],
  setup(__props, { emit: __emit }) {
    const MIN_WINDOW_WIDTH = 2 * (SIDE_MARGIN + SIDE_PANELS_MARGIN) + MIN_PANEL_WIDTH;
    const initialMainPanelWidth = {
      regular: MAIN_NODE_PANEL_WIDTH,
      dragless: MAIN_NODE_PANEL_WIDTH,
      unknown: MAIN_NODE_PANEL_WIDTH,
      inputless: MAIN_NODE_PANEL_WIDTH,
      wide: MAIN_NODE_PANEL_WIDTH * 2
    };
    const throttledOnResize = useThrottleFn(onResize, 100);
    const ndvStore = useNDVStore();
    const uiStore = useUIStore();
    const props = __props;
    const isDragging = ref(false);
    const initialized = ref(false);
    const emit = __emit;
    const slots = useSlots();
    onMounted(() => {
      if (mainPanelDimensions.value.relativeLeft === 1 && mainPanelDimensions.value.relativeRight === 1) {
        setMainPanelWidth();
        setPositions(getInitialLeftPosition(mainPanelDimensions.value.relativeWidth));
        restorePositionData();
      }
      emit("init", { position: mainPanelDimensions.value.relativeLeft });
      setTimeout(() => {
        initialized.value = true;
      }, 0);
      ndvEventBus.on("setPositionByName", setPositionByName);
    });
    onBeforeUnmount(() => {
      ndvEventBus.off("setPositionByName", setPositionByName);
    });
    const containerWidth = computed(() => uiStore.appGridWidth);
    watch(containerWidth, (width) => {
      const minRelativeWidth = pxToRelativeWidth(MIN_PANEL_WIDTH);
      const isBelowMinWidthMainPanel = mainPanelDimensions.value.relativeWidth < minRelativeWidth;
      if (isBelowMinWidthMainPanel) {
        setMainPanelWidth(minRelativeWidth);
      }
      const isBelowMinLeft = minimumLeftPosition.value > mainPanelDimensions.value.relativeLeft;
      const isMaxRight = maximumRightPosition.value > mainPanelDimensions.value.relativeRight;
      if (width > MIN_WINDOW_WIDTH && isBelowMinLeft && isMaxRight) {
        setMainPanelWidth(minRelativeWidth);
        setPositions(getInitialLeftPosition(mainPanelDimensions.value.relativeWidth));
      }
      setPositions(mainPanelDimensions.value.relativeLeft);
    });
    const currentNodePaneType = computed(() => {
      if (!hasInputSlot.value) return "inputless";
      if (!props.isDraggable) return "dragless";
      if (props.nodeType === null) return "unknown";
      return props.nodeType.parameterPane ?? "regular";
    });
    const mainPanelDimensions = computed(() => {
      return ndvStore.mainPanelDimensions[currentNodePaneType.value];
    });
    const calculatedPositions = computed(
      () => {
        const hasInput = slots.input !== void 0;
        const outputPanelRelativeLeft = mainPanelDimensions.value.relativeLeft + mainPanelDimensions.value.relativeWidth;
        const inputPanelRelativeRight = hasInput ? 1 - outputPanelRelativeLeft + mainPanelDimensions.value.relativeWidth : 1 - pxToRelativeWidth(SIDE_MARGIN);
        return {
          inputPanelRelativeRight,
          outputPanelRelativeLeft
        };
      }
    );
    const outputPanelRelativeTranslate = computed(() => {
      const panelMinLeft = 1 - pxToRelativeWidth(MIN_PANEL_WIDTH + SIDE_MARGIN);
      const currentRelativeLeftDelta = calculatedPositions.value.outputPanelRelativeLeft - panelMinLeft;
      return currentRelativeLeftDelta > 0 ? currentRelativeLeftDelta : 0;
    });
    const supportedResizeDirections = computed(() => {
      const supportedDirections = ["right"];
      if (props.isDraggable) supportedDirections.push("left");
      return supportedDirections;
    });
    const hasInputSlot = computed(() => {
      return slots.input !== void 0;
    });
    const inputPanelMargin = computed(() => pxToRelativeWidth(SIDE_PANELS_MARGIN));
    const minimumLeftPosition = computed(() => {
      if (containerWidth.value < MIN_WINDOW_WIDTH) return pxToRelativeWidth(1);
      if (!hasInputSlot.value) return pxToRelativeWidth(SIDE_MARGIN);
      return pxToRelativeWidth(SIDE_MARGIN + 20) + inputPanelMargin.value;
    });
    const maximumRightPosition = computed(() => {
      if (containerWidth.value < MIN_WINDOW_WIDTH) return pxToRelativeWidth(1);
      return pxToRelativeWidth(SIDE_MARGIN + 20) + inputPanelMargin.value;
    });
    const canMoveLeft = computed(() => {
      return mainPanelDimensions.value.relativeLeft > minimumLeftPosition.value;
    });
    const canMoveRight = computed(() => {
      return mainPanelDimensions.value.relativeRight > maximumRightPosition.value;
    });
    const mainPanelStyles = computed(() => {
      return {
        left: `${relativeWidthToPx(mainPanelDimensions.value.relativeLeft)}px`,
        right: `${relativeWidthToPx(mainPanelDimensions.value.relativeRight)}px`
      };
    });
    const inputPanelStyles = computed(() => {
      return {
        right: `${relativeWidthToPx(calculatedPositions.value.inputPanelRelativeRight)}px`
      };
    });
    const outputPanelStyles = computed(() => {
      return {
        left: `${relativeWidthToPx(calculatedPositions.value.outputPanelRelativeLeft)}px`,
        transform: `translateX(-${relativeWidthToPx(outputPanelRelativeTranslate.value)}px)`
      };
    });
    const hasDoubleWidth = computed(() => {
      return props.nodeType?.parameterPane === "wide";
    });
    const fixedPanelWidth = computed(() => {
      const multiplier = hasDoubleWidth.value ? 2 : 1;
      if (containerWidth.value > 1700) {
        return PANEL_WIDTH_LARGE * multiplier;
      }
      return PANEL_WIDTH * multiplier;
    });
    const onSwitchSelectedNode = (node2) => emit("switchSelectedNode", node2);
    function getInitialLeftPosition(width) {
      if (currentNodePaneType.value === "dragless")
        return pxToRelativeWidth(SIDE_MARGIN + 1 + fixedPanelWidth.value);
      return hasInputSlot.value ? 0.5 - width / 2 : minimumLeftPosition.value;
    }
    function setMainPanelWidth(relativeWidth) {
      const mainPanelRelativeWidth = relativeWidth || pxToRelativeWidth(initialMainPanelWidth[currentNodePaneType.value]);
      ndvStore.setMainPanelDimensions({
        panelType: currentNodePaneType.value,
        dimensions: {
          relativeWidth: mainPanelRelativeWidth
        }
      });
    }
    function setPositions(relativeLeft) {
      const mainPanelRelativeLeft = relativeLeft || 1 - calculatedPositions.value.inputPanelRelativeRight;
      const mainPanelRelativeRight = 1 - mainPanelRelativeLeft - mainPanelDimensions.value.relativeWidth;
      const isMaxRight = maximumRightPosition.value > mainPanelRelativeRight;
      const isMinLeft = minimumLeftPosition.value > mainPanelRelativeLeft;
      const isInputless = currentNodePaneType.value === "inputless";
      if (isMinLeft) {
        ndvStore.setMainPanelDimensions({
          panelType: currentNodePaneType.value,
          dimensions: {
            relativeLeft: minimumLeftPosition.value,
            relativeRight: 1 - mainPanelDimensions.value.relativeWidth - minimumLeftPosition.value
          }
        });
        return;
      }
      if (isMaxRight) {
        ndvStore.setMainPanelDimensions({
          panelType: currentNodePaneType.value,
          dimensions: {
            relativeLeft: 1 - mainPanelDimensions.value.relativeWidth - maximumRightPosition.value,
            relativeRight: maximumRightPosition.value
          }
        });
        return;
      }
      ndvStore.setMainPanelDimensions({
        panelType: currentNodePaneType.value,
        dimensions: {
          relativeLeft: isInputless ? minimumLeftPosition.value : mainPanelRelativeLeft,
          relativeRight: mainPanelRelativeRight
        }
      });
    }
    function setPositionByName(position) {
      const positionByName = {
        minLeft: minimumLeftPosition.value,
        maxRight: maximumRightPosition.value,
        initial: getInitialLeftPosition(mainPanelDimensions.value.relativeWidth)
      };
      setPositions(positionByName[position]);
    }
    function pxToRelativeWidth(px) {
      return px / containerWidth.value;
    }
    function relativeWidthToPx(relativeWidth) {
      return relativeWidth * containerWidth.value;
    }
    function onResizeEnd() {
      storePositionData();
    }
    function onResizeThrottle(data) {
      if (initialized.value) {
        void throttledOnResize(data);
      }
    }
    function onResize({ direction, x, width }) {
      const relativeDistance = pxToRelativeWidth(x);
      const relativeWidth = pxToRelativeWidth(width);
      if (direction === "left" && relativeDistance <= minimumLeftPosition.value) return;
      if (direction === "right" && 1 - relativeDistance <= maximumRightPosition.value) return;
      if (width <= MIN_PANEL_WIDTH) return;
      setMainPanelWidth(relativeWidth);
      setPositions(direction === "left" ? relativeDistance : mainPanelDimensions.value.relativeLeft);
    }
    function restorePositionData() {
      const storedPanelWidthData = useStorage(
        `${LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH}_${currentNodePaneType.value}`
      ).value;
      if (storedPanelWidthData) {
        const parsedWidth = parseFloat(storedPanelWidthData);
        setMainPanelWidth(parsedWidth);
        const initialPosition = getInitialLeftPosition(parsedWidth);
        setPositions(initialPosition);
        return true;
      }
      return false;
    }
    function storePositionData() {
      useStorage(`${LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH}_${currentNodePaneType.value}`).value = mainPanelDimensions.value.relativeWidth.toString();
    }
    function onDragStart() {
      isDragging.value = true;
      emit("dragstart", { position: mainPanelDimensions.value.relativeLeft });
    }
    function onDrag(position) {
      const relativeLeft = pxToRelativeWidth(position[0]) - mainPanelDimensions.value.relativeWidth / 2;
      setPositions(relativeLeft);
    }
    function onDragEnd() {
      setTimeout(() => {
        isDragging.value = false;
        emit("dragend", {
          windowWidth: containerWidth.value,
          position: mainPanelDimensions.value.relativeLeft
        });
      }, 0);
      storePositionData();
    }
    return (_ctx, _cache) => {
      const _component_N8nResizeWrapper = resolveComponent("N8nResizeWrapper");
      return openBlock(), createElementBlock("div", null, [
        unref(ndvStore).activeNode ? (openBlock(), createBlock(NDVFloatingNodes, {
          key: 0,
          "root-node": unref(ndvStore).activeNode,
          onSwitchSelectedNode
        }, null, 8, ["root-node"])) : createCommentVNode("", true),
        !_ctx.hideInputAndOutput ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.$style.inputPanel),
          style: normalizeStyle(inputPanelStyles.value)
        }, [
          renderSlot(_ctx.$slots, "input")
        ], 6)) : createCommentVNode("", true),
        !_ctx.hideInputAndOutput ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(_ctx.$style.outputPanel),
          style: normalizeStyle(outputPanelStyles.value)
        }, [
          renderSlot(_ctx.$slots, "output")
        ], 6)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.mainPanel),
          style: normalizeStyle(mainPanelStyles.value)
        }, [
          createVNode(_component_N8nResizeWrapper, {
            "is-resizing-enabled": currentNodePaneType.value !== "unknown",
            width: relativeWidthToPx(mainPanelDimensions.value.relativeWidth),
            "min-width": MIN_PANEL_WIDTH,
            "grid-size": 20,
            "supported-directions": supportedResizeDirections.value,
            outset: "",
            onResize: onResizeThrottle,
            onResizeend: onResizeEnd
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.dragButtonContainer)
              }, [
                !_ctx.hideInputAndOutput && _ctx.isDraggable ? (openBlock(), createBlock(PanelDragButton, {
                  key: 0,
                  class: normalizeClass({ [_ctx.$style.draggable]: true, [_ctx.$style.visible]: isDragging.value }),
                  "can-move-left": canMoveLeft.value,
                  "can-move-right": canMoveRight.value,
                  onDragstart: onDragStart,
                  onDrag,
                  onDragend: onDragEnd
                }, null, 8, ["class", "can-move-left", "can-move-right"])) : createCommentVNode("", true)
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass({ [_ctx.$style.mainPanelInner]: true, [_ctx.$style.dragging]: isDragging.value })
              }, [
                renderSlot(_ctx.$slots, "main")
              ], 2)
            ]),
            _: 3
          }, 8, ["is-resizing-enabled", "width", "supported-directions"])
        ], 6)
      ]);
    };
  }
});
const dataPanel = "_dataPanel_181lg_123";
const inputPanel = "_inputPanel_181lg_132 _dataPanel_181lg_123";
const outputPanel = "_outputPanel_181lg_140 _dataPanel_181lg_123";
const mainPanel = "_mainPanel_181lg_148";
const draggable = "_draggable_181lg_152";
const mainPanelInner = "_mainPanelInner_181lg_156";
const dragging = "_dragging_181lg_163";
const dragButtonContainer = "_dragButtonContainer_181lg_176";
const visible = "_visible_181lg_192";
const style0$a = {
  dataPanel,
  inputPanel,
  outputPanel,
  mainPanel,
  draggable,
  mainPanelInner,
  dragging,
  "double-width": "_double-width_181lg_172",
  dragButtonContainer,
  visible
};
const cssModules$c = {
  "$style": style0$a
};
const NDVDraggablePanels = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__cssModules", cssModules$c]]);
var vueJsonPretty$1 = { exports: {} };
var vueJsonPretty = vueJsonPretty$1.exports;
var hasRequiredVueJsonPretty;
function requireVueJsonPretty() {
  if (hasRequiredVueJsonPretty) return vueJsonPretty$1.exports;
  hasRequiredVueJsonPretty = 1;
  (function(module, exports) {
    !function(e, t) {
      module.exports = t(requireVue());
    }(vueJsonPretty, function(e) {
      return function() {
        var t = { 789: function(t2) {
          t2.exports = e;
        } }, n = {};
        function o(e2) {
          var r2 = n[e2];
          if (void 0 !== r2) return r2.exports;
          var l = n[e2] = { exports: {} };
          return t[e2](l, l.exports, o), l.exports;
        }
        o.d = function(e2, t2) {
          for (var n2 in t2) o.o(t2, n2) && !o.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
        }, o.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, o.r = function(e2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        };
        var r = {};
        return function() {
          function e2(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var n3 = 0, o2 = new Array(t3); n3 < t3; n3++) o2[n3] = e3[n3];
            return o2;
          }
          function t2(t3, n3) {
            if (t3) {
              if ("string" == typeof t3) return e2(t3, n3);
              var o2 = Object.prototype.toString.call(t3).slice(8, -1);
              return "Object" === o2 && t3.constructor && (o2 = t3.constructor.name), "Map" === o2 || "Set" === o2 ? Array.from(t3) : "Arguments" === o2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o2) ? e2(t3, n3) : void 0;
            }
          }
          function n2(n3) {
            return function(t3) {
              if (Array.isArray(t3)) return e2(t3);
            }(n3) || function(e3) {
              if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"]) return Array.from(e3);
            }(n3) || t2(n3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function l(e3, t3, n3) {
            return t3 in e3 ? Object.defineProperty(e3, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[t3] = n3, e3;
          }
          o.r(r), o.d(r, { default: function() {
            return k;
          } });
          var a = o(789), c = (0, a.defineComponent)({ props: { data: { required: true, type: String }, onClick: Function }, render: function() {
            var e3 = this.data, t3 = this.onClick;
            return (0, a.createVNode)("span", { class: "vjs-tree-brackets", onClick: t3 }, [e3]);
          } }), i = (0, a.defineComponent)({ emits: ["change", "update:modelValue"], props: { checked: { type: Boolean, default: false }, isMultiple: Boolean, onChange: Function }, setup: function(e3, t3) {
            var n3 = t3.emit;
            return { uiType: (0, a.computed)(function() {
              return e3.isMultiple ? "checkbox" : "radio";
            }), model: (0, a.computed)({ get: function() {
              return e3.checked;
            }, set: function(e4) {
              return n3("update:modelValue", e4);
            } }) };
          }, render: function() {
            var e3 = this.uiType, t3 = this.model, n3 = this.$emit;
            return (0, a.createVNode)("label", { class: ["vjs-check-controller", t3 ? "is-checked" : ""], onClick: function(e4) {
              return e4.stopPropagation();
            } }, [(0, a.createVNode)("span", { class: "vjs-check-controller-inner is-".concat(e3) }, null), (0, a.createVNode)("input", { checked: t3, class: "vjs-check-controller-original is-".concat(e3), type: e3, onChange: function() {
              return n3("change", t3);
            } }, null)]);
          } }), u = (0, a.defineComponent)({ props: { nodeType: { required: true, type: String }, onClick: Function }, render: function() {
            var e3 = this.nodeType, t3 = this.onClick, n3 = "objectStart" === e3 || "arrayStart" === e3;
            return n3 || "objectCollapsed" === e3 || "arrayCollapsed" === e3 ? (0, a.createVNode)("span", { class: "vjs-carets vjs-carets-".concat(n3 ? "open" : "close"), onClick: t3 }, [(0, a.createVNode)("svg", { viewBox: "0 0 1024 1024", focusable: "false", "data-icon": "caret-down", width: "1em", height: "1em", fill: "currentColor", "aria-hidden": "true" }, [(0, a.createVNode)("path", { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }, null)])]) : null;
          } });
          function d(e3) {
            return d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, d(e3);
          }
          function s(e3) {
            return Object.prototype.toString.call(e3).slice(8, -1).toLowerCase();
          }
          function p(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "root", n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o2 = arguments.length > 3 ? arguments[3] : void 0, r2 = o2 || {}, l2 = r2.key, a2 = r2.index, c2 = r2.type, i2 = void 0 === c2 ? "content" : c2, u2 = r2.showComma, d2 = void 0 !== u2 && u2, f2 = r2.length, y2 = void 0 === f2 ? 1 : f2, v2 = s(e3);
            if ("array" === v2) {
              var b2 = h2(e3.map(function(e4, o3, r3) {
                return p(e4, "".concat(t3, "[").concat(o3, "]"), n3 + 1, { index: o3, showComma: o3 !== r3.length - 1, length: y2, type: i2 });
              }));
              return [p("[", t3, n3, { showComma: false, key: l2, length: e3.length, type: "arrayStart" })[0]].concat(b2, p("]", t3, n3, { showComma: d2, length: e3.length, type: "arrayEnd" })[0]);
            }
            if ("object" === v2) {
              var g2 = Object.keys(e3), m2 = h2(g2.map(function(o3, r3, l3) {
                return p(e3[o3], /^[a-zA-Z_]\w*$/.test(o3) ? "".concat(t3, ".").concat(o3) : "".concat(t3, '["').concat(o3, '"]'), n3 + 1, { key: o3, showComma: r3 !== l3.length - 1, length: y2, type: i2 });
              }));
              return [p("{", t3, n3, { showComma: false, key: l2, index: a2, length: g2.length, type: "objectStart" })[0]].concat(m2, p("}", t3, n3, { showComma: d2, length: g2.length, type: "objectEnd" })[0]);
            }
            return [{ content: e3, level: n3, key: l2, index: a2, path: t3, showComma: d2, length: y2, type: i2 }];
          }
          function h2(e3) {
            if ("function" == typeof Array.prototype.flat) return e3.flat();
            for (var t3 = n2(e3), o2 = []; t3.length; ) {
              var r2 = t3.shift();
              Array.isArray(r2) ? t3.unshift.apply(t3, n2(r2)) : o2.push(r2);
            }
            return o2;
          }
          function f(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new WeakMap();
            if (null == e3) return e3;
            if (e3 instanceof Date) return new Date(e3);
            if (e3 instanceof RegExp) return new RegExp(e3);
            if ("object" !== d(e3)) return e3;
            if (t3.get(e3)) return t3.get(e3);
            if (Array.isArray(e3)) {
              var n3 = e3.map(function(e4) {
                return f(e4, t3);
              });
              return t3.set(e3, n3), n3;
            }
            var o2 = {};
            for (var r2 in e3) o2[r2] = f(e3[r2], t3);
            return t3.set(e3, o2), o2;
          }
          function y(e3, t3) {
            var n3 = Object.keys(e3);
            if (Object.getOwnPropertySymbols) {
              var o2 = Object.getOwnPropertySymbols(e3);
              t3 && (o2 = o2.filter(function(t4) {
                return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
              })), n3.push.apply(n3, o2);
            }
            return n3;
          }
          function v(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? y(Object(n3), true).forEach(function(t4) {
                l(e3, t4, n3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : y(Object(n3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
              });
            }
            return e3;
          }
          var b = { showLength: { type: Boolean, default: false }, showDoubleQuotes: { type: Boolean, default: true }, renderNodeKey: Function, renderNodeValue: Function, selectableType: String, showSelectController: { type: Boolean, default: false }, showLine: { type: Boolean, default: true }, showLineNumber: { type: Boolean, default: false }, selectOnClickNode: { type: Boolean, default: true }, nodeSelectable: { type: Function, default: function() {
            return true;
          } }, highlightSelectedNode: { type: Boolean, default: true }, showIcon: { type: Boolean, default: false }, showKeyValueSpace: { type: Boolean, default: true }, editable: { type: Boolean, default: false }, editableTrigger: { type: String, default: "click" }, onNodeClick: { type: Function }, onBracketsClick: { type: Function }, onIconClick: { type: Function }, onValueChange: { type: Function } }, g = (0, a.defineComponent)({ name: "TreeNode", props: v(v({}, b), {}, { node: { type: Object, required: true }, collapsed: Boolean, checked: Boolean, style: Object, onSelectedChange: { type: Function } }), emits: ["nodeClick", "bracketsClick", "iconClick", "selectedChange", "valueChange"], setup: function(e3, t3) {
            var n3 = t3.emit, o2 = (0, a.computed)(function() {
              return s(e3.node.content);
            }), r2 = (0, a.computed)(function() {
              return "vjs-value vjs-value-".concat(o2.value);
            }), l2 = (0, a.computed)(function() {
              return e3.showDoubleQuotes ? '"'.concat(e3.node.key, '"') : e3.node.key;
            }), d2 = (0, a.computed)(function() {
              return "multiple" === e3.selectableType;
            }), p2 = (0, a.computed)(function() {
              return "single" === e3.selectableType;
            }), h3 = (0, a.computed)(function() {
              return e3.nodeSelectable(e3.node) && (d2.value || p2.value);
            }), f2 = (0, a.reactive)({ editing: false }), y2 = function(t4) {
              var o3, r3, l3 = "null" === (r3 = null === (o3 = t4.target) || void 0 === o3 ? void 0 : o3.value) ? null : "undefined" === r3 ? void 0 : "true" === r3 || "false" !== r3 && (r3[0] + r3[r3.length - 1] === '""' || r3[0] + r3[r3.length - 1] === "''" ? r3.slice(1, -1) : "number" == typeof Number(r3) && !isNaN(Number(r3)) || "NaN" === r3 ? Number(r3) : r3);
              n3("valueChange", l3, e3.node.path);
            }, v2 = (0, a.computed)(function() {
              var t4, n4 = null === (t4 = e3.node) || void 0 === t4 ? void 0 : t4.content;
              return null === n4 ? n4 = "null" : void 0 === n4 && (n4 = "undefined"), "string" === o2.value ? '"'.concat(n4, '"') : n4 + "";
            }), b2 = function() {
              var t4 = e3.renderNodeValue;
              return t4 ? t4({ node: e3.node, defaultValue: v2.value }) : v2.value;
            }, g2 = function() {
              n3("bracketsClick", !e3.collapsed, e3.node.path);
            }, m2 = function() {
              n3("iconClick", !e3.collapsed, e3.node.path);
            }, C2 = function() {
              n3("selectedChange", e3.node);
            }, k2 = function() {
              n3("nodeClick", e3.node), h3.value && e3.selectOnClickNode && n3("selectedChange", e3.node);
            }, w = function(t4) {
              if (e3.editable && !f2.editing) {
                f2.editing = true;
                var n4 = function e4(n5) {
                  var o3;
                  n5.target !== t4.target && (null === (o3 = n5.target) || void 0 === o3 ? void 0 : o3.parentElement) !== t4.target && (f2.editing = false, document.removeEventListener("click", e4));
                };
                document.removeEventListener("click", n4), document.addEventListener("click", n4);
              }
            };
            return function() {
              var t4, n4 = e3.node;
              return (0, a.createVNode)("div", { class: { "vjs-tree-node": true, "has-selector": e3.showSelectController, "has-carets": e3.showIcon, "is-highlight": e3.highlightSelectedNode && e3.checked }, onClick: k2, style: e3.style }, [e3.showLineNumber && (0, a.createVNode)("span", { class: "vjs-node-index" }, [n4.id + 1]), e3.showSelectController && h3.value && "objectEnd" !== n4.type && "arrayEnd" !== n4.type && (0, a.createVNode)(i, { isMultiple: d2.value, checked: e3.checked, onChange: C2 }, null), (0, a.createVNode)("div", { class: "vjs-indent" }, [Array.from(Array(n4.level)).map(function(t5, n5) {
                return (0, a.createVNode)("div", { key: n5, class: { "vjs-indent-unit": true, "has-line": e3.showLine } }, null);
              }), e3.showIcon && (0, a.createVNode)(u, { nodeType: n4.type, onClick: m2 }, null)]), n4.key && (0, a.createVNode)("span", { class: "vjs-key" }, [(t4 = e3.renderNodeKey, t4 ? t4({ node: e3.node, defaultKey: l2.value || "" }) : l2.value), (0, a.createVNode)("span", { class: "vjs-colon" }, [":".concat(e3.showKeyValueSpace ? " " : "")])]), (0, a.createVNode)("span", null, ["content" !== n4.type && n4.content ? (0, a.createVNode)(c, { data: n4.content.toString(), onClick: g2 }, null) : (0, a.createVNode)("span", { class: r2.value, onClick: !e3.editable || e3.editableTrigger && "click" !== e3.editableTrigger ? void 0 : w, onDblclick: e3.editable && "dblclick" === e3.editableTrigger ? w : void 0 }, [e3.editable && f2.editing ? (0, a.createVNode)("input", { value: v2.value, onChange: y2, style: { padding: "3px 8px", border: "1px solid #eee", boxShadow: "none", boxSizing: "border-box", borderRadius: 5, fontFamily: "inherit" } }, null) : b2()]), n4.showComma && (0, a.createVNode)("span", null, [","]), e3.showLength && e3.collapsed && (0, a.createVNode)("span", { class: "vjs-comment" }, [(0, a.createTextVNode)(" // "), n4.length, (0, a.createTextVNode)(" items ")])])]);
            };
          } });
          function m(e3, t3) {
            var n3 = Object.keys(e3);
            if (Object.getOwnPropertySymbols) {
              var o2 = Object.getOwnPropertySymbols(e3);
              t3 && (o2 = o2.filter(function(t4) {
                return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
              })), n3.push.apply(n3, o2);
            }
            return n3;
          }
          function C(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? m(Object(n3), true).forEach(function(t4) {
                l(e3, t4, n3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : m(Object(n3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
              });
            }
            return e3;
          }
          var k = (0, a.defineComponent)({ name: "Tree", props: C(C({}, b), {}, { data: { type: [String, Number, Boolean, Array, Object], default: null }, deep: { type: Number, default: 1 / 0 }, pathCollapsible: { type: Function, default: function() {
            return false;
          } }, rootPath: { type: String, default: "root" }, virtual: { type: Boolean, default: false }, height: { type: Number, default: 400 }, itemHeight: { type: Number, default: 20 }, selectedValue: { type: [String, Array], default: function() {
            return "";
          } }, collapsedOnClickBrackets: { type: Boolean, default: true }, style: Object, onSelectedChange: { type: Function } }), slots: ["renderNodeKey", "renderNodeValue"], emits: ["nodeClick", "bracketsClick", "iconClick", "selectedChange", "update:selectedValue", "update:data"], setup: function(e3, o2) {
            var r2 = o2.emit, c2 = o2.slots, i2 = (0, a.ref)(), u2 = (0, a.computed)(function() {
              return p(e3.data, e3.rootPath);
            }), d2 = function(t3) {
              return u2.value.reduce(function(n3, o3) {
                var r3, a2 = o3.level >= t3, c3 = null === (r3 = e3.pathCollapsible) || void 0 === r3 ? void 0 : r3.call(e3, o3);
                return "objectStart" !== o3.type && "arrayStart" !== o3.type || !a2 && !c3 ? n3 : C(C({}, n3), {}, l({}, o3.path, 1));
              }, {});
            }, s2 = (0, a.reactive)({ translateY: 0, visibleData: null, hiddenPaths: d2(e3.deep) }), h3 = (0, a.computed)(function() {
              for (var e4 = null, t3 = [], n3 = u2.value.length, o3 = 0; o3 < n3; o3++) {
                var r3 = C(C({}, u2.value[o3]), {}, { id: o3 }), l2 = s2.hiddenPaths[r3.path];
                if (e4 && e4.path === r3.path) {
                  var a2 = "objectStart" === e4.type, c3 = C(C(C({}, r3), e4), {}, { showComma: r3.showComma, content: a2 ? "{...}" : "[...]", type: a2 ? "objectCollapsed" : "arrayCollapsed" });
                  e4 = null, t3.push(c3);
                } else {
                  if (l2 && !e4) {
                    e4 = r3;
                    continue;
                  }
                  if (e4) continue;
                  t3.push(r3);
                }
              }
              return t3;
            }), y2 = (0, a.computed)(function() {
              var t3 = e3.selectedValue;
              return t3 && "multiple" === e3.selectableType && Array.isArray(t3) ? t3 : [t3];
            }), v2 = (0, a.computed)(function() {
              return !e3.selectableType || e3.selectOnClickNode || e3.showSelectController ? "" : "When selectableType is not null, selectOnClickNode and showSelectController cannot be false at the same time, because this will cause the selection to fail.";
            }), b2 = function() {
              var t3 = h3.value;
              if (e3.virtual) {
                var n3, o3 = e3.height / e3.itemHeight, r3 = (null === (n3 = i2.value) || void 0 === n3 ? void 0 : n3.scrollTop) || 0, l2 = Math.floor(r3 / e3.itemHeight), a2 = l2 < 0 ? 0 : l2 + o3 > t3.length ? t3.length - o3 : l2;
                a2 < 0 && (a2 = 0);
                var c3 = a2 + o3;
                s2.translateY = a2 * e3.itemHeight, s2.visibleData = t3.filter(function(e4, t4) {
                  return t4 >= a2 && t4 < c3;
                });
              } else s2.visibleData = t3;
            }, m2 = function() {
              b2();
            }, k2 = function(o3) {
              var l2, a2, c3 = o3.path, i3 = e3.selectableType;
              if ("multiple" === i3) {
                var u3 = y2.value.findIndex(function(e4) {
                  return e4 === c3;
                }), d3 = n2(y2.value);
                -1 !== u3 ? d3.splice(u3, 1) : d3.push(c3), r2("update:selectedValue", d3), r2("selectedChange", d3, n2(y2.value));
              } else if ("single" === i3 && y2.value[0] !== c3) {
                var s3 = (l2 = y2.value, a2 = 1, function(e4) {
                  if (Array.isArray(e4)) return e4;
                }(l2) || function(e4, t3) {
                  var n3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
                  if (null != n3) {
                    var o4, r3, l3 = [], a3 = true, c4 = false;
                    try {
                      for (n3 = n3.call(e4); !(a3 = (o4 = n3.next()).done) && (l3.push(o4.value), !t3 || l3.length !== t3); a3 = true) ;
                    } catch (e5) {
                      c4 = true, r3 = e5;
                    } finally {
                      try {
                        a3 || null == n3.return || n3.return();
                      } finally {
                        if (c4) throw r3;
                      }
                    }
                    return l3;
                  }
                }(l2, a2) || t2(l2, a2) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }())[0], p2 = c3;
                r2("update:selectedValue", p2), r2("selectedChange", p2, s3);
              }
            }, w = function(e4) {
              r2("nodeClick", e4);
            }, N = function(e4, t3) {
              if (e4) s2.hiddenPaths = C(C({}, s2.hiddenPaths), {}, l({}, t3, 1));
              else {
                var n3 = C({}, s2.hiddenPaths);
                delete n3[t3], s2.hiddenPaths = n3;
              }
            }, j = function(t3, n3) {
              e3.collapsedOnClickBrackets && N(t3, n3), r2("bracketsClick", t3);
            }, S = function(e4, t3) {
              N(e4, t3), r2("iconClick", e4);
            }, O = function(t3, n3) {
              var o3 = f(e3.data), l2 = e3.rootPath;
              new Function("data", "val", "data".concat(n3.slice(l2.length), "=val"))(o3, t3), r2("update:data", o3);
            };
            return (0, a.watchEffect)(function() {
              v2.value && function(e4) {
                throw new Error("[VueJSONPretty] ".concat(e4));
              }(v2.value);
            }), (0, a.watchEffect)(function() {
              h3.value && b2();
            }), (0, a.watch)(function() {
              return e3.deep;
            }, function(e4) {
              e4 && (s2.hiddenPaths = d2(e4));
            }), function() {
              var t3, n3, o3 = null !== (t3 = e3.renderNodeKey) && void 0 !== t3 ? t3 : c2.renderNodeKey, r3 = null !== (n3 = e3.renderNodeValue) && void 0 !== n3 ? n3 : c2.renderNodeValue, l2 = s2.visibleData && s2.visibleData.map(function(t4) {
                return (0, a.createVNode)(g, { key: t4.id, node: t4, collapsed: !!s2.hiddenPaths[t4.path], showDoubleQuotes: e3.showDoubleQuotes, showLength: e3.showLength, checked: y2.value.includes(t4.path), selectableType: e3.selectableType, showLine: e3.showLine, showLineNumber: e3.showLineNumber, showSelectController: e3.showSelectController, selectOnClickNode: e3.selectOnClickNode, nodeSelectable: e3.nodeSelectable, highlightSelectedNode: e3.highlightSelectedNode, editable: e3.editable, editableTrigger: e3.editableTrigger, showIcon: e3.showIcon, showKeyValueSpace: e3.showKeyValueSpace, renderNodeKey: o3, renderNodeValue: r3, onNodeClick: w, onBracketsClick: j, onIconClick: S, onSelectedChange: k2, onValueChange: O, style: e3.itemHeight && 20 !== e3.itemHeight ? { lineHeight: "".concat(e3.itemHeight, "px") } : {} }, null);
              });
              return (0, a.createVNode)("div", { ref: i2, class: { "vjs-tree": true, "is-virtual": e3.virtual }, onScroll: e3.virtual ? m2 : void 0, style: e3.showLineNumber ? C({ paddingLeft: "".concat(12 * Number(u2.value.length.toString().length), "px") }, e3.style) : e3.style }, [e3.virtual ? (0, a.createVNode)("div", { class: "vjs-tree-list", style: { height: "".concat(e3.height, "px") } }, [(0, a.createVNode)("div", { class: "vjs-tree-list-holder", style: { height: "".concat(h3.value.length * e3.itemHeight, "px") } }, [(0, a.createVNode)("div", { class: "vjs-tree-list-holder-inner", style: { transform: "translateY(".concat(s2.translateY, "px)") } }, [l2])])]) : l2]);
            };
          } });
        }(), r;
      }();
    });
  })(vueJsonPretty$1);
  return vueJsonPretty$1.exports;
}
var vueJsonPrettyExports = requireVueJsonPretty();
const VueJsonPretty = /* @__PURE__ */ getDefaultExportFromCjs(vueJsonPrettyExports);
const sanitizeOptions = {
  allowVulnerableTags: false,
  enforceHtmlBoundary: false,
  disallowedTagsMode: "discard",
  allowedTags: [...sanitizeHtmlExports.defaults.allowedTags, "style", "img", "title"],
  allowedAttributes: {
    ...sanitizeHtmlExports.defaults.allowedAttributes,
    "*": ["class", "style"]
  },
  transformTags: {
    head: ""
  }
};
const _sfc_main$o = {
  name: "RunDataHtml",
  props: {
    inputHtml: {
      type: String,
      required: true
    }
  },
  computed: {
    sanitizedHtml() {
      return sanitizeHtml(this.inputHtml, sanitizeOptions);
    }
  }
};
const _hoisted_1$c = ["srcdoc"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("iframe", {
    class: "__html-display",
    srcdoc: $options.sanitizedHtml
  }, null, 8, _hoisted_1$c);
}
const RunDataHtml = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$2]]);
const RunDataHtml$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: RunDataHtml
}, Symbol.toStringTag, { value: "Module" }));
const _hoisted_1$b = { key: 0 };
const _hoisted_2$8 = { key: 1 };
const _hoisted_3$5 = { key: 2 };
const _hoisted_4$4 = {
  key: 0,
  controls: "",
  autoplay: ""
};
const _hoisted_5$4 = ["src", "type"];
const _hoisted_6$4 = {
  key: 1,
  controls: "",
  autoplay: ""
};
const _hoisted_7$3 = ["src", "type"];
const _hoisted_8$3 = ["src"];
const _hoisted_9$2 = ["src"];
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "BinaryDataDisplayEmbed",
  props: {
    binaryData: {}
  },
  setup(__props) {
    const props = __props;
    const isLoading = ref(true);
    const embedSource = ref("");
    const error = ref(false);
    const data = ref("");
    const workflowsStore = useWorkflowsStore();
    const i18n = useI18n();
    const embedClass = computed(() => {
      return [props.binaryData.fileType ?? "other"];
    });
    onMounted(async () => {
      const { id, data: binaryData, fileName, fileType, mimeType } = props.binaryData;
      const isJSONData = fileType === "json";
      const isHTMLData = fileType === "html";
      if (!id) {
        if (isJSONData || isHTMLData) {
          data.value = jsonParse(atob(binaryData));
        } else {
          embedSource.value = "data:" + mimeType + ";base64," + binaryData;
        }
      } else {
        try {
          const binaryUrl = workflowsStore.getBinaryUrl(id, "view", fileName ?? "", mimeType);
          if (isJSONData || isHTMLData) {
            const fetchedData = await fetch(binaryUrl, { credentials: "include" });
            data.value = await (isJSONData ? fetchedData.json() : fetchedData.text());
          } else {
            embedSource.value = binaryUrl;
          }
        } catch (e) {
          error.value = true;
        }
      }
      isLoading.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", null, [
        isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_1$b, "Loading binary data...")) : error.value ? (openBlock(), createElementBlock("div", _hoisted_2$8, "Error loading binary data")) : (openBlock(), createElementBlock("span", _hoisted_3$5, [
          _ctx.binaryData.fileType === "video" ? (openBlock(), createElementBlock("video", _hoisted_4$4, [
            createBaseVNode("source", {
              src: embedSource.value,
              type: _ctx.binaryData.mimeType
            }, null, 8, _hoisted_5$4),
            createTextVNode(" " + toDisplayString(unref(i18n).baseText("binaryDataDisplay.yourBrowserDoesNotSupport")), 1)
          ])) : _ctx.binaryData.fileType === "audio" ? (openBlock(), createElementBlock("audio", _hoisted_6$4, [
            createBaseVNode("source", {
              src: embedSource.value,
              type: _ctx.binaryData.mimeType
            }, null, 8, _hoisted_7$3),
            createTextVNode(" " + toDisplayString(unref(i18n).baseText("binaryDataDisplay.yourBrowserDoesNotSupport")), 1)
          ])) : _ctx.binaryData.fileType === "image" ? (openBlock(), createElementBlock("img", {
            key: 2,
            src: embedSource.value
          }, null, 8, _hoisted_8$3)) : _ctx.binaryData.fileType === "json" ? (openBlock(), createBlock(unref(VueJsonPretty), {
            key: 3,
            data: data.value,
            deep: 3,
            "show-length": true
          }, null, 8, ["data"])) : _ctx.binaryData.fileType === "html" ? (openBlock(), createBlock(RunDataHtml, {
            key: 4,
            "input-html": data.value
          }, null, 8, ["input-html"])) : (openBlock(), createElementBlock("embed", {
            key: 5,
            src: embedSource.value,
            class: normalizeClass(["binary-data", embedClass.value])
          }, null, 10, _hoisted_9$2))
        ]))
      ]);
    };
  }
});
const _hoisted_1$a = { class: "binary-data-window-wrapper" };
const _hoisted_2$7 = { key: 0 };
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "BinaryDataDisplay",
  props: {
    displayData: {},
    windowVisible: { type: Boolean }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const nodeHelpers = useNodeHelpers();
    const workflowsStore = useWorkflowsStore();
    const i18n = useI18n();
    const workflowRunData = computed(() => {
      const workflowExecution = workflowsStore.getWorkflowExecution;
      if (workflowExecution === null) {
        return null;
      }
      const executionData = workflowExecution.data;
      return executionData ? executionData.resultData.runData : null;
    });
    const binaryData = computed(() => {
      if (typeof props.displayData.node !== "string" || typeof props.displayData.key !== "string" || typeof props.displayData.runIndex !== "number" || typeof props.displayData.index !== "number" || typeof props.displayData.outputIndex !== "number") {
        return null;
      }
      const binaryDataLocal = nodeHelpers.getBinaryData(
        workflowRunData.value,
        props.displayData.node,
        props.displayData.runIndex,
        props.displayData.outputIndex
      );
      if (binaryDataLocal.length === 0) {
        return null;
      }
      if (props.displayData.index >= binaryDataLocal.length || binaryDataLocal[props.displayData.index][props.displayData.key] === void 0) {
        return null;
      }
      const binaryDataItem = binaryDataLocal[props.displayData.index][props.displayData.key];
      return binaryDataItem;
    });
    function closeWindow() {
      emit("close");
      return false;
    }
    return (_ctx, _cache) => {
      const _component_n8n_button = resolveComponent("n8n-button");
      return _ctx.windowVisible ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["binary-data-window", binaryData.value?.fileType])
      }, [
        createVNode(_component_n8n_button, {
          size: "small",
          class: "binary-data-window-back",
          title: unref(i18n).baseText("binaryDataDisplay.backToOverviewPage"),
          icon: "arrow-left",
          label: unref(i18n).baseText("binaryDataDisplay.backToList"),
          onClick: withModifiers(closeWindow, ["stop"])
        }, null, 8, ["title", "label"]),
        createBaseVNode("div", _hoisted_1$a, [
          !binaryData.value ? (openBlock(), createElementBlock("div", _hoisted_2$7, toDisplayString(unref(i18n).baseText("binaryDataDisplay.noDataFoundToDisplay")), 1)) : (openBlock(), createBlock(_sfc_main$n, {
            key: 1,
            "binary-data": binaryData.value
          }, null, 8, ["binary-data"]))
        ])
      ], 2)) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$9 = { key: 0 };
const _hoisted_2$6 = { key: 1 };
const _hoisted_3$4 = { key: 2 };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "RunDataPinButton",
  props: {
    tooltipContentsVisibility: {},
    dataPinningDocsUrl: {},
    pinnedData: {},
    disabled: { type: Boolean }
  },
  emits: ["togglePinData"],
  setup(__props, { emit: __emit }) {
    const locale = useI18n();
    const props = __props;
    const emit = __emit;
    const visible2 = computed(
      () => props.tooltipContentsVisibility.pinDataDiscoveryTooltipContent ? true : void 0
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(N8nTooltip), {
        placement: "bottom-end",
        visible: visible2.value
      }, {
        content: withCtx(() => [
          props.tooltipContentsVisibility.binaryDataTooltipContent ? (openBlock(), createElementBlock("div", _hoisted_1$9, toDisplayString(unref(locale).baseText("ndv.pinData.pin.binary")), 1)) : props.tooltipContentsVisibility.pinDataDiscoveryTooltipContent ? (openBlock(), createElementBlock("div", _hoisted_2$6, toDisplayString(unref(locale).baseText("node.discovery.pinData.ndv")), 1)) : (openBlock(), createElementBlock("div", _hoisted_3$4, [
            createBaseVNode("strong", null, toDisplayString(unref(locale).baseText("ndv.pinData.pin.title")), 1),
            createVNode(unref(N8nText), {
              size: "small",
              tag: "p"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(locale).baseText("ndv.pinData.pin.description")) + " ", 1),
                createVNode(unref(N8nLink), {
                  to: props.dataPinningDocsUrl,
                  size: "small"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(locale).baseText("ndv.pinData.pin.link")), 1)
                  ]),
                  _: 1
                }, 8, ["to"])
              ]),
              _: 1
            })
          ]))
        ]),
        default: withCtx(() => [
          createVNode(unref(_sfc_main$B), {
            class: normalizeClass(_ctx.$style.pinDataButton),
            type: "tertiary",
            active: props.pinnedData.hasData.value,
            icon: "thumbtack",
            disabled: props.disabled,
            "data-test-id": "ndv-pin-data",
            onClick: _cache[0] || (_cache[0] = ($event) => emit("togglePinData"))
          }, null, 8, ["class", "active", "disabled"])
        ]),
        _: 1
      }, 8, ["visible"]);
    };
  }
});
const pinDataButton = "_pinDataButton_12tk2_123";
const style0$9 = {
  pinDataButton
};
const cssModules$b = {
  "$style": style0$9
};
const RunDataPinButton = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__cssModules", cssModules$b]]);
const _hoisted_1$8 = {
  key: 0,
  class: "ml-4xs"
};
const _hoisted_2$5 = ["href"];
const _hoisted_3$3 = { key: 0 };
const _hoisted_4$3 = ["href"];
const _hoisted_5$3 = { key: 1 };
const _hoisted_6$3 = { key: 0 };
const _hoisted_7$2 = ["data-test-id"];
const _hoisted_8$2 = { key: 0 };
const _hoisted_9$1 = { key: 1 };
const _hoisted_10$1 = { key: 2 };
const _hoisted_11$1 = { key: 3 };
const _hoisted_12$1 = { key: 4 };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "RunData",
  props: {
    workflow: {},
    runIndex: {},
    tooMuchDataTitle: {},
    executingMessage: {},
    pushRef: {},
    paneType: {},
    noDataInBranchMessage: {},
    node: { default: null },
    nodes: { default: () => [] },
    linkedRuns: { type: Boolean },
    canLinkRuns: { type: Boolean },
    isExecuting: { type: Boolean, default: false },
    overrideOutputs: { default: void 0 },
    mappingEnabled: { type: Boolean, default: false },
    distanceFromActive: { default: 0 },
    blockUI: { type: Boolean, default: false },
    isProductionExecutionPreview: { type: Boolean, default: false },
    isPaneActive: { type: Boolean, default: false },
    hidePagination: { type: Boolean, default: false },
    calloutMessage: { default: void 0 }
  },
  emits: ["search", "runChange", "itemHover", "linkRun", "unlinkRun", "activatePane", "tableMounted"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const LazyRunDataTable = defineAsyncComponent(
      async () => await __vitePreload(() => import("./RunDataTable-DGMN5nF6.js"), true ? __vite__mapDeps([0,1,2,3,4]) : void 0)
    );
    const LazyRunDataJson = defineAsyncComponent(
      async () => await __vitePreload(() => import("./RunDataJson-wyo45w7C.js"), true ? __vite__mapDeps([5,1,2,6,7,8,9,3,10,11,12,13,14,15,16,17]) : void 0)
    );
    const LazyRunDataSchema = defineAsyncComponent(
      async () => await __vitePreload(() => import("./index-DablXALM.js").then((n) => n.iK), true ? __vite__mapDeps([1,2]) : void 0)
    );
    const LazyRunDataHtml = defineAsyncComponent(
      async () => await __vitePreload(() => Promise.resolve().then(() => RunDataHtml$1), true ? void 0 : void 0)
    );
    const LazyRunDataSearch = defineAsyncComponent(
      async () => await __vitePreload(() => import("./RunDataSearch-B3EyVssL.js"), true ? __vite__mapDeps([18,1,2,19]) : void 0)
    );
    const props = __props;
    const emit = __emit;
    const connectionType2 = ref(NodeConnectionType.Main);
    const dataSize = ref(0);
    const showData = ref(false);
    const userEnabledShowData = ref(false);
    const outputIndex = ref(0);
    const binaryDataDisplayVisible = ref(false);
    const binaryDataDisplayData = ref(null);
    const currentPage = ref(1);
    const pageSize = ref(10);
    const pageSizes = [1, 10, 25, 50, 100];
    const pinDataDiscoveryTooltipVisible = ref(false);
    const isControlledPinDataTooltip = ref(false);
    const search2 = ref("");
    const dataContainerRef = ref();
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const workflowsStore = useWorkflowsStore();
    const sourceControlStore = useSourceControlStore();
    const rootStore = useRootStore();
    const uiStore = useUIStore();
    const toast = useToast();
    const route = useRoute();
    const nodeHelpers = useNodeHelpers();
    const externalHooks = useExternalHooks();
    const telemetry = useTelemetry();
    const i18n = useI18n();
    const { trackOpeningRelatedExecution, resolveRelatedExecutionUrl } = useExecutionHelpers();
    const node2 = toRef$1(props, "node");
    const pinnedData = usePinnedData(node2, {
      runIndex: props.runIndex,
      displayMode: props.paneType === "input" ? ndvStore.inputPanelDisplayMode : ndvStore.outputPanelDisplayMode
    });
    const { isSubNodeType: isSubNodeType2 } = useNodeType({
      node: node2
    });
    const displayMode = computed(
      () => props.paneType === "input" ? ndvStore.inputPanelDisplayMode : ndvStore.outputPanelDisplayMode
    );
    const isReadOnlyRoute = computed(() => route.meta.readOnlyCanvas === true);
    const isWaitNodeWaiting = computed(() => {
      return node2.value?.name && workflowExecution.value?.data?.resultData?.runData?.[node2.value?.name]?.[props.runIndex]?.executionStatus === "waiting";
    });
    const { activeNode } = storeToRefs(ndvStore);
    const nodeType = computed(() => {
      if (!node2.value) return null;
      return nodeTypesStore.getNodeType(node2.value.type, node2.value.typeVersion);
    });
    const isSchemaView = computed(() => displayMode.value === "schema");
    const isSearchInSchemaView = computed(() => isSchemaView.value && !!search2.value);
    const displaysMultipleNodes = computed(
      () => isSchemaView.value && props.paneType === "input" && props.nodes.length > 0
    );
    const isTriggerNode = computed(() => !!node2.value && nodeTypesStore.isTriggerNode(node2.value.type));
    const canPinData = computed(
      () => !!node2.value && pinnedData.canPinNode(false, currentOutputIndex.value) && !isPaneTypeInput.value && pinnedData.isValidNodeType.value && !(binaryData.value && binaryData.value.length > 0)
    );
    const displayModes2 = computed(() => {
      const defaults = [
        { label: i18n.baseText("runData.table"), value: "table" },
        { label: i18n.baseText("runData.json"), value: "json" }
      ];
      if (binaryData.value.length) {
        defaults.push({ label: i18n.baseText("runData.binary"), value: "binary" });
      }
      const schemaView = { label: i18n.baseText("runData.schema"), value: "schema" };
      if (isPaneTypeInput.value) {
        defaults.unshift(schemaView);
      } else {
        defaults.push(schemaView);
      }
      if (isPaneTypeOutput.value && activeNode.value?.type === HTML_NODE_TYPE && activeNode.value.parameters.operation === "generateHtmlTemplate") {
        defaults.unshift({ label: "HTML", value: "html" });
      }
      return defaults;
    });
    const hasNodeRun = computed(
      () => Boolean(
        !props.isExecuting && node2.value && (workflowRunData.value && workflowRunData.value.hasOwnProperty(node2.value.name) || pinnedData.hasData.value)
      )
    );
    const isArtificialRecoveredEventItem = computed(
      () => rawInputData.value?.[0]?.json?.isArtificialRecoveredEventItem
    );
    const isTrimmedManualExecutionDataItem = computed(
      () => rawInputData.value?.[0]?.json?.[TRIMMED_TASK_DATA_CONNECTIONS_KEY]
    );
    const subworkflowExecutionError = computed(() => {
      if (!node2.value) return null;
      return {
        node: node2.value,
        messages: [workflowsStore.subWorkflowExecutionError?.message ?? ""]
      };
    });
    const hasSubworkflowExecutionError = computed(
      () => Boolean(workflowsStore.subWorkflowExecutionError)
    );
    const workflowRunErrorAsNodeError = computed(() => {
      if (!node2.value) {
        return null;
      }
      if (isSubNodeType2.value && props.paneType === "input") {
        const parentNode = props.workflow.getChildNodes(node2.value?.name ?? "", "ALL_NON_MAIN")[0];
        return workflowRunData.value?.[parentNode]?.[props.runIndex]?.error;
      }
      return workflowRunData.value?.[node2.value?.name]?.[props.runIndex]?.error;
    });
    const hasRunError = computed(() => Boolean(node2.value && workflowRunErrorAsNodeError.value));
    const executionHints = computed(() => {
      if (hasNodeRun.value) {
        const hints = node2.value && workflowRunData.value?.[node2.value.name]?.[props.runIndex]?.hints;
        if (hints) return hints;
      }
      return [];
    });
    const workflowExecution = computed(() => workflowsStore.getWorkflowExecution);
    const workflowRunData = computed(() => {
      if (workflowExecution.value === null) {
        return null;
      }
      const executionData = workflowExecution.value.data;
      if (executionData?.resultData) {
        return executionData.resultData.runData;
      }
      return null;
    });
    const dataCount = computed(
      () => getDataCount(props.runIndex, currentOutputIndex.value, connectionType2.value)
    );
    const unfilteredDataCount = computed(
      () => pinnedData.data.value ? pinnedData.data.value.length : rawInputData.value.length
    );
    const dataSizeInMB = computed(() => (dataSize.value / (1024 * 1024)).toFixed(1));
    const maxOutputIndex = computed(() => {
      if (node2.value === null || props.runIndex === void 0) {
        return 0;
      }
      const runData = workflowRunData.value;
      if (runData === null || !runData.hasOwnProperty(node2.value.name)) {
        return 0;
      }
      if (runData[node2.value.name].length < props.runIndex) {
        return 0;
      }
      if (runData[node2.value.name][props.runIndex]) {
        const taskData = runData[node2.value.name][props.runIndex].data;
        if (taskData?.main) {
          return taskData.main.length - 1;
        }
      }
      return 0;
    });
    const currentPageOffset = computed(() => pageSize.value * (currentPage.value - 1));
    const maxRunIndex = computed(() => {
      if (!node2.value) {
        return 0;
      }
      const runData = workflowRunData.value;
      if (runData === null || !runData.hasOwnProperty(node2.value.name)) {
        return 0;
      }
      if (runData[node2.value.name].length) {
        return runData[node2.value.name].length - 1;
      }
      return 0;
    });
    const rawInputData = computed(
      () => getRawInputData(props.runIndex, currentOutputIndex.value, connectionType2.value)
    );
    const unfilteredInputData = computed(() => getPinDataOrLiveData(rawInputData.value));
    const inputData = computed(() => getFilteredData(unfilteredInputData.value));
    const inputDataPage = computed(() => {
      const offset = pageSize.value * (currentPage.value - 1);
      return inputData.value.slice(offset, offset + pageSize.value);
    });
    const jsonData = computed(() => executionDataToJson(inputData.value));
    const binaryData = computed(() => {
      if (!node2.value) {
        return [];
      }
      return nodeHelpers.getBinaryData(workflowRunData.value, node2.value.name, props.runIndex, currentOutputIndex.value).filter((data) => Boolean(data && Object.keys(data).length));
    });
    const inputHtml = computed(() => String(inputData.value[0]?.json?.html ?? ""));
    const currentOutputIndex = computed(() => {
      if (props.overrideOutputs?.length && !props.overrideOutputs.includes(outputIndex.value)) {
        return props.overrideOutputs[0];
      }
      return Math.min(outputIndex.value, maxOutputIndex.value);
    });
    const branches = computed(() => {
      const capitalize = (name) => name.charAt(0).toLocaleUpperCase() + name.slice(1);
      const result = [];
      for (let i = 0; i <= maxOutputIndex.value; i++) {
        if (props.overrideOutputs && !props.overrideOutputs.includes(i)) {
          continue;
        }
        const totalItemsCount = getRawInputData(props.runIndex, i).length;
        const itemsCount2 = getDataCount(props.runIndex, i);
        const items = search2.value ? i18n.baseText("ndv.search.items", {
          adjustToNumber: totalItemsCount,
          interpolate: { matched: itemsCount2, total: totalItemsCount }
        }) : i18n.baseText("ndv.output.items", {
          adjustToNumber: itemsCount2,
          interpolate: { count: itemsCount2 }
        });
        let outputName = getOutputName(i);
        if (`${outputName}` === `${i}`) {
          outputName = `${i18n.baseText("ndv.output")} ${outputName}`;
        } else {
          const appendBranchWord = NODE_TYPES_EXCLUDED_FROM_OUTPUT_NAME_APPEND.includes(
            node2.value?.type ?? ""
          ) ? "" : ` ${i18n.baseText("ndv.output.branch")}`;
          outputName = capitalize(`${getOutputName(i)}${appendBranchWord}`);
        }
        result.push({
          label: search2.value && itemsCount2 || totalItemsCount ? `${outputName} (${items})` : outputName,
          value: i
        });
      }
      return result;
    });
    const editMode2 = computed(() => {
      return isPaneTypeInput.value ? { enabled: false, value: "" } : ndvStore.outputPanelEditMode;
    });
    const isPaneTypeInput = computed(() => props.paneType === "input");
    const isPaneTypeOutput = computed(() => props.paneType === "output");
    const readOnlyEnv = computed(() => sourceControlStore.preferences.branchReadOnly);
    const showIOSearch = computed(
      () => hasNodeRun.value && !hasRunError.value && unfilteredInputData.value.length > 0
    );
    const inputSelectLocation = computed(() => {
      if (isSchemaView.value) return "none";
      if (!hasNodeRun.value) return "header";
      if (maxRunIndex.value > 0) return "runs";
      if (maxOutputIndex.value > 0 && branches.value.length > 1) {
        return "outputs";
      }
      return "items";
    });
    const showIoSearchNoMatchContent = computed(
      () => hasNodeRun.value && !inputData.value.length && !!search2.value
    );
    const parentNodeOutputData = computed(() => {
      const parentNode = props.workflow.getParentNodesByDepth(node2.value?.name ?? "")[0];
      let parentNodeData = [];
      if (parentNode?.name) {
        parentNodeData = nodeHelpers.getNodeInputData(
          props.workflow.getNode(parentNode?.name),
          props.runIndex,
          outputIndex.value,
          "input",
          connectionType2.value
        );
      }
      return parentNodeData;
    });
    const parentNodePinnedData = computed(() => {
      const parentNode = props.workflow.getParentNodesByDepth(node2.value?.name ?? "")[0];
      return props.workflow.pinData?.[parentNode?.name || ""] ?? [];
    });
    const showPinButton = computed(() => {
      if (!rawInputData.value.length && !pinnedData.hasData.value) {
        return false;
      }
      if (editMode2.value.enabled) {
        return false;
      }
      if (binaryData.value?.length) {
        return isPaneTypeOutput.value;
      }
      return canPinData.value;
    });
    const pinButtonDisabled = computed(
      () => pinnedData.hasData.value || !rawInputData.value.length || !!binaryData.value?.length || isReadOnlyRoute.value || readOnlyEnv.value
    );
    const activeTaskMetadata = computed(() => {
      if (!node2.value) {
        return null;
      }
      return workflowRunData.value?.[node2.value.name]?.[props.runIndex]?.metadata ?? null;
    });
    const hasReleatedExectuion = computed(() => {
      return Boolean(
        activeTaskMetadata.value?.subExecution || activeTaskMetadata.value?.parentExecution
      );
    });
    const hasInputOverwrite = computed(() => {
      if (!node2.value) {
        return false;
      }
      const taskData = nodeHelpers.getNodeTaskData(node2.value, props.runIndex);
      return Boolean(taskData?.inputOverride);
    });
    watch(node2, (newNode, prevNode) => {
      if (newNode?.id === prevNode?.id) return;
      init();
    });
    watch(hasNodeRun, () => {
      if (props.paneType === "output") setDisplayMode();
      else {
        outputIndex.value = determineInitialOutputIndex();
      }
    });
    watch(
      inputDataPage,
      (data) => {
        if (props.paneType && data) {
          ndvStore.setNDVPanelDataIsEmpty({
            panel: props.paneType,
            isEmpty: data.every((item) => isEmpty(item.json))
          });
        }
      },
      { immediate: true, deep: true }
    );
    watch(jsonData, (data, prevData) => {
      if (isEqual(data, prevData)) return;
      refreshDataSize();
      if (dataCount.value) {
        resetCurrentPageIfTooFar();
      }
      showPinDataDiscoveryTooltip(data);
    });
    watch(binaryData, (newData, prevData) => {
      if (newData.length && !prevData.length && displayMode.value !== "binary") {
        switchToBinary();
      } else if (!newData.length && displayMode.value === "binary") {
        onDisplayModeChange("table");
      }
    });
    watch(currentOutputIndex, (branchIndex) => {
      ndvStore.setNDVBranchIndex({
        pane: props.paneType,
        branchIndex
      });
    });
    watch(search2, (newSearch) => {
      emit("search", newSearch);
    });
    onMounted(() => {
      init();
      if (!isPaneTypeInput.value) {
        showPinDataDiscoveryTooltip(jsonData.value);
      }
      ndvStore.setNDVBranchIndex({
        pane: props.paneType,
        branchIndex: currentOutputIndex.value
      });
      if (props.paneType === "output") {
        setDisplayMode();
        activatePane();
      }
      if (hasRunError.value && node2.value) {
        const error = workflowRunData.value?.[node2.value.name]?.[props.runIndex]?.error;
        const errorsToTrack = ["unknown error"];
        if (error && errorsToTrack.some((e) => error.message?.toLowerCase().includes(e))) {
          telemetry.track(
            "User encountered an error",
            {
              node: node2.value.type,
              errorMessage: error.message,
              nodeVersion: node2.value.typeVersion,
              n8nVersion: rootStore.versionCli
            },
            {
              withPostHog: true
            }
          );
        }
      }
    });
    onBeforeUnmount(() => {
      hidePinDataDiscoveryTooltip();
    });
    function getResolvedNodeOutputs() {
      if (node2.value && nodeType.value) {
        const workflowNode = props.workflow.getNode(node2.value.name);
        if (workflowNode) {
          const outputs2 = getNodeOutputs(props.workflow, workflowNode, nodeType.value);
          return outputs2;
        }
      }
      return [];
    }
    function shouldHintBeDisplayed(hint) {
      const { location, whenToDisplay } = hint;
      if (location) {
        if (location === "ndv" && !["input", "output"].includes(props.paneType)) {
          return false;
        }
        if (location === "inputPane" && props.paneType !== "input") {
          return false;
        }
        if (location === "outputPane" && props.paneType !== "output") {
          return false;
        }
      }
      if (whenToDisplay === "afterExecution" && !hasNodeRun.value) {
        return false;
      }
      if (whenToDisplay === "beforeExecution" && hasNodeRun.value) {
        return false;
      }
      return true;
    }
    function getNodeHints$1() {
      try {
        if (node2.value && nodeType.value) {
          const workflowNode = props.workflow.getNode(node2.value.name);
          if (workflowNode) {
            const nodeHints = getNodeHints(props.workflow, workflowNode, nodeType.value, {
              runExecutionData: workflowExecution.value?.data ?? null,
              runIndex: props.runIndex,
              connectionInputData: parentNodeOutputData.value
            });
            const hasMultipleInputItems = parentNodeOutputData.value.length > 1 || parentNodePinnedData.value.length > 1;
            const nodeOutputData = workflowRunData.value?.[node2.value.name]?.[props.runIndex]?.data?.main?.[0] ?? [];
            const genericHints = getGenericHints({
              workflowNode,
              node: node2.value,
              nodeType: nodeType.value,
              nodeOutputData,
              workflow: props.workflow,
              hasNodeRun: hasNodeRun.value,
              hasMultipleInputItems
            });
            return executionHints.value.concat(nodeHints, genericHints).filter(shouldHintBeDisplayed);
          }
        }
      } catch (error) {
        console.error("Error while getting node hints", error);
      }
      return [];
    }
    function onItemHover(itemIndex) {
      if (itemIndex === null) {
        emit("itemHover", null);
        return;
      }
      emit("itemHover", {
        outputIndex: currentOutputIndex.value,
        itemIndex
      });
    }
    function onClickDataPinningDocsLink() {
      telemetry.track("User clicked ndv link", {
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        node_type: activeNode.value?.type,
        pane: "output",
        type: "data-pinning-docs"
      });
    }
    function showPinDataDiscoveryTooltip(value) {
      if (!isTriggerNode.value) {
        return;
      }
      const pinDataDiscoveryFlag = useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG).value;
      if (value && value.length > 0 && !isReadOnlyRoute.value && !pinDataDiscoveryFlag) {
        pinDataDiscoveryComplete();
        setTimeout(() => {
          isControlledPinDataTooltip.value = true;
          pinDataDiscoveryTooltipVisible.value = true;
          dataPinningEventBus.emit("data-pinning-discovery", { isTooltipVisible: true });
        }, 500);
      }
    }
    function hidePinDataDiscoveryTooltip() {
      if (pinDataDiscoveryTooltipVisible.value) {
        isControlledPinDataTooltip.value = false;
        pinDataDiscoveryTooltipVisible.value = false;
        dataPinningEventBus.emit("data-pinning-discovery", { isTooltipVisible: false });
      }
    }
    function pinDataDiscoveryComplete() {
      useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG).value = "true";
      useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG).value = "true";
    }
    function enterEditMode({ origin }) {
      const inputData2 = pinnedData.data.value ? clearJsonKey(pinnedData.data.value) : executionDataToJson(rawInputData.value);
      const inputDataLength = Array.isArray(inputData2) ? inputData2.length : Object.keys(inputData2 ?? {}).length;
      const data = inputDataLength > 0 ? inputData2 : TEST_PIN_DATA;
      ndvStore.setOutputPanelEditModeEnabled(true);
      ndvStore.setOutputPanelEditModeValue(JSON.stringify(data, null, 2));
      telemetry.track("User opened ndv edit state", {
        node_type: activeNode.value?.type,
        click_type: origin === "editIconButton" ? "button" : "link",
        push_ref: props.pushRef,
        run_index: props.runIndex,
        is_output_present: hasNodeRun.value || pinnedData.hasData.value,
        view: !hasNodeRun.value && !pinnedData.hasData.value ? "undefined" : displayMode.value,
        is_data_pinned: pinnedData.hasData.value
      });
    }
    function onClickCancelEdit() {
      ndvStore.setOutputPanelEditModeEnabled(false);
      ndvStore.setOutputPanelEditModeValue("");
      onExitEditMode({ type: "cancel" });
    }
    function onClickSaveEdit() {
      if (!node2.value) {
        return;
      }
      const { value } = editMode2.value;
      toast.clearAllStickyNotifications();
      try {
        const clearedValue = clearJsonKey(value);
        try {
          pinnedData.setData(clearedValue, "save-edit");
        } catch (error) {
          return;
        }
      } catch (error) {
        toast.showError(error, i18n.baseText("ndv.pinData.error.syntaxError.title"));
        return;
      }
      ndvStore.setOutputPanelEditModeEnabled(false);
      onExitEditMode({ type: "save" });
    }
    function onExitEditMode({ type }) {
      telemetry.track("User closed ndv edit state", {
        node_type: activeNode.value?.type,
        push_ref: props.pushRef,
        run_index: props.runIndex,
        view: displayMode.value,
        type
      });
    }
    async function onTogglePinData({ source }) {
      if (!node2.value) {
        return;
      }
      if (source === "pin-icon-click") {
        const telemetryPayload = {
          node_type: activeNode.value?.type,
          push_ref: props.pushRef,
          run_index: props.runIndex,
          view: !hasNodeRun.value && !pinnedData.hasData.value ? "none" : displayMode.value
        };
        void externalHooks.run("runData.onTogglePinData", telemetryPayload);
        telemetry.track("User clicked pin data icon", telemetryPayload);
      }
      nodeHelpers.updateNodeParameterIssues(node2.value);
      if (pinnedData.hasData.value) {
        pinnedData.unsetData(source);
        return;
      }
      try {
        pinnedData.setData(rawInputData.value, "pin-icon-click");
      } catch (error) {
        console.error(error);
        return;
      }
      if (maxRunIndex.value > 0) {
        toast.showToast({
          title: i18n.baseText("ndv.pinData.pin.multipleRuns.title", {
            interpolate: {
              index: `${props.runIndex}`
            }
          }),
          message: i18n.baseText("ndv.pinData.pin.multipleRuns.description"),
          type: "success",
          duration: 2e3
        });
      }
      hidePinDataDiscoveryTooltip();
      pinDataDiscoveryComplete();
    }
    function switchToBinary() {
      onDisplayModeChange("binary");
    }
    function onBranchChange(value) {
      outputIndex.value = value;
      telemetry.track("User changed ndv branch", {
        push_ref: props.pushRef,
        branch_index: value,
        node_type: activeNode.value?.type,
        node_type_input_selection: nodeType.value ? nodeType.value.name : "",
        pane: props.paneType
      });
    }
    function showTooMuchData() {
      showData.value = true;
      userEnabledShowData.value = true;
      telemetry.track("User clicked ndv button", {
        node_type: activeNode.value?.type,
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        pane: props.paneType,
        type: "showTooMuchData"
      });
    }
    function toggleLinkRuns() {
      if (props.linkedRuns) {
        unlinkRun();
      } else {
        linkRun();
      }
    }
    function linkRun() {
      emit("linkRun");
    }
    function unlinkRun() {
      emit("unlinkRun");
    }
    function onCurrentPageChange(value) {
      currentPage.value = value;
      telemetry.track("User changed ndv page", {
        node_type: activeNode.value?.type,
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        pane: props.paneType,
        page_selected: currentPage.value,
        page_size: pageSize.value,
        items_total: dataCount.value
      });
    }
    function resetCurrentPageIfTooFar() {
      const maxPage = Math.ceil(dataCount.value / pageSize.value);
      if (maxPage < currentPage.value) {
        currentPage.value = maxPage;
      }
    }
    function onPageSizeChange(newPageSize) {
      pageSize.value = newPageSize;
      resetCurrentPageIfTooFar();
      telemetry.track("User changed ndv page size", {
        node_type: activeNode.value?.type,
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        pane: props.paneType,
        page_selected: currentPage.value,
        page_size: pageSize.value,
        items_total: dataCount.value
      });
    }
    function onDisplayModeChange(newDisplayMode) {
      const previous = displayMode.value;
      ndvStore.setPanelDisplayMode({ pane: props.paneType, mode: newDisplayMode });
      if (!userEnabledShowData.value) updateShowData();
      if (dataContainerRef.value) {
        const dataDisplay2 = dataContainerRef.value.children[0];
        if (dataDisplay2) {
          dataDisplay2.scrollTo(0, 0);
        }
      }
      closeBinaryDataDisplay();
      void externalHooks.run("runData.displayModeChanged", {
        newValue: newDisplayMode,
        oldValue: previous
      });
      if (activeNode.value) {
        telemetry.track("User changed ndv item view", {
          previous_view: previous,
          new_view: newDisplayMode,
          node_type: activeNode.value.type,
          workflow_id: workflowsStore.workflowId,
          push_ref: props.pushRef,
          pane: props.paneType
        });
      }
    }
    function getRunLabel(option) {
      if (!node2.value) {
        return;
      }
      let itemsCount2 = 0;
      for (let i = 0; i <= maxOutputIndex.value; i++) {
        itemsCount2 += getPinDataOrLiveData(getRawInputData(option - 1, i)).length;
      }
      const items = i18n.baseText("ndv.output.items", {
        adjustToNumber: itemsCount2,
        interpolate: { count: itemsCount2 }
      });
      const metadata = workflowRunData.value?.[node2.value.name]?.[option - 1]?.metadata ?? null;
      const subexecutions = metadata?.subExecutionsCount ? i18n.baseText("ndv.output.andSubExecutions", {
        adjustToNumber: metadata.subExecutionsCount,
        interpolate: {
          count: metadata.subExecutionsCount
        }
      }) : "";
      const itemsLabel = itemsCount2 > 0 ? ` (${items}${subexecutions})` : "";
      return option + i18n.baseText("ndv.output.of") + (maxRunIndex.value + 1) + itemsLabel;
    }
    function getRawInputData(runIndex, outputIndex2, connectionType22 = NodeConnectionType.Main) {
      let inputData2 = [];
      if (node2.value) {
        inputData2 = nodeHelpers.getNodeInputData(
          node2.value,
          runIndex,
          outputIndex2,
          props.paneType,
          connectionType22
        );
      }
      if (inputData2.length === 0 || !Array.isArray(inputData2)) {
        return [];
      }
      return inputData2;
    }
    function getPinDataOrLiveData(data) {
      if (pinnedData.data.value && !props.isProductionExecutionPreview) {
        return Array.isArray(pinnedData.data.value) ? pinnedData.data.value.map((value) => ({
          json: value
        })) : [
          {
            json: pinnedData.data.value
          }
        ];
      }
      return data;
    }
    function getFilteredData(data) {
      if (!search2.value || isSchemaView.value) {
        return data;
      }
      currentPage.value = 1;
      return data.filter(({ json }) => searchInObject(json, search2.value));
    }
    function getDataCount(runIndex, outputIndex2, connectionType22 = NodeConnectionType.Main) {
      if (!node2.value) {
        return 0;
      }
      if (workflowRunData.value?.[node2.value.name]?.[runIndex]?.hasOwnProperty("error")) {
        return 1;
      }
      const rawInputData2 = getRawInputData(runIndex, outputIndex2, connectionType22);
      const pinOrLiveData = getPinDataOrLiveData(rawInputData2);
      return getFilteredData(pinOrLiveData).length;
    }
    function determineInitialOutputIndex() {
      for (let i = 0; i <= maxOutputIndex.value; i++) {
        if (getRawInputData(props.runIndex, i).length) {
          return i;
        }
      }
      return 0;
    }
    function init() {
      outputIndex.value = determineInitialOutputIndex();
      refreshDataSize();
      closeBinaryDataDisplay();
      let outputTypes = [];
      if (node2.value && nodeType.value) {
        const outputs2 = getResolvedNodeOutputs();
        outputTypes = getConnectionTypes(outputs2);
      }
      connectionType2.value = outputTypes.length === 0 ? NodeConnectionType.Main : outputTypes[0];
      if (binaryData.value.length > 0) {
        ndvStore.setPanelDisplayMode({
          pane: props.paneType,
          mode: "binary"
        });
      } else if (displayMode.value === "binary") {
        ndvStore.setPanelDisplayMode({
          pane: props.paneType,
          mode: "table"
        });
      }
    }
    function closeBinaryDataDisplay() {
      binaryDataDisplayVisible.value = false;
      binaryDataDisplayData.value = null;
    }
    function isViewable(index, key) {
      const { fileType } = binaryData.value[index][key];
      return !!fileType && ["image", "audio", "video", "text", "json", "pdf", "html"].includes(fileType);
    }
    function isDownloadable(index, key) {
      const { mimeType, fileName } = binaryData.value[index][key];
      return !!(mimeType && fileName);
    }
    async function downloadBinaryData(index, key) {
      const { id, data, fileName, fileExtension, mimeType } = binaryData.value[index][key];
      if (id) {
        const url = workflowsStore.getBinaryUrl(id, "download", fileName ?? "", mimeType);
        FileSaver_minExports.saveAs(url, [fileName, fileExtension].join("."));
        return;
      } else {
        const bufferString = "data:" + mimeType + ";base64," + data;
        const blob = await fetch(bufferString).then(async (d) => await d.blob());
        FileSaver_minExports.saveAs(blob, fileName);
      }
    }
    async function downloadJsonData() {
      const fileName = (node2.value?.name ?? "").replace(/[^\w\d]/g, "_");
      const blob = new Blob([JSON.stringify(rawInputData.value, null, 2)], {
        type: "application/json"
      });
      FileSaver_minExports.saveAs(blob, `${fileName}.json`);
    }
    function displayBinaryData(index, key) {
      const { data, mimeType } = binaryData.value[index][key];
      binaryDataDisplayVisible.value = true;
      binaryDataDisplayData.value = {
        node: node2.value?.name,
        runIndex: props.runIndex,
        outputIndex: currentOutputIndex.value,
        index,
        key,
        data,
        mimeType
      };
    }
    function getOutputName(outputIndex2) {
      if (node2.value === null) {
        return outputIndex2 + 1;
      }
      const outputs2 = getResolvedNodeOutputs();
      const outputConfiguration = outputs2?.[outputIndex2];
      if (outputConfiguration && isObject$1(outputConfiguration)) {
        return outputConfiguration?.displayName;
      }
      if (!nodeType.value?.outputNames || nodeType.value.outputNames.length <= outputIndex2) {
        return outputIndex2 + 1;
      }
      return nodeType.value.outputNames[outputIndex2];
    }
    function refreshDataSize() {
      showData.value = false;
      const jsonItems = inputDataPage.value.map((item) => item.json);
      const byteSize = new Blob([JSON.stringify(jsonItems)]).size;
      dataSize.value = byteSize;
      updateShowData();
    }
    function updateShowData() {
      showData.value = isSchemaView.value && dataSize.value < MAX_DISPLAY_DATA_SIZE_SCHEMA_VIEW || dataSize.value < MAX_DISPLAY_DATA_SIZE;
    }
    function onRunIndexChange(run) {
      emit("runChange", run);
    }
    function enableNode() {
      if (node2.value) {
        const updateInformation = {
          name: node2.value.name,
          properties: {
            disabled: !node2.value.disabled
          }
        };
        workflowsStore.updateNodeProperties(updateInformation);
      }
    }
    function setDisplayMode() {
      if (!activeNode.value) return;
      const shouldDisplayHtml = activeNode.value.type === HTML_NODE_TYPE && activeNode.value.parameters.operation === "generateHtmlTemplate";
      if (shouldDisplayHtml) {
        ndvStore.setPanelDisplayMode({
          pane: "output",
          mode: "html"
        });
      }
    }
    function activatePane() {
      emit("activatePane");
    }
    function onSearchClear() {
      search2.value = "";
      document.dispatchEvent(new KeyboardEvent("keyup", { key: "/" }));
    }
    function getExecutionLinkLabel(task) {
      if (task.parentExecution) {
        return i18n.baseText("runData.openParentExecution", {
          interpolate: { id: task.parentExecution.executionId }
        });
      }
      if (task.subExecution) {
        if (activeTaskMetadata.value?.subExecutionsCount === 1) {
          return i18n.baseText("runData.openSubExecutionSingle");
        } else {
          return i18n.baseText("runData.openSubExecutionWithId", {
            interpolate: { id: task.subExecution.executionId }
          });
        }
      }
      return;
    }
    __expose({ enterEditMode });
    return (_ctx, _cache) => {
      const _component_N8nIcon = resolveComponent("N8nIcon");
      const _component_i18n_t = resolveComponent("i18n-t");
      const _component_el_pagination = resolveComponent("el-pagination");
      const _directive_n8n_html = resolveDirective("n8n-html");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["run-data", _ctx.$style.container]),
        onMouseover: activatePane
      }, [
        !isPaneTypeInput.value && unref(pinnedData).hasData.value && !editMode2.value.enabled && !_ctx.isProductionExecutionPreview ? (openBlock(), createBlock(unref(N8nCallout), {
          key: 0,
          theme: "secondary",
          icon: "thumbtack",
          class: normalizeClass(_ctx.$style.pinnedDataCallout),
          "data-test-id": "ndv-pinned-data-callout"
        }, {
          trailingContent: withCtx(() => [
            createVNode(unref(N8nLink), {
              to: unref(DATA_PINNING_DOCS_URL),
              size: "small",
              theme: "secondary",
              bold: "",
              underline: "",
              onClick: onClickDataPinningDocsLink
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("runData.pindata.learnMore")), 1)
              ]),
              _: 1
            }, 8, ["to"])
          ]),
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(i18n).baseText("runData.pindata.thisDataIsPinned")) + " ", 1),
            !isReadOnlyRoute.value && !readOnlyEnv.value ? (openBlock(), createElementBlock("span", _hoisted_1$8, [
              createVNode(unref(N8nLink), {
                theme: "secondary",
                size: "small",
                underline: "",
                bold: "",
                "data-test-id": "ndv-unpin-data",
                onClick: _cache[0] || (_cache[0] = withModifiers(($event) => onTogglePinData({ source: "banner-link" }), ["stop"]))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("runData.pindata.unpin")), 1)
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["class"])) : createCommentVNode("", true),
        binaryDataDisplayData.value ? (openBlock(), createBlock(_sfc_main$m, {
          key: 1,
          "window-visible": binaryDataDisplayVisible.value,
          "display-data": binaryDataDisplayData.value,
          onClose: closeBinaryDataDisplay
        }, null, 8, ["window-visible", "display-data"])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.header)
        }, [
          renderSlot(_ctx.$slots, "header", {}, void 0, true),
          withDirectives(createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.displayModes),
            "data-test-id": "run-data-pane-header",
            onClick: _cache[4] || (_cache[4] = withModifiers(() => {
            }, ["stop"]))
          }, [
            (openBlock(), createBlock(Suspense, null, {
              default: withCtx(() => [
                showIOSearch.value ? (openBlock(), createBlock(unref(LazyRunDataSearch), {
                  key: 0,
                  modelValue: search2.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => search2.value = $event),
                  class: normalizeClass(_ctx.$style.search),
                  "pane-type": _ctx.paneType,
                  "display-mode": displayMode.value,
                  "is-area-active": _ctx.isPaneActive,
                  onFocus: activatePane
                }, null, 8, ["modelValue", "class", "pane-type", "display-mode", "is-area-active"])) : createCommentVNode("", true)
              ]),
              _: 1
            })),
            withDirectives(createVNode(unref(N8nRadioButtons), {
              "model-value": displayMode.value,
              options: displayModes2.value,
              "data-test-id": "ndv-run-data-display-mode",
              "onUpdate:modelValue": onDisplayModeChange
            }, null, 8, ["model-value", "options"]), [
              [
                vShow,
                hasNodeRun.value && (inputData.value.length || binaryData.value.length || search2.value) && !editMode2.value.enabled
              ]
            ]),
            canPinData.value && !isReadOnlyRoute.value && !readOnlyEnv.value ? withDirectives((openBlock(), createBlock(unref(_sfc_main$B), {
              key: 0,
              title: unref(i18n).baseText("runData.editOutput"),
              circle: false,
              disabled: node2.value?.disabled,
              icon: "pencil-alt",
              type: "tertiary",
              "data-test-id": "ndv-edit-pinned-data",
              onClick: _cache[2] || (_cache[2] = ($event) => enterEditMode({ origin: "editIconButton" }))
            }, null, 8, ["title", "disabled"])), [
              [vShow, !editMode2.value.enabled]
            ]) : createCommentVNode("", true),
            showPinButton.value ? (openBlock(), createBlock(RunDataPinButton, {
              key: 1,
              disabled: pinButtonDisabled.value,
              "tooltip-contents-visibility": {
                binaryDataTooltipContent: !!binaryData.value?.length,
                pinDataDiscoveryTooltipContent: isControlledPinDataTooltip.value && pinDataDiscoveryTooltipVisible.value
              },
              "data-pinning-docs-url": unref(DATA_PINNING_DOCS_URL),
              "pinned-data": unref(pinnedData),
              onTogglePinData: _cache[3] || (_cache[3] = ($event) => onTogglePinData({ source: "pin-icon-click" }))
            }, null, 8, ["disabled", "tooltip-contents-visibility", "data-pinning-docs-url", "pinned-data"])) : createCommentVNode("", true),
            withDirectives(createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.editModeActions)
            }, [
              createVNode(unref(N8nButton), {
                type: "tertiary",
                label: unref(i18n).baseText("runData.editor.cancel"),
                onClick: onClickCancelEdit
              }, null, 8, ["label"]),
              createVNode(unref(N8nButton), {
                class: "ml-2xs",
                type: "primary",
                label: unref(i18n).baseText("runData.editor.save"),
                onClick: onClickSaveEdit
              }, null, 8, ["label"])
            ], 2), [
              [vShow, editMode2.value.enabled]
            ])
          ], 2), [
            [vShow, !hasRunError.value && !isTrimmedManualExecutionDataItem.value]
          ])
        ], 2),
        inputSelectLocation.value === "header" ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(_ctx.$style.inputSelect)
        }, [
          renderSlot(_ctx.$slots, "input-select", {}, void 0, true)
        ], 2)) : createCommentVNode("", true),
        maxRunIndex.value > 0 && !displaysMultipleNodes.value ? withDirectives((openBlock(), createElementBlock("div", {
          key: 3,
          class: normalizeClass(_ctx.$style.runSelector)
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.runSelectorInner)
          }, [
            inputSelectLocation.value === "runs" ? renderSlot(_ctx.$slots, "input-select", { key: 0 }, void 0, true) : createCommentVNode("", true),
            createVNode(unref(N8nSelect), {
              "model-value": _ctx.runIndex,
              class: normalizeClass(_ctx.$style.runSelectorSelect),
              size: "small",
              teleported: "",
              "data-test-id": "run-selector",
              "onUpdate:modelValue": onRunIndexChange,
              onClick: _cache[5] || (_cache[5] = withModifiers(() => {
              }, ["stop"]))
            }, {
              prepend: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.run")), 1)
              ]),
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(maxRunIndex.value + 1, (option) => {
                  return openBlock(), createBlock(unref(_sfc_main$E), {
                    key: option,
                    label: getRunLabel(option),
                    value: option - 1
                  }, null, 8, ["label", "value"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["model-value", "class"]),
            _ctx.canLinkRuns ? (openBlock(), createBlock(unref(N8nTooltip), {
              key: 1,
              placement: "right"
            }, {
              content: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText(_ctx.linkedRuns ? "runData.unlinking.hint" : "runData.linking.hint")), 1)
              ]),
              default: withCtx(() => [
                createVNode(unref(_sfc_main$B), {
                  icon: _ctx.linkedRuns ? "unlink" : "link",
                  class: normalizeClass(["linkRun", _ctx.linkedRuns ? "linked" : ""]),
                  text: "",
                  type: "tertiary",
                  size: "small",
                  "data-test-id": "link-run",
                  onClick: toggleLinkRuns
                }, null, 8, ["icon", "class"])
              ]),
              _: 1
            })) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "run-info", {}, void 0, true)
          ], 2),
          activeTaskMetadata.value && hasReleatedExectuion.value && !(_ctx.paneType === "input" && hasInputOverwrite.value) ? (openBlock(), createElementBlock("a", {
            key: 0,
            class: normalizeClass(_ctx.$style.relatedExecutionInfo),
            "data-test-id": "related-execution-link",
            href: unref(resolveRelatedExecutionUrl)(activeTaskMetadata.value),
            target: "_blank",
            onClick: _cache[6] || (_cache[6] = withModifiers(($event) => unref(trackOpeningRelatedExecution)(activeTaskMetadata.value, displayMode.value), ["stop"]))
          }, [
            createVNode(_component_N8nIcon, {
              icon: "external-link-alt",
              size: "xsmall"
            }),
            createTextVNode(" " + toDisplayString(getExecutionLinkLabel(activeTaskMetadata.value)), 1)
          ], 10, _hoisted_2$5)) : createCommentVNode("", true)
        ], 2)), [
          [vShow, !editMode2.value.enabled]
        ]) : createCommentVNode("", true),
        !displaysMultipleNodes.value ? renderSlot(_ctx.$slots, "before-data", { key: 4 }, void 0, true) : createCommentVNode("", true),
        props.calloutMessage ? (openBlock(), createElementBlock("div", {
          key: 5,
          class: normalizeClass(_ctx.$style.hintCallout)
        }, [
          createVNode(unref(N8nCallout), {
            theme: "info",
            "data-test-id": "run-data-callout"
          }, {
            default: withCtx(() => [
              withDirectives(createVNode(unref(N8nText), { size: "small" }, null, 512), [
                [_directive_n8n_html, props.calloutMessage]
              ])
            ]),
            _: 1
          })
        ], 2)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(getNodeHints$1(), (hint) => {
          return openBlock(), createBlock(unref(N8nCallout), {
            key: hint.message,
            class: normalizeClass(_ctx.$style.hintCallout),
            theme: hint.type || "info"
          }, {
            default: withCtx(() => [
              withDirectives(createVNode(unref(N8nText), { size: "small" }, null, 512), [
                [_directive_n8n_html, hint.message]
              ])
            ]),
            _: 2
          }, 1032, ["class", "theme"]);
        }), 128)),
        maxOutputIndex.value > 0 && branches.value.length > 1 && !displaysMultipleNodes.value ? (openBlock(), createElementBlock("div", {
          key: 6,
          class: normalizeClass(_ctx.$style.outputs),
          "data-test-id": "branches"
        }, [
          inputSelectLocation.value === "outputs" ? renderSlot(_ctx.$slots, "input-select", { key: 0 }, void 0, true) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.tabs)
          }, [
            createVNode(unref(N8nTabs), {
              "model-value": currentOutputIndex.value,
              options: branches.value,
              "onUpdate:modelValue": onBranchChange
            }, null, 8, ["model-value", "options"])
          ], 2)
        ], 2)) : hasNodeRun.value && !isSearchInSchemaView.value && (dataCount.value > 0 && maxRunIndex.value === 0 || search2.value) && !isArtificialRecoveredEventItem.value && !displaysMultipleNodes.value ? withDirectives((openBlock(), createElementBlock("div", {
          key: 7,
          class: normalizeClass([_ctx.$style.itemsCount, { [_ctx.$style.muted]: _ctx.paneType === "input" && maxRunIndex.value === 0 }]),
          "data-test-id": "ndv-items-count"
        }, [
          inputSelectLocation.value === "items" ? renderSlot(_ctx.$slots, "input-select", { key: 0 }, void 0, true) : createCommentVNode("", true),
          search2.value ? (openBlock(), createBlock(unref(N8nText), {
            key: 1,
            class: normalizeClass(_ctx.$style.itemsText)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(i18n).baseText("ndv.search.items", {
                adjustToNumber: unfilteredDataCount.value,
                interpolate: { matched: dataCount.value, total: unfilteredDataCount.value }
              })), 1)
            ]),
            _: 1
          }, 8, ["class"])) : (openBlock(), createBlock(unref(N8nText), {
            key: 2,
            class: normalizeClass(_ctx.$style.itemsText)
          }, {
            default: withCtx(() => [
              createBaseVNode("span", null, toDisplayString(unref(i18n).baseText("ndv.output.items", {
                adjustToNumber: dataCount.value,
                interpolate: { count: dataCount.value }
              })), 1),
              activeTaskMetadata.value?.subExecutionsCount ? (openBlock(), createElementBlock("span", _hoisted_3$3, toDisplayString(unref(i18n).baseText("ndv.output.andSubExecutions", {
                adjustToNumber: activeTaskMetadata.value.subExecutionsCount,
                interpolate: { count: activeTaskMetadata.value.subExecutionsCount }
              })), 1)) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["class"])),
          activeTaskMetadata.value && hasReleatedExectuion.value && !(_ctx.paneType === "input" && hasInputOverwrite.value) ? (openBlock(), createElementBlock("a", {
            key: 3,
            class: normalizeClass(_ctx.$style.relatedExecutionInfo),
            "data-test-id": "related-execution-link",
            href: unref(resolveRelatedExecutionUrl)(activeTaskMetadata.value),
            target: "_blank",
            onClick: _cache[7] || (_cache[7] = withModifiers(($event) => unref(trackOpeningRelatedExecution)(activeTaskMetadata.value, displayMode.value), ["stop"]))
          }, [
            createVNode(_component_N8nIcon, {
              icon: "external-link-alt",
              size: "xsmall"
            }),
            createTextVNode(" " + toDisplayString(getExecutionLinkLabel(activeTaskMetadata.value)), 1)
          ], 10, _hoisted_4$3)) : createCommentVNode("", true)
        ], 2)), [
          [vShow, !editMode2.value.enabled]
        ]) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "dataContainerRef",
          ref: dataContainerRef,
          class: normalizeClass(_ctx.$style.dataContainer),
          "data-test-id": "ndv-data-container"
        }, [
          _ctx.isExecuting && !isWaitNodeWaiting.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.$style.center),
            "data-test-id": "ndv-executing"
          }, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.spinner)
            }, [
              createVNode(unref(_sfc_main$C), { type: "ring" })
            ], 2),
            createVNode(unref(N8nText), null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.executingMessage), 1)
              ]),
              _: 1
            })
          ], 2)) : editMode2.value.enabled ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.$style.editMode)
          }, [
            createBaseVNode("div", {
              class: normalizeClass([_ctx.$style.editModeBody, "ignore-key-press-canvas"])
            }, [
              createVNode(JsonEditor, {
                "model-value": editMode2.value.value,
                "fill-parent": true,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(ndvStore).setOutputPanelEditModeValue($event))
              }, null, 8, ["model-value"])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.editModeFooter)
            }, [
              createVNode(unref(InfoTip), {
                bold: false,
                class: normalizeClass(_ctx.$style.editModeFooterInfotip)
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("runData.editor.copyDataInfo")) + " ", 1),
                  createVNode(unref(N8nLink), {
                    to: unref(DATA_EDITING_DOCS_URL),
                    size: "small"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(i18n).baseText("generic.learnMore")), 1)
                    ]),
                    _: 1
                  }, 8, ["to"])
                ]),
                _: 1
              }, 8, ["class"])
            ], 2)
          ], 2)) : _ctx.paneType === "output" && hasSubworkflowExecutionError.value && subworkflowExecutionError.value ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(_ctx.$style.stretchVertically)
          }, [
            createVNode(_sfc_main$D, {
              error: subworkflowExecutionError.value,
              class: normalizeClass(_ctx.$style.errorDisplay)
            }, null, 8, ["error", "class"])
          ], 2)) : isWaitNodeWaiting.value ? (openBlock(), createElementBlock("div", {
            key: 3,
            class: normalizeClass(_ctx.$style.center)
          }, [
            renderSlot(_ctx.$slots, "node-waiting", {}, () => [
              _cache[11] || (_cache[11] = createTextVNode("xxx"))
            ], true)
          ], 2)) : !hasNodeRun.value && !(displaysMultipleNodes.value && node2.value?.disabled) ? (openBlock(), createElementBlock("div", {
            key: 4,
            class: normalizeClass(_ctx.$style.center)
          }, [
            renderSlot(_ctx.$slots, "node-not-run", {}, void 0, true)
          ], 2)) : _ctx.paneType === "input" && !displaysMultipleNodes.value && node2.value?.disabled ? (openBlock(), createElementBlock("div", {
            key: 5,
            class: normalizeClass(_ctx.$style.center)
          }, [
            createVNode(unref(N8nText), null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.disabled", { interpolate: { nodeName: node2.value.name } })) + " ", 1),
                createVNode(unref(N8nLink), { onClick: enableNode }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.disabled.cta")), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ], 2)) : isTrimmedManualExecutionDataItem.value && unref(uiStore).isProcessingExecutionResults ? (openBlock(), createElementBlock("div", {
            key: 6,
            class: normalizeClass(_ctx.$style.center)
          }, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.spinner)
            }, [
              createVNode(unref(_sfc_main$C), { type: "ring" })
            ], 2),
            createVNode(unref(N8nText), {
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("runData.trimmedData.loading")), 1)
              ]),
              _: 1
            })
          ], 2)) : isTrimmedManualExecutionDataItem.value ? (openBlock(), createElementBlock("div", {
            key: 7,
            class: normalizeClass(_ctx.$style.center)
          }, [
            createVNode(unref(N8nText), {
              bold: "",
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("runData.trimmedData.title")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(N8nText), null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("runData.trimmedData.message")), 1)
              ]),
              _: 1
            })
          ], 2)) : hasNodeRun.value && isArtificialRecoveredEventItem.value ? (openBlock(), createElementBlock("div", {
            key: 8,
            class: normalizeClass(_ctx.$style.center)
          }, [
            renderSlot(_ctx.$slots, "recovered-artificial-output-data", {}, void 0, true)
          ], 2)) : hasNodeRun.value && hasRunError.value ? (openBlock(), createElementBlock("div", {
            key: 9,
            class: normalizeClass(_ctx.$style.stretchVertically)
          }, [
            isPaneTypeInput.value ? (openBlock(), createBlock(unref(N8nText), {
              key: 0,
              class: normalizeClass(_ctx.$style.center),
              size: "large",
              tag: "p",
              bold: ""
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("nodeErrorView.inputPanel.previousNodeError.title", {
                  interpolate: { nodeName: node2.value?.name ?? "" }
                })), 1)
              ]),
              _: 1
            }, 8, ["class"])) : _ctx.$slots["content"] ? (openBlock(), createElementBlock("div", _hoisted_5$3, [
              workflowRunErrorAsNodeError.value ? (openBlock(), createBlock(_sfc_main$D, {
                key: 0,
                error: workflowRunErrorAsNodeError.value,
                class: normalizeClass(_ctx.$style.inlineError),
                compact: ""
              }, null, 8, ["error", "class"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "content", {}, void 0, true)
            ])) : workflowRunErrorAsNodeError.value ? (openBlock(), createBlock(_sfc_main$D, {
              key: 2,
              error: workflowRunErrorAsNodeError.value,
              class: normalizeClass(_ctx.$style.dataDisplay)
            }, null, 8, ["error", "class"])) : createCommentVNode("", true)
          ], 2)) : hasNodeRun.value && (!unfilteredDataCount.value || search2.value && !dataCount.value) && branches.value.length > 1 ? (openBlock(), createElementBlock("div", {
            key: 10,
            class: normalizeClass(_ctx.$style.center)
          }, [
            search2.value ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
              createVNode(unref(N8nText), {
                tag: "h3",
                size: "large"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("ndv.search.noMatch.title")), 1)
                ]),
                _: 1
              }),
              createVNode(unref(N8nText), null, {
                default: withCtx(() => [
                  createVNode(_component_i18n_t, {
                    keypath: "ndv.search.noMatch.description",
                    tag: "span"
                  }, {
                    link: withCtx(() => [
                      createBaseVNode("a", {
                        href: "#",
                        onClick: onSearchClear
                      }, toDisplayString(unref(i18n).baseText("ndv.search.noMatch.description.link")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ])) : (openBlock(), createBlock(unref(N8nText), { key: 1 }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.noDataInBranchMessage), 1)
              ]),
              _: 1
            }))
          ], 2)) : hasNodeRun.value && !inputData.value.length && !search2.value ? (openBlock(), createElementBlock("div", {
            key: 11,
            class: normalizeClass(_ctx.$style.center)
          }, [
            renderSlot(_ctx.$slots, "no-output-data", {}, () => [
              _cache[12] || (_cache[12] = createTextVNode("xxx"))
            ], true)
          ], 2)) : hasNodeRun.value && !showData.value ? (openBlock(), createElementBlock("div", {
            key: 12,
            "data-test-id": "ndv-data-size-warning",
            class: normalizeClass(_ctx.$style.center)
          }, [
            createVNode(unref(N8nText), {
              bold: true,
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.tooMuchDataTitle), 1)
              ]),
              _: 1
            }),
            createVNode(unref(N8nText), {
              align: "center",
              tag: "div"
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("span", null, null, 512), [
                  [
                    _directive_n8n_html,
                    unref(i18n).baseText("ndv.output.tooMuchData.message", {
                      interpolate: { size: dataSizeInMB.value }
                    })
                  ]
                ])
              ]),
              _: 1
            }),
            createVNode(unref(N8nButton), {
              outline: "",
              label: unref(i18n).baseText("ndv.output.tooMuchData.showDataAnyway"),
              onClick: showTooMuchData
            }, null, 8, ["label"]),
            createVNode(unref(N8nButton), {
              size: "small",
              label: unref(i18n).baseText("runData.downloadBinaryData"),
              onClick: _cache[9] || (_cache[9] = ($event) => downloadJsonData())
            }, null, 8, ["label"])
          ], 2)) : hasNodeRun.value && _ctx.$slots["content"] ? renderSlot(_ctx.$slots, "content", { key: 13 }, void 0, true) : hasNodeRun.value && displayMode.value === "table" && binaryData.value.length > 0 && inputData.value.length === 1 && Object.keys(jsonData.value[0] || {}).length === 0 ? (openBlock(), createElementBlock("div", {
            key: 14,
            class: normalizeClass(_ctx.$style.center)
          }, [
            createVNode(unref(N8nText), null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("runData.switchToBinary.info")) + " ", 1),
                createBaseVNode("a", { onClick: switchToBinary }, toDisplayString(unref(i18n).baseText("runData.switchToBinary.binary")), 1)
              ]),
              _: 1
            })
          ], 2)) : showIoSearchNoMatchContent.value ? (openBlock(), createElementBlock("div", {
            key: 15,
            class: normalizeClass(_ctx.$style.center)
          }, [
            createVNode(unref(N8nText), {
              tag: "h3",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.search.noMatch.title")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(N8nText), null, {
              default: withCtx(() => [
                createVNode(_component_i18n_t, {
                  keypath: "ndv.search.noMatch.description",
                  tag: "span"
                }, {
                  link: withCtx(() => [
                    createBaseVNode("a", {
                      href: "#",
                      onClick: onSearchClear
                    }, toDisplayString(unref(i18n).baseText("ndv.search.noMatch.description.link")), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ], 2)) : hasNodeRun.value && displayMode.value === "table" && node2.value ? (openBlock(), createBlock(Suspense, { key: 16 }, {
            default: withCtx(() => [
              createVNode(unref(LazyRunDataTable), {
                node: node2.value,
                "input-data": inputDataPage.value,
                "mapping-enabled": _ctx.mappingEnabled,
                "distance-from-active": _ctx.distanceFromActive,
                "run-index": _ctx.runIndex,
                "page-offset": currentPageOffset.value,
                "total-runs": maxRunIndex.value,
                "has-default-hover-state": _ctx.paneType === "input" && !search2.value,
                search: search2.value,
                onMounted: _cache[10] || (_cache[10] = ($event) => emit("tableMounted", $event)),
                onActiveRowChanged: onItemHover,
                onDisplayModeChange
              }, null, 8, ["node", "input-data", "mapping-enabled", "distance-from-active", "run-index", "page-offset", "total-runs", "has-default-hover-state", "search"])
            ]),
            _: 1
          })) : hasNodeRun.value && displayMode.value === "json" && node2.value ? (openBlock(), createBlock(Suspense, { key: 17 }, {
            default: withCtx(() => [
              createVNode(unref(LazyRunDataJson), {
                "pane-type": _ctx.paneType,
                "edit-mode": editMode2.value,
                "push-ref": _ctx.pushRef,
                node: node2.value,
                "input-data": inputDataPage.value,
                "mapping-enabled": _ctx.mappingEnabled,
                "distance-from-active": _ctx.distanceFromActive,
                "run-index": _ctx.runIndex,
                "total-runs": maxRunIndex.value,
                search: search2.value
              }, null, 8, ["pane-type", "edit-mode", "push-ref", "node", "input-data", "mapping-enabled", "distance-from-active", "run-index", "total-runs", "search"])
            ]),
            _: 1
          })) : hasNodeRun.value && isPaneTypeOutput.value && displayMode.value === "html" ? (openBlock(), createBlock(Suspense, { key: 18 }, {
            default: withCtx(() => [
              createVNode(unref(LazyRunDataHtml), { "input-html": inputHtml.value }, null, 8, ["input-html"])
            ]),
            _: 1
          })) : hasNodeRun.value && isSchemaView.value ? (openBlock(), createBlock(Suspense, { key: 19 }, {
            default: withCtx(() => [
              createVNode(unref(LazyRunDataSchema), {
                nodes: _ctx.nodes,
                "mapping-enabled": _ctx.mappingEnabled,
                node: node2.value,
                data: jsonData.value,
                "pane-type": _ctx.paneType,
                "connection-type": connectionType2.value,
                "run-index": _ctx.runIndex,
                "output-index": currentOutputIndex.value,
                "total-runs": maxRunIndex.value,
                search: search2.value,
                class: normalizeClass(_ctx.$style.schema),
                "onClear:search": onSearchClear
              }, null, 8, ["nodes", "mapping-enabled", "node", "data", "pane-type", "connection-type", "run-index", "output-index", "total-runs", "search", "class"])
            ]),
            _: 1
          })) : displayMode.value === "binary" && binaryData.value.length === 0 ? (openBlock(), createElementBlock("div", {
            key: 20,
            class: normalizeClass(_ctx.$style.center)
          }, [
            createVNode(unref(N8nText), {
              align: "center",
              tag: "div"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("runData.noBinaryDataFound")), 1)
              ]),
              _: 1
            })
          ], 2)) : displayMode.value === "binary" ? (openBlock(), createElementBlock("div", {
            key: 21,
            class: normalizeClass(_ctx.$style.dataDisplay)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(binaryData.value, (binaryDataEntry, index) => {
              return openBlock(), createElementBlock("div", { key: index }, [
                binaryData.value.length > 1 ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(_ctx.$style.binaryIndex)
                }, [
                  createBaseVNode("div", null, toDisplayString(index + 1), 1)
                ], 2)) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.$style.binaryRow)
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(binaryDataEntry, (binaryData2, key) => {
                    return openBlock(), createElementBlock("div", {
                      key: index + "_" + key,
                      class: normalizeClass(_ctx.$style.binaryCell)
                    }, [
                      createBaseVNode("div", {
                        "data-test-id": "ndv-binary-data_" + index
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.$style.binaryHeader)
                        }, toDisplayString(key), 3),
                        binaryData2.fileName ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
                          createBaseVNode("div", null, [
                            createVNode(unref(N8nText), {
                              size: "small",
                              bold: true
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(unref(i18n).baseText("runData.fileName")) + ": ", 1)
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.$style.binaryValue)
                          }, toDisplayString(binaryData2.fileName), 3)
                        ])) : createCommentVNode("", true),
                        binaryData2.directory ? (openBlock(), createElementBlock("div", _hoisted_9$1, [
                          createBaseVNode("div", null, [
                            createVNode(unref(N8nText), {
                              size: "small",
                              bold: true
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(unref(i18n).baseText("runData.directory")) + ": ", 1)
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.$style.binaryValue)
                          }, toDisplayString(binaryData2.directory), 3)
                        ])) : createCommentVNode("", true),
                        binaryData2.fileExtension ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
                          createBaseVNode("div", null, [
                            createVNode(unref(N8nText), {
                              size: "small",
                              bold: true
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(unref(i18n).baseText("runData.fileExtension")) + ":", 1)
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.$style.binaryValue)
                          }, toDisplayString(binaryData2.fileExtension), 3)
                        ])) : createCommentVNode("", true),
                        binaryData2.mimeType ? (openBlock(), createElementBlock("div", _hoisted_11$1, [
                          createBaseVNode("div", null, [
                            createVNode(unref(N8nText), {
                              size: "small",
                              bold: true
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(unref(i18n).baseText("runData.mimeType")) + ": ", 1)
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.$style.binaryValue)
                          }, toDisplayString(binaryData2.mimeType), 3)
                        ])) : createCommentVNode("", true),
                        binaryData2.fileSize ? (openBlock(), createElementBlock("div", _hoisted_12$1, [
                          createBaseVNode("div", null, [
                            createVNode(unref(N8nText), {
                              size: "small",
                              bold: true
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(unref(i18n).baseText("runData.fileSize")) + ": ", 1)
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.$style.binaryValue)
                          }, toDisplayString(binaryData2.fileSize), 3)
                        ])) : createCommentVNode("", true),
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.$style.binaryButtonContainer)
                        }, [
                          isViewable(index, key) ? (openBlock(), createBlock(unref(N8nButton), {
                            key: 0,
                            size: "small",
                            label: unref(i18n).baseText("runData.showBinaryData"),
                            "data-test-id": "ndv-view-binary-data",
                            onClick: ($event) => displayBinaryData(index, key)
                          }, null, 8, ["label", "onClick"])) : createCommentVNode("", true),
                          isDownloadable(index, key) ? (openBlock(), createBlock(unref(N8nButton), {
                            key: 1,
                            size: "small",
                            type: "secondary",
                            label: unref(i18n).baseText("runData.downloadBinaryData"),
                            "data-test-id": "ndv-download-binary-data",
                            onClick: ($event) => downloadBinaryData(index, key)
                          }, null, 8, ["label", "onClick"])) : createCommentVNode("", true)
                        ], 2)
                      ], 8, _hoisted_7$2)
                    ], 2);
                  }), 128))
                ], 2)
              ]);
            }), 128))
          ], 2)) : createCommentVNode("", true)
        ], 2),
        _ctx.hidePagination === false && hasNodeRun.value && !hasRunError.value && displayMode.value !== "binary" && dataCount.value > pageSize.value && !isSchemaView.value && !isArtificialRecoveredEventItem.value ? withDirectives((openBlock(), createElementBlock("div", {
          key: 8,
          class: normalizeClass(_ctx.$style.pagination),
          "data-test-id": "ndv-data-pagination"
        }, [
          createVNode(_component_el_pagination, {
            background: "",
            "hide-on-single-page": true,
            "current-page": currentPage.value,
            "pager-count": 5,
            "page-size": pageSize.value,
            layout: "prev, pager, next",
            total: dataCount.value,
            "onUpdate:currentPage": onCurrentPageChange
          }, null, 8, ["current-page", "page-size", "total"]),
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.pageSizeSelector)
          }, [
            createVNode(unref(N8nSelect), {
              size: "mini",
              "model-value": pageSize.value,
              teleported: "",
              "onUpdate:modelValue": onPageSizeChange
            }, {
              prepend: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.pageSize")), 1)
              ]),
              default: withCtx(() => [
                (openBlock(), createElementBlock(Fragment, null, renderList(pageSizes, (size) => {
                  return createVNode(unref(_sfc_main$E), {
                    key: size,
                    label: size,
                    value: size
                  }, null, 8, ["label", "value"]);
                }), 64)),
                createVNode(unref(_sfc_main$E), {
                  label: unref(i18n).baseText("ndv.output.all"),
                  value: dataCount.value
                }, null, 8, ["label", "value"])
              ]),
              _: 1
            }, 8, ["model-value"])
          ], 2)
        ], 2)), [
          [vShow, !editMode2.value.enabled]
        ]) : createCommentVNode("", true),
        createVNode(unref(N8nBlockUi), {
          show: _ctx.blockUI,
          class: normalizeClass(_ctx.$style.uiBlocker)
        }, null, 8, ["show", "class"])
      ], 34);
    };
  }
});
const infoIcon = "_infoIcon_e9ynn_123";
const center = "_center_e9ynn_127";
const container$1 = "_container_e9ynn_141";
const pinnedDataCallout = "_pinnedDataCallout_e9ynn_150";
const header$1 = "_header_e9ynn_158";
const dataContainer = "_dataContainer_e9ynn_173";
const dataDisplay = "_dataDisplay_e9ynn_182";
const inlineError = "_inlineError_e9ynn_194";
const outputs = "_outputs_e9ynn_201";
const tabs = "_tabs_e9ynn_210";
const itemsCount = "_itemsCount_e9ynn_218";
const itemsText = "_itemsText_e9ynn_227";
const muted = "_muted_e9ynn_233";
const inputSelect = "_inputSelect_e9ynn_238";
const runSelector = "_runSelector_e9ynn_244";
const runSelectorInner = "_runSelectorInner_e9ynn_257";
const runSelectorSelect = "_runSelectorSelect_e9ynn_263";
const search = "_search_e9ynn_267";
const pagination = "_pagination_e9ynn_271";
const pageSizeSelector = "_pageSizeSelector_e9ynn_281";
const binaryIndex = "_binaryIndex_e9ynn_287";
const binaryRow = "_binaryRow_e9ynn_304";
const binaryCell = "_binaryCell_e9ynn_309";
const binaryHeader = "_binaryHeader_e9ynn_321";
const binaryButtonContainer = "_binaryButtonContainer_e9ynn_330";
const binaryValue = "_binaryValue_e9ynn_341";
const displayModes = "_displayModes_e9ynn_346";
const tooltipContain = "_tooltipContain_e9ynn_353";
const spinner = "_spinner_e9ynn_357";
const editMode = "_editMode_e9ynn_368";
const editModeBody = "_editModeBody_e9ynn_377";
const editModeFooter = "_editModeFooter_e9ynn_384";
const editModeFooterInfotip = "_editModeFooterInfotip_e9ynn_394";
const editModeActions = "_editModeActions_e9ynn_400";
const stretchVertically = "_stretchVertically_e9ynn_407";
const uiBlocker = "_uiBlocker_e9ynn_411";
const hintCallout = "_hintCallout_e9ynn_416";
const schema = "_schema_e9ynn_422";
const relatedExecutionInfo = "_relatedExecutionInfo_e9ynn_426";
const style0$8 = {
  infoIcon,
  center,
  container: container$1,
  pinnedDataCallout,
  header: header$1,
  dataContainer,
  "actions-group": "_actions-group_e9ynn_178",
  dataDisplay,
  inlineError,
  outputs,
  tabs,
  itemsCount,
  itemsText,
  muted,
  inputSelect,
  runSelector,
  runSelectorInner,
  runSelectorSelect,
  search,
  pagination,
  pageSizeSelector,
  binaryIndex,
  binaryRow,
  binaryCell,
  binaryHeader,
  binaryButtonContainer,
  binaryValue,
  displayModes,
  tooltipContain,
  spinner,
  editMode,
  editModeBody,
  editModeFooter,
  editModeFooterInfotip,
  editModeActions,
  stretchVertically,
  uiBlocker,
  hintCallout,
  schema,
  relatedExecutionInfo
};
const cssModules$a = {
  "$style": style0$8
};
const RunData = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__cssModules", cssModules$a], ["__scopeId", "data-v-e5cc934c"]]);
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "RunInfo",
  props: {
    taskData: {},
    hasStaleData: { type: Boolean },
    hasPinData: { type: Boolean }
  },
  setup(__props) {
    const i18n = useI18n();
    const props = __props;
    const runTaskData = computed(() => {
      return props.taskData;
    });
    const theme = computed(() => {
      return props.taskData?.error ? "danger" : "success";
    });
    const runMetadata = computed(() => {
      if (!runTaskData.value) {
        return null;
      }
      const { date, time } = convertToDisplayDateComponents(runTaskData.value.startTime);
      return {
        executionTime: runTaskData.value.executionTime,
        startTime: `${date} at ${time}`
      };
    });
    return (_ctx, _cache) => {
      const _component_n8n_info_tip = resolveComponent("n8n-info-tip");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _directive_n8n_html = resolveDirective("n8n-html");
      return _ctx.hasStaleData ? (openBlock(), createBlock(_component_n8n_info_tip, {
        key: 0,
        theme: "warning",
        type: "tooltip",
        "tooltip-placement": "right",
        "data-test-id": "node-run-info-stale"
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("span", null, null, 512), [
            [
              _directive_n8n_html,
              unref(i18n).baseText(
                _ctx.hasPinData ? "ndv.output.staleDataWarning.pinData" : "ndv.output.staleDataWarning.regular"
              )
            ]
          ])
        ]),
        _: 1
      })) : runMetadata.value ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.$style.tooltipRow)
      }, [
        createVNode(_component_n8n_info_tip, {
          type: "note",
          theme: theme.value,
          "data-test-id": `node-run-status-${theme.value}`
        }, null, 8, ["theme", "data-test-id"]),
        createVNode(_component_n8n_info_tip, {
          type: "tooltip",
          theme: "info",
          "data-test-id": `node-run-info`,
          "tooltip-placement": "right"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", null, [
              createVNode(_component_n8n_text, {
                bold: true,
                size: "small"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(runTaskData.value?.error ? unref(i18n).baseText("runData.executionStatus.failed") : unref(i18n).baseText("runData.executionStatus.success")), 1)
                ]),
                _: 1
              }),
              _cache[0] || (_cache[0] = createBaseVNode("br", null, null, -1)),
              createVNode(_component_n8n_text, {
                bold: true,
                size: "small"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("runData.startTime") + ":"), 1)
                ]),
                _: 1
              }),
              createTextVNode(" " + toDisplayString(runMetadata.value.startTime), 1),
              _cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
              createVNode(_component_n8n_text, {
                bold: true,
                size: "small"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("runData.executionTime") + ":"), 1)
                ]),
                _: 1
              }),
              createTextVNode(" " + toDisplayString(runMetadata.value.executionTime) + " " + toDisplayString(unref(i18n).baseText("runData.ms")), 1)
            ])
          ]),
          _: 1
        })
      ], 2)) : createCommentVNode("", true);
    };
  }
});
const tooltipRow = "_tooltipRow_14r7d_123";
const style0$7 = {
  tooltipRow
};
const cssModules$9 = {
  "$style": style0$7
};
const RunInfo = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__cssModules", cssModules$9]]);
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "OutputPanel",
  props: {
    workflow: {},
    runIndex: {},
    isReadOnly: { type: Boolean },
    linkedRuns: { type: Boolean },
    canLinkRuns: { type: Boolean },
    pushRef: {},
    blockUI: { type: Boolean, default: false },
    isProductionExecutionPreview: { type: Boolean, default: false },
    isPaneActive: { type: Boolean, default: false }
  },
  emits: ["linkRun", "unlinkRun", "runChange", "activatePane", "tableMounted", "itemHover", "search", "openSettings"],
  setup(__props, { emit: __emit }) {
    const OUTPUT_TYPE = {
      REGULAR: "regular",
      LOGS: "logs"
    };
    const props = __props;
    const emit = __emit;
    const ndvStore = useNDVStore();
    const nodeTypesStore = useNodeTypesStore();
    const workflowsStore = useWorkflowsStore();
    const uiStore = useUIStore();
    const telemetry = useTelemetry();
    const i18n = useI18n();
    const { activeNode } = storeToRefs(ndvStore);
    const { isSubNodeType: isSubNodeType2 } = useNodeType({
      node: activeNode
    });
    const pinnedData = usePinnedData(activeNode, {
      runIndex: props.runIndex,
      displayMode: ndvStore.outputPanelDisplayMode
    });
    const outputMode = ref(OUTPUT_TYPE.REGULAR);
    const outputTypes = ref([
      { label: i18n.baseText("ndv.output.outType.regular"), value: OUTPUT_TYPE.REGULAR },
      { label: i18n.baseText("ndv.output.outType.logs"), value: OUTPUT_TYPE.LOGS }
    ]);
    const runDataRef = ref();
    const node2 = computed(() => {
      return ndvStore.activeNode ?? void 0;
    });
    const isTriggerNode = computed(() => {
      return !!node2.value && nodeTypesStore.isTriggerNode(node2.value.type);
    });
    const hasAiMetadata = computed(() => {
      if (isNodeRunning.value || !workflowRunData.value) {
        return false;
      }
      if (node2.value) {
        const connectedSubNodes = props.workflow.getParentNodes(node2.value.name, "ALL_NON_MAIN");
        const resultData = connectedSubNodes.map(workflowsStore.getWorkflowResultDataByNodeName);
        return resultData && Array.isArray(resultData) && resultData.length > 0;
      }
      return false;
    });
    const hasError = computed(
      () => Boolean(
        workflowRunData.value && node2.value && workflowRunData.value[node2.value.name]?.[props.runIndex]?.error
      )
    );
    const defaultOutputMode = computed(() => {
      return hasError.value && hasAiMetadata.value ? OUTPUT_TYPE.LOGS : OUTPUT_TYPE.REGULAR;
    });
    const isNodeRunning = computed(() => {
      return workflowRunning.value && !!node2.value && workflowsStore.isNodeExecuting(node2.value.name);
    });
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const workflowExecution = computed(() => {
      return workflowsStore.getWorkflowExecution;
    });
    const workflowRunData = computed(() => {
      if (workflowExecution.value === null) {
        return null;
      }
      const executionData = workflowExecution.value.data;
      if (!executionData?.resultData?.runData) {
        return null;
      }
      return executionData.resultData.runData;
    });
    const hasNodeRun = computed(() => {
      if (workflowsStore.subWorkflowExecutionError) return true;
      return Boolean(
        node2.value && workflowRunData.value && workflowRunData.value.hasOwnProperty(node2.value.name)
      );
    });
    const runTaskData = computed(() => {
      if (!node2.value || workflowExecution.value === null) {
        return null;
      }
      const runData = workflowRunData.value;
      if (runData === null || !runData.hasOwnProperty(node2.value.name)) {
        return null;
      }
      if (runData[node2.value.name].length <= props.runIndex) {
        return null;
      }
      return runData[node2.value.name][props.runIndex];
    });
    const runsCount = computed(() => {
      if (node2.value === null) {
        return 0;
      }
      const runData = workflowRunData.value;
      if (runData === null || node2.value && !runData.hasOwnProperty(node2.value.name)) {
        return 0;
      }
      if (node2.value && runData[node2.value.name].length) {
        return runData[node2.value.name].length;
      }
      return 0;
    });
    const staleData = computed(() => {
      if (!node2.value) {
        return false;
      }
      const updatedAt = workflowsStore.getParametersLastUpdate(node2.value.name);
      if (!updatedAt || !runTaskData.value) {
        return false;
      }
      const runAt = runTaskData.value.startTime;
      return updatedAt > runAt;
    });
    const outputPanelEditMode = computed(() => {
      return ndvStore.outputPanelEditMode;
    });
    const canPinData = computed(() => {
      return pinnedData.isValidNodeType.value && !props.isReadOnly;
    });
    const allToolsWereUnusedNotice = computed(() => {
      if (!node2.value || runsCount.value === 0 || hasError.value) return void 0;
      if (pinnedData.hasData.value) return void 0;
      const toolsAvailable = props.workflow.getParentNodes(
        node2.value.name,
        NodeConnectionType.AiTool,
        1
      );
      const toolsUsedInLatestRun = toolsAvailable.filter(
        (tool) => !!workflowRunData.value?.[tool]?.[props.runIndex]
      );
      if (toolsAvailable.length > 0 && toolsUsedInLatestRun.length === 0) {
        return i18n.baseText("ndv.output.noToolUsedInfo");
      } else {
        return void 0;
      }
    });
    const insertTestData = () => {
      if (!runDataRef.value) return;
      runDataRef.value.enterEditMode({
        origin: "insertTestDataLink"
      });
      telemetry.track("User clicked ndv link", {
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        node_type: node2.value?.type,
        pane: "output",
        type: "insert-test-data"
      });
    };
    const onLinkRun = () => {
      emit("linkRun");
    };
    const onUnlinkRun = () => {
      emit("unlinkRun");
    };
    const openSettings = () => {
      emit("openSettings");
      telemetry.track("User clicked ndv link", {
        node_type: node2.value?.type,
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        pane: "output",
        type: "settings"
      });
    };
    const onRunIndexChange = (run) => {
      emit("runChange", run);
    };
    const onUpdateOutputMode = (newOutputMode) => {
      if (newOutputMode === OUTPUT_TYPE.LOGS) {
        ndvEventBus.emit("setPositionByName", "minLeft");
      } else {
        ndvEventBus.emit("setPositionByName", "initial");
      }
    };
    onMounted(() => {
      outputMode.value = defaultOutputMode.value;
    });
    watch(defaultOutputMode, (newValue, oldValue) => {
      if (newValue === OUTPUT_TYPE.LOGS && oldValue === OUTPUT_TYPE.REGULAR && hasNodeRun.value) {
        outputMode.value = defaultOutputMode.value;
      }
    });
    const activatePane = () => {
      emit("activatePane");
    };
    return (_ctx, _cache) => {
      const _directive_n8n_html = resolveDirective("n8n-html");
      return openBlock(), createBlock(RunData, {
        ref_key: "runDataRef",
        ref: runDataRef,
        node: node2.value,
        workflow: _ctx.workflow,
        "run-index": _ctx.runIndex,
        "linked-runs": _ctx.linkedRuns,
        "can-link-runs": _ctx.canLinkRuns,
        "too-much-data-title": unref(i18n).baseText("ndv.output.tooMuchData.title"),
        "no-data-in-branch-message": unref(i18n).baseText("ndv.output.noOutputDataInBranch"),
        "is-executing": isNodeRunning.value,
        "executing-message": unref(i18n).baseText("ndv.output.executing"),
        "push-ref": _ctx.pushRef,
        "block-u-i": _ctx.blockUI,
        "is-production-execution-preview": _ctx.isProductionExecutionPreview,
        "is-pane-active": _ctx.isPaneActive,
        "hide-pagination": outputMode.value === "logs",
        "pane-type": "output",
        "data-output-type": outputMode.value,
        "callout-message": allToolsWereUnusedNotice.value,
        onActivatePane: activatePane,
        onRunChange: onRunIndexChange,
        onLinkRun,
        onUnlinkRun,
        onTableMounted: _cache[1] || (_cache[1] = ($event) => emit("tableMounted", $event)),
        onItemHover: _cache[2] || (_cache[2] = ($event) => emit("itemHover", $event)),
        onSearch: _cache[3] || (_cache[3] = ($event) => emit("search", $event))
      }, createSlots({
        header: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.titleSection)
          }, [
            hasAiMetadata.value ? (openBlock(), createBlock(unref(N8nRadioButtons), {
              key: 0,
              modelValue: outputMode.value,
              "onUpdate:modelValue": [
                _cache[0] || (_cache[0] = ($event) => outputMode.value = $event),
                onUpdateOutputMode
              ],
              "data-test-id": "ai-output-mode-select",
              options: outputTypes.value
            }, null, 8, ["modelValue", "options"])) : (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(_ctx.$style.title)
            }, toDisplayString(unref(i18n).baseText(outputPanelEditMode.value.enabled ? "ndv.output.edit" : "ndv.output")), 3)),
            hasNodeRun.value && !unref(pinnedData).hasData.value && runsCount.value === 1 ? withDirectives((openBlock(), createBlock(RunInfo, {
              key: 2,
              "task-data": runTaskData.value,
              "has-stale-data": staleData.value,
              "has-pin-data": unref(pinnedData).hasData.value
            }, null, 8, ["task-data", "has-stale-data", "has-pin-data"])), [
              [vShow, !outputPanelEditMode.value.enabled]
            ]) : createCommentVNode("", true)
          ], 2)
        ]),
        "node-not-run": withCtx(() => [
          workflowRunning.value && !isTriggerNode.value ? (openBlock(), createBlock(unref(N8nText), {
            key: 0,
            "data-test-id": "ndv-output-waiting"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.waitingToRun")), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          !workflowRunning.value ? (openBlock(), createBlock(unref(N8nText), {
            key: 1,
            "data-test-id": "ndv-output-run-node-hint"
          }, {
            default: withCtx(() => [
              unref(isSubNodeType2) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.runNodeHintSubNode")), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.runNodeHint")) + " ", 1),
                canPinData.value ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  onClick: insertTestData
                }, [
                  _cache[4] || (_cache[4] = createBaseVNode("br", null, null, -1)),
                  createTextVNode(" " + toDisplayString(unref(i18n).baseText("generic.or")) + " ", 1),
                  createVNode(unref(N8nText), {
                    tag: "a",
                    size: "medium",
                    color: "primary"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.insertTestData")), 1)
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true)
              ], 64))
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ]),
        "node-waiting": withCtx(() => [
          createVNode(unref(N8nText), {
            bold: true,
            color: "text-dark",
            size: "large"
          }, {
            default: withCtx(() => _cache[5] || (_cache[5] = [
              createTextVNode("Waiting for input")
            ])),
            _: 1
          }),
          withDirectives(createVNode(unref(N8nText), null, null, 512), [
            [_directive_n8n_html, unref(waitingNodeTooltip)(node2.value)]
          ])
        ]),
        "no-output-data": withCtx(() => [
          createVNode(unref(N8nText), {
            bold: true,
            color: "text-dark",
            size: "large"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.noOutputData.title")), 1)
            ]),
            _: 1
          }),
          createVNode(unref(N8nText), null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(i18n).baseText("ndv.output.noOutputData.message")) + " ", 1),
              createBaseVNode("a", { onClick: openSettings }, toDisplayString(unref(i18n).baseText("ndv.output.noOutputData.message.settings")), 1),
              createTextVNode(" " + toDisplayString(unref(i18n).baseText("ndv.output.noOutputData.message.settingsOption")), 1)
            ]),
            _: 1
          })
        ]),
        "recovered-artificial-output-data": withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.recoveredOutputData)
          }, [
            createVNode(unref(N8nText), {
              tag: "div",
              bold: true,
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("executionDetails.executionFailed.recoveredNodeTitle")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(N8nText), null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("executionDetails.executionFailed.recoveredNodeMessage")), 1)
              ]),
              _: 1
            })
          ], 2)
        ]),
        _: 2
      }, [
        outputMode.value === "logs" && node2.value ? {
          name: "content",
          fn: withCtx(() => [
            createVNode(RunDataAi, {
              node: node2.value,
              "run-index": _ctx.runIndex,
              workflow: _ctx.workflow
            }, null, 8, ["node", "run-index", "workflow"])
          ]),
          key: "0"
        } : void 0,
        !unref(pinnedData).hasData.value && runsCount.value > 1 ? {
          name: "run-info",
          fn: withCtx(() => [
            createVNode(RunInfo, { "task-data": runTaskData.value }, null, 8, ["task-data"])
          ]),
          key: "1"
        } : void 0
      ]), 1032, ["node", "workflow", "run-index", "linked-runs", "can-link-runs", "too-much-data-title", "no-data-in-branch-message", "is-executing", "executing-message", "push-ref", "block-u-i", "is-production-execution-preview", "is-pane-active", "hide-pagination", "data-output-type", "callout-message"]);
    };
  }
});
const outputTypeSelect = "_outputTypeSelect_1g8bw_128";
const titleSection$1 = "_titleSection_1g8bw_133";
const title$2 = "_title_1g8bw_133";
const noOutputData$1 = "_noOutputData_1g8bw_149";
const recoveredOutputData$1 = "_recoveredOutputData_1g8bw_159";
const style0$6 = {
  outputTypeSelect,
  titleSection: titleSection$1,
  title: title$2,
  noOutputData: noOutputData$1,
  recoveredOutputData: recoveredOutputData$1
};
const cssModules$8 = {
  "$style": style0$6
};
const OutputPanel = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__cssModules", cssModules$8]]);
const _hoisted_1$7 = { key: 0 };
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "InputNodeSelect",
  props: {
    nodes: {},
    workflow: {},
    modelValue: {}
  },
  emits: ["update:model-value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const i18n = useI18n();
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const selectedInputNode = computed(() => workflowsStore.getNodeByName(props.modelValue ?? ""));
    const selectedInputNodeType = computed(() => {
      const node2 = selectedInputNode.value;
      if (!node2) return null;
      return nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
    });
    const inputNodes = computed(
      () => props.nodes.map((node2) => {
        const fullNode = workflowsStore.getNodeByName(node2.name);
        if (!fullNode) return null;
        return {
          node: fullNode,
          type: nodeTypesStore.getNodeType(fullNode.type, fullNode.typeVersion),
          depth: node2.depth
        };
      }).filter(isPresent)
    );
    const activeNode = computed(() => ndvStore.activeNode);
    const activeNodeType = computed(() => {
      const node2 = activeNode.value;
      if (!node2) return null;
      return nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
    });
    const isMultiInputNode = computed(() => {
      const nodeType = activeNodeType.value;
      return nodeType !== null && nodeType.inputs.length > 1;
    });
    const connectedTo = (nodeName) => {
      const connections2 = ndvStore.ndvNodeInputNumber[nodeName];
      if (!connections2) return "";
      if (connections2.length === 1) {
        return `Input ${ndvStore.ndvNodeInputNumber[nodeName]}`;
      }
      return `Inputs ${ndvStore.ndvNodeInputNumber[nodeName].join(", ")}`;
    };
    function getMultipleNodesText(nodeName) {
      if (!nodeName || !isMultiInputNode.value || !activeNode.value || !activeNodeType.value?.inputNames)
        return "";
      const activeNodeConnections = props.workflow.connectionsByDestinationNode[activeNode.value.name].main || [];
      const connectedInputIndexes = activeNodeConnections.reduce((acc, node2, index) => {
        if (node2?.[0] && node2[0].node === nodeName) return [...acc, index];
        return acc;
      }, []);
      const connectedInputs = connectedInputIndexes.map(
        (inputIndex) => activeNodeType.value?.inputNames?.[inputIndex]
      );
      if (connectedInputs.length === 0) return "";
      return `(${connectedInputs.join(" & ")})`;
    }
    function title2(nodeName, length = 30) {
      return truncate(nodeName, length);
    }
    function subtitle2(nodeName, depth) {
      const multipleNodesText = getMultipleNodesText(nodeName);
      if (multipleNodesText) return multipleNodesText;
      return i18n.baseText("ndv.input.nodeDistance", { adjustToNumber: depth });
    }
    function onInputNodeChange(value) {
      emit("update:model-value", value);
    }
    return (_ctx, _cache) => {
      const _component_n8n_option = resolveComponent("n8n-option");
      const _component_n8n_select = resolveComponent("n8n-select");
      return openBlock(), createBlock(_component_n8n_select, {
        "model-value": _ctx.modelValue,
        "no-data-text": unref(i18n).baseText("ndv.input.noNodesFound"),
        placeholder: unref(i18n).baseText("ndv.input.parentNodes"),
        class: normalizeClass(_ctx.$style.select),
        teleported: "",
        size: "small",
        filterable: "",
        "data-test-id": "ndv-input-select",
        "onUpdate:modelValue": onInputNodeChange
      }, {
        prefix: withCtx(() => [
          createVNode(_sfc_main$z, {
            disabled: selectedInputNode.value?.disabled,
            "node-type": selectedInputNodeType.value,
            size: 14,
            shrink: false
          }, null, 8, ["disabled", "node-type"])
        ]),
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(inputNodes.value, ({ node: node2, type, depth }) => {
            return openBlock(), createBlock(_component_n8n_option, {
              key: node2.name,
              value: node2.name,
              class: normalizeClass([_ctx.$style.node, { [_ctx.$style.disabled]: node2.disabled }]),
              label: `${title2(node2.name)} ${getMultipleNodesText(node2.name)}`,
              "data-test-id": "ndv-input-option"
            }, {
              default: withCtx(() => [
                createVNode(_sfc_main$z, {
                  disabled: node2.disabled,
                  "node-type": type,
                  size: 14,
                  shrink: false,
                  class: normalizeClass(_ctx.$style.icon)
                }, null, 8, ["disabled", "node-type", "class"]),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.$style.title)
                }, [
                  createTextVNode(toDisplayString(title2(node2.name)) + " ", 1),
                  node2.disabled ? (openBlock(), createElementBlock("span", _hoisted_1$7, "(" + toDisplayString(unref(i18n).baseText("node.disabled")) + ")", 1)) : createCommentVNode("", true)
                ], 2),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.$style.subtitle)
                }, toDisplayString(connectedTo(node2.name) ? connectedTo(node2.name) : subtitle2(node2.name, depth)), 3)
              ]),
              _: 2
            }, 1032, ["value", "class", "label"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "no-data-text", "placeholder", "class"]);
    };
  }
});
const select = "_select_wv0ev_123";
const node = "_node_wv0ev_132";
const icon = "_icon_wv0ev_140";
const title$1 = "_title_wv0ev_144";
const disabled = "_disabled_wv0ev_153";
const subtitle = "_subtitle_wv0ev_157";
const style0$5 = {
  select,
  node,
  icon,
  title: title$1,
  disabled,
  subtitle
};
const cssModules$7 = {
  "$style": style0$5
};
const InputNodeSelect = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__cssModules", cssModules$7]]);
const _sfc_main$g = {};
const _hoisted_1$6 = {
  width: "112",
  height: "80",
  viewBox: "0 0 112 80",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$6, _cache[0] || (_cache[0] = [
    createStaticVNode('<mask id="mask0_489_46042" style="mask-type:alpha;" maskUnits="userSpaceOnUse" x="0" y="0" width="112" height="80"><rect width="112" height="80" fill="url(#paint0_linear_489_46042)"></rect></mask><g mask="url(#mask0_489_46042)"><rect x="-0.5" width="112" height="80" fill="url(#pattern0)" fill-opacity="0.6"></rect></g><defs><pattern id="pattern0" patternContentUnits="objectBoundingBox" width="1" height="1"><use xlink:href="#image0_489_46042" transform="scale(0.00357143 0.005)"></use></pattern><linearGradient id="paint0_linear_489_46042" x1="90.5" y1="40.4494" x2="112.5" y2="40.4494" gradientUnits="userSpaceOnUse"><stop></stop><stop offset="1" stop-color="white" stop-opacity="0"></stop></linearGradient><image id="image0_489_46042" width="280" height="200" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADICAYAAAAzx/4XAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABhdSURBVHgB7d0JcFTVngbw/72d4IYa0Ie4IK2llgpodNwtB9AaxVILF7ZxynkgWupojaRwASXQGEBqEAI8LXfBpZQS9IFabjMFkXFfijCKyqjQqIiKShCUpdP3vvPdpXP7pjtk6dPdSX+/qlPpJX07UfrL/yz3XEOIPJNiswaZkbKBtkiluC0qRB1gCJW86ntmjzYM81YvWIhyhgFTwlCxGJGyBcJKhTQxhUrSpJraKSpcVgjDhTQqEyo5U+6prbVExmV6TnWT6ixbnuxmSZ262xCLVTUIUTsxYEoMKpdM4aKCZV5ZUmIMFMoljsGUkMk1c9RArjE39HBchcuYadVVdUKUYwyYEjEhVhstj8gqdbMi8HA8kpTBqmqJC5EGHOQtEeVlMkXSw6WB4UK6cQymBKB6UYMso4OPWYZMrWG4kGasYEpAmWGHB3Xj0ydVzRUizRgwJcAwjaFpD9gyVYjygAHTxTndo9Bium2WLBWiPGDAdHFlkWT4/KK6uVzrQnnCgOniDNuIBu/blr1aiPKEAdPF2Xba1DQeYfVCecOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2hhCXc7ll19eUVZWNto0zYFGJDLIamys8J+LRMrilpWst217WSKRqFu6dGlciDRhwHQho0aNilqWVavC4/I2vGyhCpqpDBrSISLUJYwcOfJWFS6vq5vHS9tURiKRcf3795c1a9a8JUQ5xAqmk0N3qLy8/O/q5iDpIMMwlu7evXuMqmYahCgHOMjbyalwWSE5CBdA18o7HlFOsIvUiY0YMaJWfWnLeEtr9FbdpQrVXXpDiDqIXaROavjw4aPVlwWiiapmBi9ZsqROiDqAXaTOa4popMZjtIUXlQ4GTCfkVS9R0SvqvQ9RuzFgOqe/Sn7k632oi+IYTCfjTUtvkTxJJBI9OG1N7cUKppMpKyurlDzK9/tR18KA6Xzy+oG3LCsqRO3EgOl8KiSPTNOMClE7MWCISJsyIUcsVlvRGJEVhm3Nq5k8fqEUr3wPuHKAl9qNFYwnFqtqMND9MMwF1TW16yfXzLl1Qqw2KkXGtu245Fe9ELUTAybAaPprHbXFmFsekfXV02oX3BX7r6KZSUkmk3WSR42NjQwYajcGTIBl2aubPWjL6EikfJWqalZU3zN7tBSYtyalTvJAVUt1XANDHcExmDTofmRdezhIdZ8GqaCZYog9d3fSWDYzVhWXwnhScrRFQ0sMw3hSiDqAFUyAZUi8Fd9W8O5TIpFYqr7ERa/44sWLFwpRBzBggiJm28YbCtR9QrfFsqwq0WuqEHUQz0UKwFR1MiIdOc8nns/u01VXXTXXNM1bJcdUeM174YUXxglRBzFgQlQ1goDp+GpZQxYmGxPzZsTu0DYL4534iC0uc9lNq1ddo1OEKAfYRQoYpyoYI1djG6r7ZEbKF+CYogm6Smo8ZjA265YcwHFwPCHKkZKrYPCB31cSUTEjlaYtUSNi9rVtqTTcqiUqOWKLzCtLql5XrCov07zDhg2LqYBo9y53akq6asmSJXOFKIe6ZMDEYvdGG6W80jKNioiYJ6vfUs38qDBxA0T7yYJqNqpq+qSqvH9YceG1xsZGBE1bNorihddIm04ZMMEqJILAMFWI2E5wYCwiKoUTV0E2Zlp1VZ0UEIImmUwOUjeHRiKRSnU76j9nlpU1WI2NdapieUuF0UIupCOdijZgUIXslkhFhq5MVPRWIQ3tOb4KlnrVJboiVrjFdxlNmjo7ZphmqutkW9bUaVPGx4QoDwq6ktfvyhimEVV/W/uiKyNuFVKRVC110SbEoJ2zNGywMZ1sSL2dtLdahlFvGtKgwqEe4aCmqqNqqnp9Ww6Y7/EWos5Ca8Bk6cpExa1CoipEdJVQ6Ko0uCFibbAMM94tIvWSkPieQgAho6aqpbUKNd5C1Bl0OGCaDaiaUpHelSlv+mZbcimuWr1t2RvUoGbcNiSOKkQ91pCDSiIuex7LccZbVLjUhR5vT2bm9r8MUZHYY8CgCqmQnRVZujKpKiTVnclTV0b0QlBFsz2ZZbzFCH0N3w4dIo3Riu/Z0+NERScVMM5Je1nWhiRlb21dGcGHWQWHWLJahVVDa7syOjlVkZn5Nw6Nt4S/yQg0LGJECJ+n2nGqdVPtO9XeUW2lagnZw4+R4bYdeE8GDRW9VMCURcoX2PhA5HhA1WvNujLFNtsSZBjetg12+mfYErtq+uTx86QpQFIvkab/ZOgTnqlajWpniBssQY2qrVJtumornMOK9BQ3jE5XrY9q3VXbodo61d5U7TPVtgeO4QcNQ4aKWipgsNmS+qvdnnNaAl2ZtAHVhmIOkZbYKmCM9HCJJ3bvGjtz2sT/FffDv7e4/+3wTegl7lJtt3f/JHHD5VzVjH333Ve6deuGZfjYHU62b99eZts2gmS+ajHVvlZtjGqjVNsnw4+DkxkfVW2OapuF1Qx1IoExmBY3W1LPFV9XRhcracUjpulUMKq8WP3Lr1uGPzx/Gk6CPFu1gaqdrNrB4lYjP6n2iWr/p9pG1W5X7Z9UM4499li59NJL5ZRTTnFC5ssvv5Tly5fL+++/L7t370alMkO1TaqdYqr36969uxx44IG42Bm2xpStW7fK77//fqAKpPHiVkYIpR+897Wl5WBh6FDBNQWMaSJAFhZgQLXYGNbO5AZzn4gkLWv+199+O23xgr/tpR7/V9VuUK1fhtdcLW43BhXOaart07NnT5kzZ44MGTLECQxABTN06FAZM2aM1NfXI817oyFcEEbnn3++DBgwwAmZbdu2yTvvvCNvvPGGbN68WRVU9s3ijt9sFbdqOki1fcUNEoTfL9I0rhOsbogKJhUw06qrcEZuTs7K7exmzpy49a7qe8feWzPxKXErh39TrVq1ngiLCjWv1qNHD+ybggpDGhoasMtcf/X8ieJ9sC+88EI599xzU+ECuH3MMcfIyJEjETCpxw8++GCpqqqSa665RtCl8g0fPlzuuusuWbRoEaoZHOhKcSumY8Ttgh0pbjWD6ul/xJ39+i3wq7CKoYLinrzpUlPNM9xwwQAtQuM/VeuJILjgggucdvTRRzsVyTfffCPLli2T9957D1VHauD3zDPPdLpFYfvtt5+cdtppTpD8+eefzmP9+vWTgQMHpoULoAq69tpr5e2333a6S8r54obLaaHDXqTaNar9TbUnVPtVguGC8SSDBQ3lHwOmueA0MwZdMRN01D777COnnnqq1NTUON2ZIHRr7rzzTidkfAcddJBEIpHmB1cfdARV37595YsvvnAeQ0X0l7/8JeMPc8IJJ8ghhxwin3/+ObZU6KUe6uUfPxqNyo4dO2TdunXGzp07D1UP/4dq34hbiWJ2Cq8x8J4MGSoEbjjVJLhQLhgwGNB1xkVQuYTDBc444ww5++yz5YADDkg9tv/++zthkgnCChUQIITQ3cLxM8FxjjrqKCkvb1oRjdCZMWOGzJs3zxnnufrqq3ENaTyFMZ1LxR2ANv3fif0kKhRWMOnCC+XQMMDrjJ+EuzC+vfbay+n2YEB2zZo1zmP+1HQme++9t1OV+LdRwQTHasJQ7SBg1MyTc//mm2+W66+/3jk+xoHw3GuvvSabNm3CQfp4zRmLsdWkO+sWKhRWMJkFF9JhdsYZL9m4cWPWF5x++ulOpeGHSksBg0BCFwdQoWTrHvmOOOKIVAWDMBoxYkTq2KhcevXq5by3Zz9xK5iI83uoAEL3yKlibNYylF8MmHTh6sWfoXEGWT/99NPUwGwYxkMwJY1qA10m3M80BgPoEmGGqbKy0hkMRmsJxn4wOIxQwXuEAwlhhuDx74obMs7vkFRjMIwVKhR2kVzBpf7BbhICZr1qW5LJZA/MGK1du9ZZOBeGLs5ll13mTEPj9mGHHeaPizSDQBg8eLAzZoNqpn///tISjPvMmjVLNmzYIIMGDWr2PN4Hx/Eg1RAyTsBgkDdVubCzRHnGgMkcLH4Fg9vbxK1iBm7evNlZhZspYODII4902h7fUH3QES4ImdbA2M+wYcOcGSNUMpkEwsw/uT01yEtUKKXeRco0c4SG2ZgrVLtRtb+KNxGDBXXvvvsuVtZKvmEMBqGUrdsVkgpIO5k0/HMK2FWifCvlCiZT5YJp6RGqjVXtEO++3+Vwzg/CepS6ujpnlW2RMkKNqGBYwTRVLvuLe8byveIurouKGzKYkUktcME09EsvveSvrC16lhAVTqlWMMHqxe9O3CbuuT7OdMzxxx/vnAmNLsknn3wiK1eudNah7Nq1ywmZVatWZRxwLQScsrBz507/LjIFJz2ygqGCK+Uukj8Iiq/YcW6keOFyww03yN133+2sUcHgKaqV5557TqZOnepMU3/77bfO1gvFEjDougWmzxEuu4WoCJRiwGSaLbpANWdxyVlnnSUPPfRQ2gswuDp27Fhn1ezEiROdr63xww8/yPr16+Wcc85ptugOA8aYkcIpAlg3Ex68xZQ0zrg++eSTpU+fPi0O7qKCCXTZEC47hKgIlOoYTDBk8MnFMlhnqewll1yS8QVYeYvl+Y8++qjMnDnTmTZuCVb94gzp8847T6qrq9OeQxg888wzcvHFF8tNN90kL7/8ctrzv/zyi0yYMEGuvPJKufHGG+Wrr75q8b3QbcNrPOgrdY4BIurySrmCQbj660XKvcdSS/gzwXPXXXedtAbGabBXjG3bznYLQVjP8v333zu3f/vtN6fLFYSw2LJli1Mpff3119hms8X3QsD8+uuv/l30lRAwzsw0l2pTIZXav7/wJUX8CuYP8SZc8IHvTBBgCKA//vjDuStuBfO7EBWBUvwDF5xd8cdgUttNrlu3TjqTRCIh8Xg8dVfczaawCTnX1VHBlXIFHewqob/iBAy6NnYnOusYAYOBZA+ql58leOUBNQvGVXdUKFxo58In1Pmrj5W6GP/o8IEDs0aYRtYFa3NwlrcH/SR/TwlWMFRwpV7B+PChxEhrI3bzf/7556WjsGudHzLZtnjoKExPYzr7448/9h/CANL/S9OpR9gvk0FDBVPKARP84KHEeEu89SNPPPFEh09oxJYNfsDoqmAwsPvqq6/6U9T42dHVQ1Cmn9+In4NbNVABlGLAhK/57DcsRomrlvzoo4/kvvvuS21RWawwIP3444/7dzG4i8vMImgwI8YTqKngSi1ggpdd9ZvlNVwxEbvxO4tO8MFdunRpq1ft5hsGonH6gjfrhSTEJWhxWYNguLCLRAVV6l0kS9JD5lVxr87oLFybPXu2rFixQnINXSd/gygERXtCDCdfPvvss/5d9JH+W7Ufpel3SS20S80gsZtEeVaqXaRgwwCJ5X3FwMsDqq3CN+JcICzz/+CDDySXcF6Rv8UlBmrb2hVbvXq1cyVIbxNyTK9jqTACxgo1VjBUUKVawQS7R37I+A19DlwhcR0++NiWAdce+uyzzySXgicvtqWCQWU1efJk5+cS9+fHz/uCuDNIflimmmFGbFYuVCilXMH4H0L/Q9no3cbXD1Wbr9pm7LPyyiuvSG1tbcFX+SKIHnzwQXn99df9hzCw+4i4ewYHQ5KDvFQUSn0Mxg+a4IcTAYM+CwZfZqm2BetYsDYGlcN3333XqoMfeuihqbUwuMJAEK4qgEuXADb0Dp9giX1ounfv7rwWx8HF2QAXV3vssceCXaoHxb3o/W7v5/ZD0g9PB8dfqFBatYN0F5TppMdwQ/g0iLv0/sxEIlGOcEFFc+KJJ2a91KsPwYFrUGNnPGy5cPjhh6eewxoZvB7PY9OqK664wgkVHwIFe9DgciWjRo2Sk046yTkDe/z48c64kKdO3IDBVQ8QLAlJr8KcKmbg4Iv+WQXVoFTA2PZbK+verBOiPCjVHe0QHn6I+GMwqOYS3vP+SZAIl9dU66Vme67fsmVL+YIFC+Tnn3+W6dOnOxdZywZVysiRI51qI3ypEYy/IHjuuOOO8DWNUq+96KKLnMua4Htx//777xesz/HOk8Ks0Qxxt2VISnq4sItERaPUr4sUnk0KngDp38bWB4vFvUb1v2/durUcm36j4sBMznHHHZf14AiOcHgEZbvWNaDK8a9XjbGXxYsXC05j8Dyh2iZp6hZlC5emlbxEBVDKAROsYvzxiuAVHYMnIP+k2jOq7VIVxLXbt2/f++mnn3bOMbrttttkwIABohO23sSWDN5sE6qVl6SpagmHS7ARFVSpn02daU1MIktDyDyl2gMqZLbhPKCnnnpKbr/9dmeLh/ZAcNxyyy3Su3dv6devnzz88MPBKiUF2zFg1zoPRpl/C/1smWaQRNhFogLjpWObPoTBv/jB7pIEvqK7hDUn+LTfotoBb775pnOdJAziBi5Av0c//vijzJ8/Xx544AHn/k8//SRTpkxxFt5hn97gda2xQXjghMmNkh4o4XDh+AsVDW7Zmnm62p+V8S8BEqwWMLD6d9UeVu1nDLouX77cuYxJa2FbTgQTAsZ7b6e7g5BZtGiRfPjhh2lnYKN6CWyCtUOyj70EqxeigmPAuIJdinDQBMPGb9jg5RPVPseLsGQfVUZrYYOoWbNmOVPP4p5cWe8dy8a1r1ER4Zh+qIQueWJK5vEWW9g1oiLDLlKTTFPXRuh5/3vQsO2ds7k2LkPiX4wNMLUcvg4SwgLbW2ItDS7g5p16gLDCiU4LVTtBtR5qILcPVuuiizRkyBBnvQwqG7zWg+s3ZQsXdo2oqDBg0vkBgg+tXymINL9YW3DTcKfL88gjj8iLL77oBAMWygXHUABjK9iKEwHj7aGLY8dVW6baN+IO3PZW7SpVDVXgTO4lS5Y44zp4XWBXvL7e+zJYqOgxYJoLhox4t4NB4y/CA2clNFb34vrVbYBuF1IG+898JE1ncmO7CKzK+xd1zB5r167N1IXtJu51nFi9UNFjwGQWDhlfsILBtDVOisSJRPuGno9I8038cUzMPmHnf8wEYd+ZleKGjR8MOJtyobhbX1aqdqB3LASQf0lY7PD9hzBYqBNgwGQXDBm/e+QP/vrXUkIFgg98T0m/UmQ3aQqi4DQ4ggELXbBvrn/1xeDMD74f4YNFfW94x8WxEt7rMO6zSTKfDsCQoaLDgGlZeLVveJUvQgZBgS5LRJoCxsxwnEzbRPiDyb5gFwxVzEbJvAgwKaxgqBNgwLROOBwQMqb31YcP/Z4CxsrS/IDwqx5T0isgW9L3rOGCOuoUGDB7FuyCBM9bagw8jsf8cMk2/tJSwPiCYzzB2apM+9bwrGkqegyY1guGCzQGHiuTpqom05VagwETDppgQISnws0Mr/cXAPK8Iyp6DJjWC6/2Dd72181ASwETrmQyVR/h7SLCxwhu88kxGCpqDJjWCa/ytaR5WIR3xAu/Pjzj01LA7Cmk2DWiToEB03Z+mJiB28GAEckcMMHbVuhxO/S6TCHlf1+msGLQUFFiwLSeX8X4ty1pHiit2TouU7cmU8BI6Lad5StR0WLAtE0wCMKDs209RkvPtTY8GDJU1Bgw7WNnuW+04TVEXR4DJrcYIkQB3HCKiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBdnGFI2gWbjIjZV4jyhAHTxdmGHU9/QKJClCcMmC6uLBmpDz1UOS5W2/qLaBN1AAOmi4vFquLiXuDNV7GfaY0WojxgwJQA27KeDN43DXOoEOUBA6YElNnmwtBDg6rvmT1OiDRjwJQAdJNssdOqGDHMKRNitVEh0ogBUyLKkkZMfQlOWVeUR2QFQ4Z0YsCUCGew15CpoYejCJlJNbWDhEiDtmz1SF2ACpOY+p8+pdkThixMNMrUme6sE1FOMGBK0KSaOXMNMW7N8vRSNe20LGkl62fE7qgXog5gwJSorJUMUQ4xYEoYxl7UP4AF6mZUiDRgwJBU31M7Wv1LQDUTFaIcYsBQSmx6bWVjo3W5mOZAww2bqBB1wD8AobUpv0xPqN8AAAAASUVORK5CYII="></image></defs>', 3)
  ]));
}
const WireMeUp = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$1]]);
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "InputPanel",
  props: {
    runIndex: {},
    workflow: {},
    pushRef: {},
    currentNodeName: { default: "" },
    canLinkRuns: { type: Boolean, default: false },
    linkedRuns: { type: Boolean },
    readOnly: { type: Boolean, default: false },
    isProductionExecutionPreview: { type: Boolean, default: false },
    isPaneActive: { type: Boolean, default: false }
  },
  emits: ["itemHover", "tableMounted", "linkRun", "unlinkRun", "runChange", "search", "changeInputNode", "execute", "activatePane"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const i18n = useI18n();
    const telemetry = useTelemetry();
    const showDraggableHintWithDelay = ref(false);
    const draggableHintShown = ref(false);
    const mappedNode2 = ref(null);
    const inputModes = [
      { value: "mapping", label: i18n.baseText("ndv.input.mapping") },
      { value: "debugging", label: i18n.baseText("ndv.input.debugging") }
    ];
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const workflowsStore = useWorkflowsStore();
    const uiStore = useUIStore();
    const {
      activeNode,
      focusedMappableInput,
      isMappingOnboarded: isUserOnboarded
    } = storeToRefs(ndvStore);
    const rootNode = computed(() => {
      if (!activeNode.value) return null;
      return props.workflow.getChildNodes(activeNode.value.name, "ALL").at(0) ?? null;
    });
    const hasRootNodeRun = computed(() => {
      return !!(rootNode.value && workflowsStore.getWorkflowExecution?.data?.resultData.runData[rootNode.value]);
    });
    const inputMode = ref(
      // Show debugging mode by default only when the node has already run
      activeNode.value && workflowsStore.getWorkflowExecution?.data?.resultData.runData[activeNode.value.name] ? "debugging" : "mapping"
    );
    const isMappingMode = computed(() => isActiveNodeConfig.value && inputMode.value === "mapping");
    const showDraggableHint = computed(() => {
      const toIgnore = [START_NODE_TYPE, MANUAL_TRIGGER_NODE_TYPE, CRON_NODE_TYPE, INTERVAL_NODE_TYPE];
      if (!currentNode.value || toIgnore.includes(currentNode.value.type)) {
        return false;
      }
      return !!focusedMappableInput.value && !isUserOnboarded.value;
    });
    const isActiveNodeConfig = computed(() => {
      let inputs = activeNodeType.value?.inputs ?? [];
      let outputs2 = activeNodeType.value?.outputs ?? [];
      if (props.workflow && activeNode.value) {
        const node2 = props.workflow.getNode(activeNode.value.name);
        if (node2 && activeNodeType.value) {
          inputs = getNodeInputs(props.workflow, node2, activeNodeType.value);
          outputs2 = getNodeOutputs(props.workflow, node2, activeNodeType.value);
        }
      }
      if (!Array.isArray(inputs)) {
        inputs = [];
      }
      if (!Array.isArray(outputs2)) {
        outputs2 = [];
      }
      return inputs.length === 0 || inputs.every((input) => filterOutConnectionType(input, NodeConnectionType.Main)) && outputs2.find((output) => filterOutConnectionType(output, NodeConnectionType.Main));
    });
    const isMappingEnabled = computed(() => {
      if (props.readOnly) return false;
      if (isActiveNodeConfig.value) return isMappingMode.value && mappedNode2.value !== null;
      return true;
    });
    const isExecutingPrevious = computed(() => {
      if (!workflowRunning.value) {
        return false;
      }
      const triggeredNode = workflowsStore.executedNode;
      const executingNode = workflowsStore.executingNode;
      if (activeNode.value && triggeredNode === activeNode.value.name && workflowsStore.isNodeExecuting(props.currentNodeName)) {
        return true;
      }
      if (executingNode.length || triggeredNode) {
        return !!parentNodes.value.find(
          (node2) => workflowsStore.isNodeExecuting(node2.name) || node2.name === triggeredNode
        );
      }
      return false;
    });
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const rootNodesParents = computed(() => {
      if (!rootNode.value) return [];
      return props.workflow.getParentNodesByDepth(rootNode.value);
    });
    const currentNode = computed(() => {
      if (isActiveNodeConfig.value) {
        if (mappedNode2.value) {
          return workflowsStore.getNodeByName(mappedNode2.value);
        }
        return activeNode.value;
      }
      return workflowsStore.getNodeByName(props.currentNodeName ?? "");
    });
    const connectedCurrentNodeOutputs = computed(() => {
      const search2 = parentNodes.value.find(({ name }) => name === props.currentNodeName);
      return search2?.indicies;
    });
    const parentNodes = computed(() => {
      if (!activeNode.value) {
        return [];
      }
      const parents = props.workflow.getParentNodesByDepth(activeNode.value.name).filter((parent) => parent.name !== activeNode.value?.name);
      return uniqBy(parents, (parent) => parent.name);
    });
    const currentNodeDepth = computed(() => {
      const node2 = parentNodes.value.find(
        (parent) => currentNode.value && parent.name === currentNode.value.name
      );
      return node2?.depth ?? -1;
    });
    const activeNodeType = computed(() => {
      if (!activeNode.value) return null;
      return nodeTypesStore.getNodeType(activeNode.value.type, activeNode.value.typeVersion);
    });
    const waitingMessage = computed(() => {
      const parentNode = parentNodes.value[0];
      return parentNode && waitingNodeTooltip(workflowsStore.getNodeByName(parentNode.name));
    });
    watch(
      inputMode,
      (mode) => {
        onRunIndexChange(-1);
        if (mode === "mapping") {
          onUnlinkRun();
          mappedNode2.value = rootNodesParents.value[0]?.name ?? null;
        } else {
          mappedNode2.value = null;
        }
      },
      { immediate: true }
    );
    watch(showDraggableHint, (curr, prev) => {
      if (curr && !prev) {
        setTimeout(() => {
          if (draggableHintShown.value) {
            return;
          }
          showDraggableHintWithDelay.value = showDraggableHint.value;
          if (showDraggableHintWithDelay.value) {
            draggableHintShown.value = true;
            telemetry.track("User viewed data mapping tooltip", {
              type: "unexecuted input pane"
            });
          }
        }, 1e3);
      } else if (!curr) {
        showDraggableHintWithDelay.value = false;
      }
    });
    function filterOutConnectionType(item, type) {
      if (!item) return false;
      return typeof item === "string" ? item !== type : item.type !== type;
    }
    function onInputModeChange(val) {
      inputMode.value = val;
    }
    function onMappedNodeSelected(val) {
      mappedNode2.value = val;
      onRunIndexChange(0);
      onUnlinkRun();
    }
    function onNodeExecute() {
      emit("execute");
      if (activeNode.value) {
        telemetry.track("User clicked ndv button", {
          node_type: activeNode.value.type,
          workflow_id: workflowsStore.workflowId,
          push_ref: props.pushRef,
          pane: "input",
          type: "executePrevious"
        });
      }
    }
    function onRunIndexChange(run) {
      emit("runChange", run);
    }
    function onLinkRun() {
      emit("linkRun");
    }
    function onUnlinkRun() {
      emit("unlinkRun");
    }
    function onSearch(search2) {
      emit("search", search2);
    }
    function onItemHover(item) {
      emit("itemHover", item);
    }
    function onTableMounted(event) {
      emit("tableMounted", event);
    }
    function onInputNodeChange(value) {
      const index = parentNodes.value.findIndex((node2) => node2.name === value) + 1;
      emit("changeInputNode", value, index);
    }
    function onConnectionHelpClick() {
      if (activeNode.value) {
        telemetry.track("User clicked ndv link", {
          node_type: activeNode.value.type,
          workflow_id: workflowsStore.workflowId,
          push_ref: props.pushRef,
          pane: "input",
          type: "not-connected-help"
        });
      }
    }
    function activatePane() {
      emit("activatePane");
    }
    return (_ctx, _cache) => {
      const _component_i18n_t = resolveComponent("i18n-t");
      const _directive_n8n_html = resolveDirective("n8n-html");
      return openBlock(), createBlock(RunData, {
        node: currentNode.value,
        nodes: isMappingMode.value ? rootNodesParents.value : parentNodes.value,
        workflow: _ctx.workflow,
        "run-index": isMappingMode.value ? 0 : _ctx.runIndex,
        "linked-runs": _ctx.linkedRuns,
        "can-link-runs": !mappedNode2.value && _ctx.canLinkRuns,
        "too-much-data-title": unref(i18n).baseText("ndv.input.tooMuchData.title"),
        "no-data-in-branch-message": unref(i18n).baseText("ndv.input.noOutputDataInBranch"),
        "is-executing": isExecutingPrevious.value,
        "executing-message": unref(i18n).baseText("ndv.input.executingPrevious"),
        "push-ref": _ctx.pushRef,
        "override-outputs": connectedCurrentNodeOutputs.value,
        "mapping-enabled": isMappingEnabled.value,
        "distance-from-active": currentNodeDepth.value,
        "is-production-execution-preview": _ctx.isProductionExecutionPreview,
        "is-pane-active": _ctx.isPaneActive,
        "pane-type": "input",
        "data-test-id": "ndv-input-panel",
        onActivatePane: activatePane,
        onItemHover,
        onLinkRun,
        onUnlinkRun,
        onRunChange: onRunIndexChange,
        onTableMounted,
        onSearch
      }, createSlots({
        header: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.titleSection)
          }, [
            createBaseVNode("span", {
              class: normalizeClass(_ctx.$style.title)
            }, toDisplayString(unref(i18n).baseText("ndv.input")), 3),
            isActiveNodeConfig.value && !_ctx.readOnly ? (openBlock(), createBlock(unref(N8nRadioButtons), {
              key: 0,
              "data-test-id": "input-panel-mode",
              options: inputModes,
              "model-value": inputMode.value,
              "onUpdate:modelValue": onInputModeChange
            }, null, 8, ["model-value"])) : createCommentVNode("", true)
          ], 2)
        ]),
        "input-select": withCtx(() => [
          parentNodes.value.length && _ctx.currentNodeName ? (openBlock(), createBlock(InputNodeSelect, {
            key: 0,
            "model-value": _ctx.currentNodeName,
            workflow: _ctx.workflow,
            nodes: parentNodes.value,
            "onUpdate:modelValue": onInputNodeChange
          }, null, 8, ["model-value", "workflow", "nodes"])) : createCommentVNode("", true)
        ]),
        "node-not-run": withCtx(() => [
          isActiveNodeConfig.value && rootNode.value || parentNodes.value.length ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.$style.noOutputData)
          }, [
            isMappingEnabled.value || hasRootNodeRun.value ? (openBlock(), createBlock(unref(N8nText), {
              key: 0,
              tag: "div",
              bold: true,
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.noOutputData.title")), 1)
              ]),
              _: 1
            })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createVNode(unref(N8nText), {
                tag: "div",
                bold: true,
                color: "text-dark",
                size: "large"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.rootNodeHasNotRun.title")), 1)
                ]),
                _: 1
              }),
              createVNode(unref(N8nText), {
                tag: "div",
                color: "text-dark",
                size: "medium"
              }, {
                default: withCtx(() => [
                  createVNode(_component_i18n_t, {
                    tag: "span",
                    keypath: "ndv.input.rootNodeHasNotRun.description"
                  }, {
                    link: withCtx(() => [
                      createBaseVNode("a", {
                        href: "#",
                        "data-test-id": "switch-to-mapping-mode-link",
                        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => onInputModeChange("mapping"), ["prevent"]))
                      }, toDisplayString(unref(i18n).baseText("ndv.input.rootNodeHasNotRun.description.link")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ], 64)),
            !_ctx.readOnly ? (openBlock(), createBlock(unref(N8nTooltip), {
              key: 2,
              visible: showDraggableHint.value && showDraggableHintWithDelay.value
            }, {
              content: withCtx(() => [
                withDirectives(createBaseVNode("div", null, null, 512), [
                  [
                    _directive_n8n_html,
                    unref(i18n).baseText("dataMapping.dragFromPreviousHint", {
                      interpolate: { name: unref(focusedMappableInput) }
                    })
                  ]
                ])
              ]),
              default: withCtx(() => [
                createVNode(_sfc_main$u, {
                  type: "secondary",
                  "hide-icon": "",
                  transparent: true,
                  "node-name": (isActiveNodeConfig.value ? rootNode.value : _ctx.currentNodeName) ?? "",
                  label: unref(i18n).baseText("ndv.input.noOutputData.executePrevious"),
                  class: "mt-m",
                  "telemetry-source": "inputs",
                  "data-test-id": "execute-previous-node",
                  onExecute: onNodeExecute
                }, null, 8, ["node-name", "label"])
              ]),
              _: 1
            }, 8, ["visible"])) : createCommentVNode("", true),
            !_ctx.readOnly ? (openBlock(), createBlock(unref(N8nText), {
              key: 3,
              tag: "div",
              size: "small"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.noOutputData.hint")), 1)
              ]),
              _: 1
            })) : createCommentVNode("", true)
          ], 2)) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.$style.notConnected)
          }, [
            createBaseVNode("div", null, [
              createVNode(WireMeUp)
            ]),
            createVNode(unref(N8nText), {
              tag: "div",
              bold: true,
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.notConnected.title")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(N8nText), { tag: "div" }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.notConnected.message")) + " ", 1),
                createBaseVNode("a", {
                  href: "https://docs.n8n.io/workflows/connections/",
                  target: "_blank",
                  onClick: onConnectionHelpClick
                }, toDisplayString(unref(i18n).baseText("ndv.input.notConnected.learnMore")), 1)
              ]),
              _: 1
            })
          ], 2))
        ]),
        "node-waiting": withCtx(() => [
          createVNode(unref(N8nText), {
            bold: true,
            color: "text-dark",
            size: "large"
          }, {
            default: withCtx(() => _cache[2] || (_cache[2] = [
              createTextVNode("Waiting for input")
            ])),
            _: 1
          }),
          withDirectives(createVNode(unref(N8nText), null, null, 512), [
            [_directive_n8n_html, waitingMessage.value]
          ])
        ]),
        "no-output-data": withCtx(() => [
          createVNode(unref(N8nText), {
            tag: "div",
            bold: true,
            color: "text-dark",
            size: "large"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(i18n).baseText("ndv.input.noOutputData")), 1)
            ]),
            _: 1
          })
        ]),
        "recovered-artificial-output-data": withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.recoveredOutputData)
          }, [
            createVNode(unref(N8nText), {
              tag: "div",
              bold: true,
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("executionDetails.executionFailed.recoveredNodeTitle")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(N8nText), null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n).baseText("executionDetails.executionFailed.recoveredNodeMessage")), 1)
              ]),
              _: 1
            })
          ], 2)
        ]),
        _: 2
      }, [
        isMappingMode.value ? {
          name: "before-data",
          fn: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent("style"), null, {
              default: withCtx(() => _cache[1] || (_cache[1] = [
                createTextVNode("button.linkRun { display: none }")
              ])),
              _: 1
            })),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.mappedNode)
            }, [
              createVNode(InputNodeSelect, {
                "model-value": mappedNode2.value,
                workflow: _ctx.workflow,
                nodes: rootNodesParents.value,
                "onUpdate:modelValue": onMappedNodeSelected
              }, null, 8, ["model-value", "workflow", "nodes"])
            ], 2)
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["node", "nodes", "workflow", "run-index", "linked-runs", "can-link-runs", "too-much-data-title", "no-data-in-branch-message", "is-executing", "executing-message", "push-ref", "override-outputs", "mapping-enabled", "distance-from-active", "is-production-execution-preview", "is-pane-active"]);
    };
  }
});
const mappedNode = "_mappedNode_48j1a_123";
const titleSection = "_titleSection_48j1a_127";
const inputModeTab = "_inputModeTab_48j1a_136";
const noOutputData = "_noOutputData_48j1a_140";
const recoveredOutputData = "_recoveredOutputData_48j1a_147";
const notConnected = "_notConnected_48j1a_156";
const title = "_title_48j1a_127";
const style0$4 = {
  mappedNode,
  titleSection,
  inputModeTab,
  noOutputData,
  recoveredOutputData,
  notConnected,
  title
};
const cssModules$6 = {
  "$style": style0$4
};
const InputPanel = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__cssModules", cssModules$6]]);
const _hoisted_1$5 = { key: "empty" };
const _hoisted_2$4 = { key: "listening" };
const _hoisted_3$2 = { key: 0 };
const _hoisted_4$2 = { key: 1 };
const _hoisted_5$2 = { key: 0 };
const _hoisted_6$2 = { key: "default" };
const _hoisted_7$1 = {
  key: 0,
  class: "mb-xl"
};
const _hoisted_8$1 = ["textContent"];
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "TriggerPanel",
  props: {
    nodeName: {},
    pushRef: { default: "" }
  },
  emits: ["activate", "execute"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const nodesTypeStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const workflowsStore = useWorkflowsStore();
    const ndvStore = useNDVStore();
    const router = useRouter();
    const workflowHelpers = useWorkflowHelpers({ router });
    const i18n = useI18n();
    const telemetry = useTelemetry();
    const executionsHelpEventBus = createEventBus();
    const help = ref(null);
    const node2 = computed(() => workflowsStore.getNodeByName(props.nodeName));
    const nodeType = computed(() => {
      if (node2.value) {
        return nodesTypeStore.getNodeType(node2.value.type, node2.value.typeVersion);
      }
      return null;
    });
    const triggerPanel = computed(() => {
      const panel = nodeType.value?.triggerPanel;
      if (isTriggerPanelObject(panel)) {
        return panel;
      }
      return void 0;
    });
    const hideContent = computed(() => {
      const hideContent2 = triggerPanel.value?.hideContent;
      if (typeof hideContent2 === "boolean") {
        return hideContent2;
      }
      if (node2.value) {
        const hideContentValue = workflowHelpers.getCurrentWorkflow().expression.getSimpleParameterValue(node2.value, hideContent2, "internal", {});
        if (typeof hideContentValue === "boolean") {
          return hideContentValue;
        }
      }
      return false;
    });
    const hasIssues2 = computed(() => {
      return Boolean(
        node2.value?.issues && (node2.value.issues.parameters ?? node2.value.issues.credentials)
      );
    });
    const serviceName = computed(() => {
      if (nodeType.value) {
        return getTriggerNodeServiceName(nodeType.value);
      }
      return "";
    });
    const displayChatButton = computed(() => {
      return Boolean(
        node2.value && node2.value.type === CHAT_TRIGGER_NODE_TYPE && node2.value.parameters.mode !== "webhook"
      );
    });
    const isWebhookNode = computed(() => {
      return Boolean(node2.value && node2.value.type === WEBHOOK_NODE_TYPE);
    });
    const webhookHttpMethod = computed(() => {
      if (!node2.value || !nodeType.value?.webhooks?.length) {
        return void 0;
      }
      const httpMethod = workflowHelpers.getWebhookExpressionValue(
        nodeType.value.webhooks[0],
        "httpMethod",
        false
      );
      if (Array.isArray(httpMethod)) {
        return httpMethod.join(", ");
      }
      return httpMethod;
    });
    const webhookTestUrl = computed(() => {
      if (!node2.value || !nodeType.value?.webhooks?.length) {
        return void 0;
      }
      return workflowHelpers.getWebhookUrl(nodeType.value.webhooks[0], node2.value, "test");
    });
    const isWebhookBasedNode = computed(() => {
      return Boolean(nodeType.value?.webhooks?.length);
    });
    const isPollingNode = computed(() => {
      return Boolean(nodeType.value?.polling);
    });
    const isListeningForEvents = computed(() => {
      const waitingOnWebhook = workflowsStore.executionWaitingForWebhook;
      const executedNode = workflowsStore.executedNode;
      return !!node2.value && !node2.value.disabled && isWebhookBasedNode.value && waitingOnWebhook && (!executedNode || executedNode === props.nodeName);
    });
    const workflowRunning = computed(() => {
      return uiStore.isActionActive["workflowRunning"];
    });
    const isActivelyPolling = computed(() => {
      const triggeredNode = workflowsStore.executedNode;
      return workflowRunning.value && isPollingNode.value && props.nodeName === triggeredNode;
    });
    const isWorkflowActive = computed(() => {
      return workflowsStore.isWorkflowActive;
    });
    const listeningTitle = computed(() => {
      return nodeType.value?.name === FORM_TRIGGER_NODE_TYPE ? i18n.baseText("ndv.trigger.webhookNode.formTrigger.listening") : i18n.baseText("ndv.trigger.webhookNode.listening");
    });
    const listeningHint = computed(() => {
      switch (nodeType.value?.name) {
        case CHAT_TRIGGER_NODE_TYPE:
          return i18n.baseText("ndv.trigger.webhookBasedNode.chatTrigger.serviceHint");
        case FORM_TRIGGER_NODE_TYPE:
          return i18n.baseText("ndv.trigger.webhookBasedNode.formTrigger.serviceHint");
        default:
          return i18n.baseText("ndv.trigger.webhookBasedNode.serviceHint", {
            interpolate: { service: serviceName.value }
          });
      }
    });
    const header2 = computed(() => {
      if (isActivelyPolling.value) {
        return i18n.baseText("ndv.trigger.pollingNode.fetchingEvent");
      }
      if (triggerPanel.value?.header) {
        return triggerPanel.value.header;
      }
      if (isWebhookBasedNode.value) {
        return i18n.baseText("ndv.trigger.webhookBasedNode.action", {
          interpolate: { name: serviceName.value }
        });
      }
      return "";
    });
    const subheader = computed(() => {
      if (isActivelyPolling.value) {
        return i18n.baseText("ndv.trigger.pollingNode.fetchingHint", {
          interpolate: { name: serviceName.value }
        });
      }
      return "";
    });
    const executionsHelp = computed(() => {
      if (triggerPanel.value?.executionsHelp) {
        if (typeof triggerPanel.value.executionsHelp === "string") {
          return triggerPanel.value.executionsHelp;
        }
        if (!isWorkflowActive.value && triggerPanel.value.executionsHelp.inactive) {
          return triggerPanel.value.executionsHelp.inactive;
        }
        if (isWorkflowActive.value && triggerPanel.value.executionsHelp.active) {
          return triggerPanel.value.executionsHelp.active;
        }
      }
      if (isWebhookBasedNode.value) {
        if (isWorkflowActive.value) {
          return i18n.baseText("ndv.trigger.webhookBasedNode.executionsHelp.active", {
            interpolate: { service: serviceName.value }
          });
        } else {
          return i18n.baseText("ndv.trigger.webhookBasedNode.executionsHelp.inactive", {
            interpolate: { service: serviceName.value }
          });
        }
      }
      if (isPollingNode.value) {
        if (isWorkflowActive.value) {
          return i18n.baseText("ndv.trigger.pollingNode.executionsHelp.active", {
            interpolate: { service: serviceName.value }
          });
        } else {
          return i18n.baseText("ndv.trigger.pollingNode.executionsHelp.inactive", {
            interpolate: { service: serviceName.value }
          });
        }
      }
      return "";
    });
    const activationHint = computed(() => {
      if (isActivelyPolling.value || !triggerPanel.value) {
        return "";
      }
      if (triggerPanel.value.activationHint) {
        if (typeof triggerPanel.value.activationHint === "string") {
          return triggerPanel.value.activationHint;
        }
        if (!isWorkflowActive.value && typeof triggerPanel.value.activationHint.inactive === "string") {
          return triggerPanel.value.activationHint.inactive;
        }
        if (isWorkflowActive.value && typeof triggerPanel.value.activationHint.active === "string") {
          return triggerPanel.value.activationHint.active;
        }
      }
      if (isWebhookBasedNode.value) {
        if (isWorkflowActive.value) {
          return i18n.baseText("ndv.trigger.webhookBasedNode.activationHint.active", {
            interpolate: { service: serviceName.value }
          });
        } else {
          return i18n.baseText("ndv.trigger.webhookBasedNode.activationHint.inactive", {
            interpolate: { service: serviceName.value }
          });
        }
      }
      if (isPollingNode.value) {
        if (isWorkflowActive.value) {
          return i18n.baseText("ndv.trigger.pollingNode.activationHint.active", {
            interpolate: { service: serviceName.value }
          });
        } else {
          return i18n.baseText("ndv.trigger.pollingNode.activationHint.inactive", {
            interpolate: { service: serviceName.value }
          });
        }
      }
      return "";
    });
    const expandExecutionHelp = () => {
      if (help.value) {
        executionsHelpEventBus.emit("expand");
      }
    };
    const openWebhookUrl = () => {
      telemetry.track("User clicked ndv link", {
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        pane: "input",
        type: "open-chat"
      });
      window.open(webhookTestUrl.value, "_blank", "noreferrer");
    };
    const onLinkClick = (e) => {
      if (!e.target) {
        return;
      }
      const target = e.target;
      if (target.localName !== "a") return;
      if (target.dataset?.key) {
        e.stopPropagation();
        e.preventDefault();
        if (target.dataset.key === "activate") {
          emit("activate");
        } else if (target.dataset.key === "executions") {
          telemetry.track("User clicked ndv link", {
            workflow_id: workflowsStore.workflowId,
            push_ref: props.pushRef,
            pane: "input",
            type: "open-executions-log"
          });
          ndvStore.activeNodeName = null;
          void router.push({
            name: VIEWS.EXECUTIONS
          });
        } else if (target.dataset.key === "settings") {
          uiStore.openModal(WORKFLOW_SETTINGS_MODAL_KEY);
        }
      }
    };
    const onTestLinkCopied = () => {
      telemetry.track("User copied webhook URL", {
        pane: "inputs",
        type: "test url"
      });
    };
    const onNodeExecute = () => {
      emit("execute");
    };
    return (_ctx, _cache) => {
      const _component_n8n_pulse = resolveComponent("n8n-pulse");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_n8n_button = resolveComponent("n8n-button");
      const _component_n8n_spinner = resolveComponent("n8n-spinner");
      const _component_n8n_heading = resolveComponent("n8n-heading");
      const _component_n8n_link = resolveComponent("n8n-link");
      const _component_n8n_info_accordion = resolveComponent("n8n-info-accordion");
      const _directive_n8n_html = resolveDirective("n8n-html");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style.container)
      }, [
        createVNode(Transition, {
          name: "fade",
          mode: "out-in"
        }, {
          default: withCtx(() => [
            hasIssues2.value || hideContent.value ? (openBlock(), createElementBlock("div", _hoisted_1$5)) : isListeningForEvents.value ? (openBlock(), createElementBlock("div", _hoisted_2$4, [
              createVNode(_component_n8n_pulse, null, {
                default: withCtx(() => [
                  createVNode(_sfc_main$z, {
                    "node-type": nodeType.value,
                    size: 40
                  }, null, 8, ["node-type"])
                ]),
                _: 1
              }),
              isWebhookNode.value ? (openBlock(), createElementBlock("div", _hoisted_3$2, [
                createVNode(_component_n8n_text, {
                  tag: "div",
                  size: "large",
                  color: "text-dark",
                  class: "mb-2xs",
                  bold: ""
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(i18n).baseText("ndv.trigger.webhookNode.listening")), 1)
                  ]),
                  _: 1
                }),
                createBaseVNode("div", {
                  class: normalizeClass([_ctx.$style.shake, "mb-xs"])
                }, [
                  createVNode(_component_n8n_text, null, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(i18n).baseText("ndv.trigger.webhookNode.requestHint", {
                        interpolate: { type: webhookHttpMethod.value ?? "" }
                      })), 1)
                    ]),
                    _: 1
                  })
                ], 2),
                createVNode(CopyInput, {
                  value: webhookTestUrl.value,
                  "toast-title": unref(i18n).baseText("ndv.trigger.copiedTestUrl"),
                  class: "mb-2xl",
                  size: "medium",
                  collapse: true,
                  "copy-button-text": unref(i18n).baseText("generic.clickToCopy"),
                  onCopy: onTestLinkCopied
                }, null, 8, ["value", "toast-title", "copy-button-text"]),
                createVNode(_sfc_main$u, {
                  "data-test-id": "trigger-execute-button",
                  "node-name": _ctx.nodeName,
                  size: "medium",
                  "telemetry-source": "inputs",
                  onExecute: onNodeExecute
                }, null, 8, ["node-name"])
              ])) : (openBlock(), createElementBlock("div", _hoisted_4$2, [
                createVNode(_component_n8n_text, {
                  tag: "div",
                  size: "large",
                  color: "text-dark",
                  class: "mb-2xs",
                  bold: ""
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(listeningTitle.value), 1)
                  ]),
                  _: 1
                }),
                createBaseVNode("div", {
                  class: normalizeClass([_ctx.$style.shake, "mb-xs"])
                }, [
                  createVNode(_component_n8n_text, { tag: "div" }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(listeningHint.value), 1)
                    ]),
                    _: 1
                  })
                ], 2),
                displayChatButton.value ? (openBlock(), createElementBlock("div", _hoisted_5$2, [
                  createVNode(_component_n8n_button, {
                    class: "mb-xl",
                    onClick: _cache[0] || (_cache[0] = ($event) => openWebhookUrl())
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(i18n).baseText("ndv.trigger.chatTrigger.openChat")), 1)
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true),
                createVNode(_sfc_main$u, {
                  "data-test-id": "trigger-execute-button",
                  "node-name": _ctx.nodeName,
                  size: "medium",
                  "telemetry-source": "inputs",
                  onExecute: onNodeExecute
                }, null, 8, ["node-name"])
              ]))
            ])) : (openBlock(), createElementBlock("div", _hoisted_6$2, [
              isActivelyPolling.value ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
                createVNode(_component_n8n_spinner, { type: "ring" })
              ])) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.action)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.$style.header)
                }, [
                  header2.value ? (openBlock(), createBlock(_component_n8n_heading, {
                    key: 0,
                    tag: "h1",
                    bold: ""
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(header2.value), 1)
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  subheader.value ? (openBlock(), createBlock(_component_n8n_text, { key: 1 }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        textContent: toDisplayString(subheader.value)
                      }, null, 8, _hoisted_8$1)
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ], 2),
                createVNode(_sfc_main$u, {
                  "data-test-id": "trigger-execute-button",
                  "node-name": _ctx.nodeName,
                  size: "medium",
                  "telemetry-source": "inputs",
                  onExecute: onNodeExecute
                }, null, 8, ["node-name"])
              ], 2),
              activationHint.value ? (openBlock(), createBlock(_component_n8n_text, {
                key: 1,
                size: "small",
                onClick: onLinkClick
              }, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("span", null, null, 512), [
                    [_directive_n8n_html, activationHint.value]
                  ]),
                  _cache[1] || (_cache[1] = createTextVNode("  "))
                ]),
                _: 1
              })) : createCommentVNode("", true),
              activationHint.value && executionsHelp.value ? (openBlock(), createBlock(_component_n8n_link, {
                key: 2,
                size: "small",
                onClick: expandExecutionHelp
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("ndv.trigger.moreInfo")), 1)
                ]),
                _: 1
              })) : createCommentVNode("", true),
              executionsHelp.value ? (openBlock(), createBlock(_component_n8n_info_accordion, {
                key: 3,
                ref_key: "help",
                ref: help,
                class: normalizeClass(_ctx.$style.accordion),
                title: unref(i18n).baseText("ndv.trigger.executionsHint.question"),
                description: executionsHelp.value,
                "event-bus": unref(executionsHelpEventBus),
                "onClick:body": onLinkClick
              }, null, 8, ["class", "title", "description", "event-bus"])) : createCommentVNode("", true)
            ]))
          ]),
          _: 1
        })
      ], 2);
    };
  }
});
const container = "_container_13dut_123";
const header = "_header_13dut_140";
const action = "_action_13dut_147";
const shake$1 = "_shake_13dut_151";
const accordion = "_accordion_13dut_172";
const style0$3 = {
  container,
  header,
  action,
  shake: shake$1,
  accordion
};
const cssModules$5 = {
  "$style": style0$3
};
const TriggerPanel = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__cssModules", cssModules$5], ["__scopeId", "data-v-61e12e36"]]);
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "NodeDetailsView",
  props: {
    workflowObject: {},
    readOnly: { type: Boolean, default: false },
    renaming: { type: Boolean },
    isProductionExecutionPreview: { type: Boolean, default: false }
  },
  emits: ["saveKeyboardShortcut", "valueChanged", "switchSelectedNode", "openConnectionNodeCreator", "redrawNode", "stopExecution"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const ndvStore = useNDVStore();
    const externalHooks = useExternalHooks();
    const nodeHelpers = useNodeHelpers();
    const { activeNode } = storeToRefs(ndvStore);
    const pinnedData = usePinnedData(activeNode);
    const workflowActivate = useWorkflowActivate();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const workflowsStore = useWorkflowsStore();
    const settingsStore = useSettingsStore();
    const deviceSupport = useDeviceSupport();
    const telemetry = useTelemetry();
    const i18n = useI18n();
    const message = useMessage();
    const { APP_Z_INDEXES } = useStyles();
    const settingsEventBus = createEventBus();
    const redrawRequired = ref(false);
    const runInputIndex = ref(-1);
    const runOutputIndex = ref(-1);
    const isLinkingEnabled = ref(true);
    const selectedInput = ref();
    const triggerWaitingWarningEnabled = ref(false);
    const isDragging = ref(false);
    const mainPanelPosition = ref(0);
    const pinDataDiscoveryTooltipVisible = ref(false);
    const avgInputRowHeight = ref(0);
    const avgOutputRowHeight = ref(0);
    const isInputPaneActive = ref(false);
    const isOutputPaneActive = ref(false);
    const isPairedItemHoveringEnabled = ref(true);
    const pushRef = computed(() => ndvStore.pushRef);
    const activeNodeType = computed(() => {
      if (activeNode.value) {
        return nodeTypesStore.getNodeType(activeNode.value.type, activeNode.value.typeVersion);
      }
      return null;
    });
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const showTriggerWaitingWarning = computed(
      () => triggerWaitingWarningEnabled.value && !!activeNodeType.value && !activeNodeType.value.group.includes("trigger") && workflowRunning.value && workflowsStore.executionWaitingForWebhook
    );
    const workflowRunData = computed(() => {
      if (workflowExecution.value === null) {
        return null;
      }
      const executionData = workflowExecution.value.data;
      if (executionData?.resultData) {
        return executionData.resultData.runData;
      }
      return null;
    });
    const parentNodes = computed(() => {
      if (activeNode.value) {
        return props.workflowObject.getParentNodesByDepth(activeNode.value.name, 1).map(({ name }) => name) || [];
      } else {
        return [];
      }
    });
    const parentNode = computed(() => {
      for (const parentNodeName of parentNodes.value) {
        if (workflowsStore?.pinnedWorkflowData?.[parentNodeName]) {
          return parentNodeName;
        }
        if (workflowRunData.value?.[parentNodeName]) {
          return parentNodeName;
        }
      }
      return parentNodes.value[0];
    });
    const inputNodeName = computed(() => {
      const nodeOutputs = activeNode.value && activeNodeType.value ? getNodeOutputs(props.workflowObject, activeNode.value, activeNodeType.value) : [];
      const nonMainOutputs = nodeOutputs.filter((output) => {
        if (typeof output === "string") return output !== NodeConnectionType.Main;
        return output.type !== NodeConnectionType.Main;
      });
      const isSubNode = nonMainOutputs.length > 0;
      if (isSubNode && activeNode.value) {
        const connectedOutputNode = props.workflowObject.getChildNodes(
          activeNode.value.name,
          "ALL_NON_MAIN"
        )?.[0];
        return connectedOutputNode;
      }
      return selectedInput.value || parentNode.value;
    });
    const inputNode = computed(() => {
      if (inputNodeName.value) {
        return workflowsStore.getNodeByName(inputNodeName.value);
      }
      return null;
    });
    const inputSize = computed(() => ndvStore.ndvInputDataWithPinnedData.length);
    const isTriggerNode = computed(
      () => !!activeNodeType.value && (activeNodeType.value.group.includes("trigger") || activeNodeType.value.name === START_NODE_TYPE)
    );
    const showTriggerPanel = computed(() => {
      const override = !!activeNodeType.value?.triggerPanel;
      if (typeof activeNodeType.value?.triggerPanel === "boolean") {
        return override;
      }
      const isWebhookBasedNode = !!activeNodeType.value?.webhooks?.length;
      const isPollingNode = activeNodeType.value?.polling;
      return !props.readOnly && isTriggerNode.value && (isWebhookBasedNode || isPollingNode || override);
    });
    const hasOutputConnection = computed(() => {
      if (!activeNode.value) return false;
      const outgoingConnections = workflowsStore.outgoingConnectionsByNodeName(activeNode.value.name);
      return (Object.values(outgoingConnections)?.[0]?.[0] ?? []).length > 0;
    });
    const isExecutableTriggerNode = computed(() => {
      if (!activeNodeType.value) return false;
      return EXECUTABLE_TRIGGER_NODE_TYPES.includes(activeNodeType.value.name);
    });
    const isActiveStickyNode = computed(
      () => !!ndvStore.activeNode && ndvStore.activeNode.type === STICKY_NODE_TYPE
    );
    const workflowExecution = computed(() => workflowsStore.getWorkflowExecution);
    const maxOutputRun = computed(() => {
      if (activeNode.value === null) {
        return 0;
      }
      const runData = workflowRunData.value;
      if (!runData?.[activeNode.value.name]) {
        return 0;
      }
      if (runData[activeNode.value.name].length) {
        return runData[activeNode.value.name].length - 1;
      }
      return 0;
    });
    const outputRun = computed(
      () => runOutputIndex.value === -1 ? maxOutputRun.value : Math.min(runOutputIndex.value, maxOutputRun.value)
    );
    const maxInputRun = computed(() => {
      if (inputNode.value === null || activeNode.value === null) {
        return 0;
      }
      const workflowNode = props.workflowObject.getNode(activeNode.value.name);
      if (!workflowNode || !activeNodeType.value) {
        return 0;
      }
      const outputs2 = getNodeOutputs(
        props.workflowObject,
        workflowNode,
        activeNodeType.value
      );
      let node2 = inputNode.value;
      const runData = workflowRunData.value;
      if (outputs2.some((output) => output !== NodeConnectionType.Main)) {
        node2 = activeNode.value;
      }
      if (!node2 || !runData || !runData.hasOwnProperty(node2.name)) {
        return 0;
      }
      if (runData[node2.name].length) {
        return runData[node2.name].length - 1;
      }
      return 0;
    });
    const inputRun = computed(() => {
      if (isLinkingEnabled.value && maxOutputRun.value === maxInputRun.value) {
        return outputRun.value;
      }
      if (runInputIndex.value === -1) {
        return maxInputRun.value;
      }
      return Math.min(runInputIndex.value, maxInputRun.value);
    });
    const canLinkRuns = computed(
      () => maxOutputRun.value > 0 && maxOutputRun.value === maxInputRun.value
    );
    const linked = computed(() => isLinkingEnabled.value && canLinkRuns.value);
    const featureRequestUrl = computed(() => {
      if (!activeNodeType.value) {
        return "";
      }
      return `${BASE_NODE_SURVEY_URL}${activeNodeType.value.name}`;
    });
    const outputPanelEditMode = computed(() => ndvStore.outputPanelEditMode);
    const isWorkflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const isExecutionWaitingForWebhook = computed(() => workflowsStore.executionWaitingForWebhook);
    const blockUi = computed(() => isWorkflowRunning.value || isExecutionWaitingForWebhook.value);
    const foreignCredentials = computed(() => {
      const credentials = activeNode.value?.credentials;
      const usedCredentials = workflowsStore.usedCredentials;
      const foreignCredentialsArray = [];
      if (credentials && settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Sharing]) {
        Object.values(credentials).forEach((credential) => {
          if (credential.id && usedCredentials[credential.id] && !usedCredentials[credential.id].currentUserHasAccess) {
            foreignCredentialsArray.push(credential.id);
          }
        });
      }
      return foreignCredentialsArray;
    });
    const hasForeignCredential = computed(() => foreignCredentials.value.length > 0);
    const setIsTooltipVisible = ({ isTooltipVisible }) => {
      pinDataDiscoveryTooltipVisible.value = isTooltipVisible;
    };
    const onKeyDown = (e) => {
      if (e.key === "s" && deviceSupport.isCtrlKeyPressed(e)) {
        e.stopPropagation();
        e.preventDefault();
        if (props.readOnly) return;
        emit("saveKeyboardShortcut", e);
      }
    };
    const onInputItemHover = (e) => {
      if (e === null || !inputNodeName.value || !isPairedItemHoveringEnabled.value) {
        ndvStore.setHoveringItem(null);
        return;
      }
      const item = {
        nodeName: inputNodeName.value,
        runIndex: inputRun.value,
        outputIndex: e.outputIndex,
        itemIndex: e.itemIndex
      };
      ndvStore.setHoveringItem(item);
    };
    const onInputTableMounted = (e) => {
      avgInputRowHeight.value = e.avgRowHeight;
    };
    const onWorkflowActivate = () => {
      ndvStore.activeNodeName = null;
      setTimeout(() => {
        void workflowActivate.activateCurrentWorkflow("ndv");
      }, 1e3);
    };
    const onOutputItemHover = (e) => {
      if (e === null || !activeNode.value || !isPairedItemHoveringEnabled.value) {
        ndvStore.setHoveringItem(null);
        return;
      }
      const item = {
        nodeName: activeNode.value?.name,
        runIndex: outputRun.value,
        outputIndex: e.outputIndex,
        itemIndex: e.itemIndex
      };
      ndvStore.setHoveringItem(item);
    };
    const onFeatureRequestClick = () => {
      window.open(featureRequestUrl.value, "_blank");
      if (activeNode.value) {
        telemetry.track("User clicked ndv link", {
          node_type: activeNode.value.type,
          workflow_id: workflowsStore.workflowId,
          push_ref: pushRef.value,
          pane: NodeConnectionType.Main,
          type: "i-wish-this-node-would"
        });
      }
    };
    const onDragEnd = (e) => {
      isDragging.value = false;
      telemetry.track("User moved parameters pane", {
        // example method for tracking
        window_width: e.windowWidth,
        start_position: mainPanelPosition.value,
        end_position: e.position,
        node_type: activeNodeType.value ? activeNodeType.value.name : "",
        push_ref: pushRef.value,
        workflow_id: workflowsStore.workflowId
      });
      mainPanelPosition.value = e.position;
    };
    const onDragStart = (e) => {
      isDragging.value = true;
      mainPanelPosition.value = e.position;
    };
    const onPanelsInit = (e) => {
      mainPanelPosition.value = e.position;
    };
    const onLinkRunToOutput = () => {
      isLinkingEnabled.value = true;
      trackLinking("output");
    };
    const onUnlinkRun = (pane) => {
      runInputIndex.value = runOutputIndex.value;
      isLinkingEnabled.value = false;
      trackLinking(pane);
    };
    const onNodeExecute = () => {
      setTimeout(() => {
        if (!activeNode.value || !workflowRunning.value) {
          return;
        }
        triggerWaitingWarningEnabled.value = true;
      }, 1e3);
    };
    const openSettings = () => {
      settingsEventBus.emit("openSettings");
    };
    const trackLinking = (pane) => {
      telemetry.track("User changed ndv run linking", {
        node_type: activeNodeType.value ? activeNodeType.value.name : "",
        push_ref: pushRef.value,
        linked: linked.value,
        pane
      });
    };
    const onLinkRunToInput = () => {
      runOutputIndex.value = runInputIndex.value;
      isLinkingEnabled.value = true;
      trackLinking("input");
    };
    const valueChanged = (parameterData) => {
      emit("valueChanged", parameterData);
    };
    const onSwitchSelectedNode = (nodeTypeName) => {
      emit("switchSelectedNode", nodeTypeName);
    };
    const onOpenConnectionNodeCreator = (nodeTypeName, connectionType2) => {
      emit("openConnectionNodeCreator", nodeTypeName, connectionType2);
    };
    const close = async () => {
      if (isDragging.value) {
        return;
      }
      if (activeNode.value && (typeof activeNodeType.value?.outputs === "string" || typeof activeNodeType.value?.inputs === "string" || redrawRequired.value)) {
        const nodeName = activeNode.value.name;
        setTimeout(() => {
          emit("redrawNode", nodeName);
        }, 1);
      }
      if (outputPanelEditMode.value.enabled && activeNode.value) {
        const shouldPinDataBeforeClosing = await message.confirm(
          "",
          i18n.baseText("ndv.pinData.beforeClosing.title"),
          {
            confirmButtonText: i18n.baseText("ndv.pinData.beforeClosing.confirm"),
            cancelButtonText: i18n.baseText("ndv.pinData.beforeClosing.cancel")
          }
        );
        if (shouldPinDataBeforeClosing === MODAL_CONFIRM) {
          const { value } = outputPanelEditMode.value;
          try {
            pinnedData.setData(jsonParse(value), "on-ndv-close-modal");
          } catch (error) {
            console.error(error);
          }
        }
        ndvStore.setOutputPanelEditModeEnabled(false);
      }
      await externalHooks.run("dataDisplay.nodeEditingFinished");
      telemetry.track("User closed node modal", {
        node_type: activeNodeType.value ? activeNodeType.value?.name : "",
        push_ref: pushRef.value,
        workflow_id: workflowsStore.workflowId
      });
      triggerWaitingWarningEnabled.value = false;
      ndvStore.activeNodeName = null;
      ndvStore.resetNDVPushRef();
    };
    const trackRunChange = (run, pane) => {
      telemetry.track("User changed ndv run dropdown", {
        push_ref: pushRef.value,
        run_index: run,
        node_type: activeNodeType.value ? activeNodeType.value?.name : "",
        pane
      });
    };
    const onRunOutputIndexChange = (run) => {
      runOutputIndex.value = run;
      trackRunChange(run, "output");
    };
    const onRunInputIndexChange = (run) => {
      runInputIndex.value = run;
      if (linked.value) {
        runOutputIndex.value = run;
      }
      trackRunChange(run, "input");
    };
    const onOutputTableMounted = (e) => {
      avgOutputRowHeight.value = e.avgRowHeight;
    };
    const onInputNodeChange = (value, index) => {
      runInputIndex.value = -1;
      isLinkingEnabled.value = true;
      selectedInput.value = value;
      telemetry.track("User changed ndv input dropdown", {
        node_type: activeNode.value ? activeNode.value.type : "",
        push_ref: pushRef.value,
        workflow_id: workflowsStore.workflowId,
        selection_value: index,
        input_node_type: inputNode.value ? inputNode.value.type : ""
      });
    };
    const onStopExecution = () => {
      emit("stopExecution");
    };
    const activateInputPane = () => {
      isInputPaneActive.value = true;
      isOutputPaneActive.value = false;
    };
    const activateOutputPane = () => {
      isInputPaneActive.value = false;
      isOutputPaneActive.value = true;
    };
    const onSearch = (search2) => {
      isPairedItemHoveringEnabled.value = !search2;
    };
    watch(
      activeNode,
      (node2, oldNode) => {
        if (node2 && node2.name !== oldNode?.name && !isActiveStickyNode.value) {
          runInputIndex.value = -1;
          runOutputIndex.value = -1;
          isLinkingEnabled.value = true;
          selectedInput.value = void 0;
          triggerWaitingWarningEnabled.value = false;
          avgOutputRowHeight.value = 0;
          avgInputRowHeight.value = 0;
          setTimeout(() => ndvStore.setNDVPushRef(), 0);
          if (!activeNodeType.value) {
            return;
          }
          void externalHooks.run("dataDisplay.nodeTypeChanged", {
            nodeSubtitle: nodeHelpers.getNodeSubtitle(node2, activeNodeType.value, props.workflowObject)
          });
          setTimeout(() => {
            if (activeNode.value) {
              const outgoingConnections = workflowsStore.outgoingConnectionsByNodeName(
                activeNode.value?.name
              );
              telemetry.track("User opened node modal", {
                node_type: activeNodeType.value ? activeNodeType.value?.name : "",
                workflow_id: workflowsStore.workflowId,
                push_ref: pushRef.value,
                is_editable: !hasForeignCredential.value,
                parameters_pane_position: mainPanelPosition.value,
                input_first_connector_runs: maxInputRun.value,
                output_first_connector_runs: maxOutputRun.value,
                selected_view_inputs: isTriggerNode.value ? "trigger" : ndvStore.inputPanelDisplayMode,
                selected_view_outputs: ndvStore.outputPanelDisplayMode,
                input_connectors: parentNodes.value.length,
                output_connectors: outgoingConnections?.main?.length,
                input_displayed_run_index: inputRun.value,
                output_displayed_run_index: outputRun.value,
                data_pinning_tooltip_presented: pinDataDiscoveryTooltipVisible.value,
                input_displayed_row_height_avg: avgInputRowHeight.value,
                output_displayed_row_height_avg: avgOutputRowHeight.value
              });
            }
          }, 2e3);
        }
        if (window.top && !isActiveStickyNode.value) {
          window.top.postMessage(JSON.stringify({ command: node2 ? "openNDV" : "closeNDV" }), "*");
        }
      },
      { immediate: true }
    );
    watch(maxOutputRun, () => {
      runOutputIndex.value = -1;
    });
    watch(maxInputRun, () => {
      runInputIndex.value = -1;
    });
    watch(inputNodeName, (nodeName) => {
      setTimeout(() => {
        ndvStore.setInputNodeName(nodeName);
      }, 0);
    });
    watch(inputRun, (inputRun2) => {
      setTimeout(() => {
        ndvStore.setInputRunIndex(inputRun2);
      }, 0);
    });
    onMounted(() => {
      dataPinningEventBus.on("data-pinning-discovery", setIsTooltipVisible);
    });
    onBeforeUnmount(() => {
      dataPinningEventBus.off("data-pinning-discovery", setIsTooltipVisible);
    });
    return (_ctx, _cache) => {
      const _component_n8n_icon = resolveComponent("n8n-icon");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_el_dialog = resolveComponent("el-dialog");
      return openBlock(), createBlock(_component_el_dialog, {
        "model-value": (!!unref(activeNode) || _ctx.renaming) && !isActiveStickyNode.value,
        "before-close": close,
        "show-close": false,
        class: "data-display-wrapper ndv-wrapper",
        "overlay-class": "data-display-overlay",
        width: "auto",
        "append-to": `#${unref(APP_MODALS_ELEMENT_ID)}`,
        "data-test-id": "ndv",
        "z-index": unref(APP_Z_INDEXES).NDV,
        "data-has-output-connection": hasOutputConnection.value
      }, {
        default: withCtx(() => [
          createVNode(_component_n8n_tooltip, {
            placement: "bottom-start",
            visible: showTriggerWaitingWarning.value,
            disabled: !showTriggerWaitingWarning.value
          }, {
            content: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.triggerWarning)
              }, toDisplayString(unref(i18n).baseText("ndv.backToCanvas.waitingForTriggerWarning")), 3)
            ]),
            default: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.backToCanvas),
                "data-test-id": "back-to-canvas",
                onClick: close
              }, [
                createVNode(_component_n8n_icon, {
                  icon: "arrow-left",
                  color: "text-xlight",
                  size: "medium"
                }),
                createVNode(_component_n8n_text, {
                  color: "text-xlight",
                  size: "medium",
                  bold: true
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(i18n).baseText("ndv.backToCanvas")), 1)
                  ]),
                  _: 1
                })
              ], 2)
            ]),
            _: 1
          }, 8, ["visible", "disabled"]),
          unref(activeNode) ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref: "container",
            class: "data-display",
            tabindex: "0",
            onKeydownCapture: onKeyDown
          }, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.modalBackground),
              onClick: close
            }, null, 2),
            (openBlock(), createBlock(NDVDraggablePanels, {
              key: unref(activeNode).name,
              "is-trigger-node": isTriggerNode.value,
              "hide-input-and-output": activeNodeType.value === null,
              position: isTriggerNode.value && !showTriggerPanel.value ? 0 : void 0,
              "is-draggable": !isTriggerNode.value,
              "has-double-width": activeNodeType.value?.parameterPane === "wide",
              "node-type": activeNodeType.value,
              onSwitchSelectedNode,
              onOpenConnectionNodeCreator,
              onClose: close,
              onInit: onPanelsInit,
              onDragstart: onDragStart,
              onDragend: onDragEnd
            }, createSlots({
              output: withCtx(() => [
                createVNode(OutputPanel, {
                  "data-test-id": "output-panel",
                  workflow: _ctx.workflowObject,
                  "can-link-runs": canLinkRuns.value,
                  "run-index": outputRun.value,
                  "linked-runs": linked.value,
                  "push-ref": pushRef.value,
                  "is-read-only": _ctx.readOnly || hasForeignCredential.value,
                  "block-u-i": blockUi.value && isTriggerNode.value && !isExecutableTriggerNode.value,
                  "is-production-execution-preview": _ctx.isProductionExecutionPreview,
                  "is-pane-active": isOutputPaneActive.value,
                  onActivatePane: activateOutputPane,
                  onLinkRun: onLinkRunToOutput,
                  onUnlinkRun: _cache[1] || (_cache[1] = () => onUnlinkRun("output")),
                  onRunChange: onRunOutputIndexChange,
                  onOpenSettings: openSettings,
                  onTableMounted: onOutputTableMounted,
                  onItemHover: onOutputItemHover,
                  onSearch
                }, null, 8, ["workflow", "can-link-runs", "run-index", "linked-runs", "push-ref", "is-read-only", "block-u-i", "is-production-execution-preview", "is-pane-active"])
              ]),
              main: withCtx(() => [
                createVNode(NodeSettings, {
                  "event-bus": unref(settingsEventBus),
                  dragging: isDragging.value,
                  "push-ref": pushRef.value,
                  "node-type": activeNodeType.value,
                  "foreign-credentials": foreignCredentials.value,
                  "read-only": _ctx.readOnly,
                  "block-u-i": blockUi.value && showTriggerPanel.value,
                  executable: !_ctx.readOnly,
                  "input-size": inputSize.value,
                  onValueChanged: valueChanged,
                  onExecute: onNodeExecute,
                  onStopExecution,
                  onRedrawRequired: _cache[2] || (_cache[2] = ($event) => redrawRequired.value = true),
                  onActivate: onWorkflowActivate,
                  onSwitchSelectedNode,
                  onOpenConnectionNodeCreator
                }, null, 8, ["event-bus", "dragging", "push-ref", "node-type", "foreign-credentials", "read-only", "block-u-i", "executable", "input-size"]),
                featureRequestUrl.value ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  class: normalizeClass(_ctx.$style.featureRequest),
                  target: "_blank",
                  onClick: onFeatureRequestClick
                }, [
                  createVNode(_component_font_awesome_icon, { icon: "lightbulb" }),
                  createTextVNode(" " + toDisplayString(unref(i18n).baseText("ndv.featureRequest")), 1)
                ], 2)) : createCommentVNode("", true)
              ]),
              _: 2
            }, [
              showTriggerPanel.value || !isTriggerNode.value ? {
                name: "input",
                fn: withCtx(() => [
                  showTriggerPanel.value ? (openBlock(), createBlock(TriggerPanel, {
                    key: 0,
                    "node-name": unref(activeNode).name,
                    "push-ref": pushRef.value,
                    onExecute: onNodeExecute,
                    onActivate: onWorkflowActivate
                  }, null, 8, ["node-name", "push-ref"])) : !isTriggerNode.value ? (openBlock(), createBlock(InputPanel, {
                    key: 1,
                    workflow: _ctx.workflowObject,
                    "can-link-runs": canLinkRuns.value,
                    "run-index": inputRun.value,
                    "linked-runs": linked.value,
                    "current-node-name": inputNodeName.value,
                    "push-ref": pushRef.value,
                    "read-only": _ctx.readOnly || hasForeignCredential.value,
                    "is-production-execution-preview": _ctx.isProductionExecutionPreview,
                    "is-pane-active": isInputPaneActive.value,
                    onActivatePane: activateInputPane,
                    onLinkRun: onLinkRunToInput,
                    onUnlinkRun: _cache[0] || (_cache[0] = () => onUnlinkRun("input")),
                    onRunChange: onRunInputIndexChange,
                    onOpenSettings: openSettings,
                    onChangeInputNode: onInputNodeChange,
                    onExecute: onNodeExecute,
                    onTableMounted: onInputTableMounted,
                    onItemHover: onInputItemHover,
                    onSearch
                  }, null, 8, ["workflow", "can-link-runs", "run-index", "linked-runs", "current-node-name", "push-ref", "read-only", "is-production-execution-preview", "is-pane-active"])) : createCommentVNode("", true)
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["is-trigger-node", "hide-input-and-output", "position", "is-draggable", "has-double-width", "node-type"]))
          ], 544)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["model-value", "append-to", "z-index", "data-has-output-connection"]);
    };
  }
});
const modalBackground = "_modalBackground_176ah_123";
const triggerWarning = "_triggerWarning_176ah_128";
const backToCanvas = "_backToCanvas_176ah_132";
const featureRequest = "_featureRequest_176ah_153";
const style1 = {
  modalBackground,
  triggerWarning,
  backToCanvas,
  featureRequest
};
const cssModules$4 = {
  "$style": style1
};
const __unplugin_components_2 = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__cssModules", cssModules$4]]);
const NodeDetailsView = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __unplugin_components_2
}, Symbol.toStringTag, { value: "Module" }));
function useNodeBase({
  name,
  instance,
  workflowObject,
  isReadOnly,
  emit
}) {
  const uiStore = useUIStore();
  const deviceSupport = useDeviceSupport();
  const workflowsStore = useWorkflowsStore();
  const nodeTypesStore = useNodeTypesStore();
  const i18n = useI18n();
  const refs = computed(() => getCurrentInstance()?.refs ?? {});
  const data = computed(() => {
    return workflowsStore.getNodeByName(name);
  });
  const nodeId = computed(() => data.value?.id ?? "");
  const inputs = ref([]);
  const outputs2 = ref([]);
  const createAddInputEndpointSpec = (connectionName, color) => {
    const multiple = NODE_CONNECTION_TYPE_ALLOW_MULTIPLE.includes(connectionName);
    return {
      type: "N8nAddInput",
      options: {
        width: 24,
        height: 72,
        color,
        multiple
      }
    };
  };
  const createDiamondOutputEndpointSpec = () => ({
    type: "Rectangle",
    options: {
      height: 10,
      width: 10,
      cssClass: "diamond-output-endpoint"
    }
  });
  const getEndpointLabelLength = (length) => {
    if (length <= 2) return "small";
    else if (length <= 6) return "medium";
    return "large";
  };
  function addEndpointTestingData(endpoint, type, inputIndex) {
    if (window?.Cypress && "canvas" in endpoint.endpoint && instance) {
      const canvas2 = endpoint.endpoint.canvas;
      instance.setAttribute(canvas2, "data-endpoint-name", data.value?.name ?? "");
      instance.setAttribute(canvas2, "data-input-index", inputIndex.toString());
      instance.setAttribute(canvas2, "data-endpoint-type", type);
    }
  }
  function addInputEndpoints(node2, nodeTypeData) {
    const rootTypeIndexData = {};
    const typeIndexData = {};
    inputs.value = getNodeInputs(workflowObject, data.value, nodeTypeData) || [];
    const sortedInputs = [...inputs.value];
    sortedInputs.sort((a, b) => {
      if (typeof a === "string") {
        return 1;
      } else if (typeof b === "string") {
        return -1;
      }
      if (a.required && !b.required) {
        return -1;
      } else if (!a.required && b.required) {
        return 1;
      }
      return 0;
    });
    sortedInputs.forEach((value, i) => {
      let inputConfiguration;
      if (typeof value === "string") {
        inputConfiguration = {
          type: value
        };
      } else {
        inputConfiguration = value;
      }
      const inputName = inputConfiguration.type;
      const rootCategoryInputName = inputName === NodeConnectionType.Main ? NodeConnectionType.Main : "other";
      if (rootTypeIndexData.hasOwnProperty(rootCategoryInputName)) {
        rootTypeIndexData[rootCategoryInputName]++;
      } else {
        rootTypeIndexData[rootCategoryInputName] = 0;
      }
      if (typeIndexData.hasOwnProperty(inputName)) {
        typeIndexData[inputName]++;
      } else {
        typeIndexData[inputName] = 0;
      }
      const rootTypeIndex = rootTypeIndexData[rootCategoryInputName];
      const typeIndex = typeIndexData[inputName];
      const inputsOfSameRootType = inputs.value.filter((inputData) => {
        const thisInputName = typeof inputData === "string" ? inputData : inputData.type;
        return inputName === NodeConnectionType.Main ? thisInputName === NodeConnectionType.Main : thisInputName !== NodeConnectionType.Main;
      });
      const nonMainInputs = inputsOfSameRootType.filter((inputData) => {
        return inputData !== NodeConnectionType.Main;
      });
      const requiredNonMainInputs = nonMainInputs.filter((inputData) => {
        return typeof inputData !== "string" && inputData.required;
      });
      const optionalNonMainInputs = nonMainInputs.filter((inputData) => {
        return typeof inputData !== "string" && !inputData.required;
      });
      const spacerIndexes = getSpacerIndexes(
        requiredNonMainInputs.length,
        optionalNonMainInputs.length
      );
      const anchorPosition = getAnchorPosition(
        inputName,
        "input",
        inputsOfSameRootType.length,
        spacerIndexes
      )[rootTypeIndex];
      if (!isValidNodeConnectionType(inputName)) {
        return;
      }
      const scope = getEndpointScope(inputName);
      const newEndpointData = {
        uuid: getInputEndpointUUID(nodeId.value, inputName, typeIndex),
        anchor: anchorPosition,
        // We potentially want to change that in the future to allow people to dynamically
        // activate and deactivate connected nodes
        maxConnections: inputConfiguration.maxConnections ?? -1,
        endpoint: "Rectangle",
        paintStyle: getInputEndpointStyle(
          nodeTypeData,
          "--color-foreground-xdark",
          inputName
        ),
        hoverPaintStyle: getInputEndpointStyle(
          nodeTypeData,
          "--color-primary",
          inputName
        ),
        scope: getScope(scope),
        source: inputName !== NodeConnectionType.Main,
        target: !isReadOnly && inputs.value.length > 1,
        // only enabled for nodes with multiple inputs.. otherwise attachment handled by connectionDrag event in NodeView,
        parameters: {
          connection: "target",
          nodeId: nodeId.value,
          type: inputName,
          index: typeIndex
        },
        enabled: !isReadOnly,
        // enabled in default case to allow dragging
        cssClass: "rect-input-endpoint",
        dragAllowedWhenFull: true,
        hoverClass: "rect-input-endpoint-hover",
        ...getInputConnectionStyle(inputName, nodeTypeData)
      };
      const endpoint = instance?.addEndpoint(
        refs.value[data.value?.name ?? ""],
        newEndpointData
      );
      addEndpointTestingData(endpoint, "input", typeIndex);
      if (inputConfiguration.displayName ?? nodeTypeData.inputNames?.[i]) {
        endpoint.addOverlay(
          getInputNameOverlay(
            inputConfiguration.displayName ?? nodeTypeData.inputNames?.[i] ?? "",
            inputName,
            inputConfiguration.required
          )
        );
      }
      if (!Array.isArray(endpoint)) {
        endpoint.__meta = {
          nodeName: node2.name,
          nodeId: nodeId.value,
          index: typeIndex,
          totalEndpoints: inputsOfSameRootType.length,
          nodeType: node2.type
        };
      }
    });
    if (sortedInputs.length === 0) {
      instance?.manage(refs.value[data.value?.name ?? ""]);
    }
  }
  function getSpacerIndexes(leftGroupItemsCount, rightGroupItemsCount, insertSpacerBetweenGroups = NODE_INSERT_SPACER_BETWEEN_INPUT_GROUPS, minItemsCount = NODE_MIN_INPUT_ITEMS_COUNT) {
    const spacerIndexes = [];
    if (leftGroupItemsCount > 0 && rightGroupItemsCount > 0) {
      if (insertSpacerBetweenGroups) {
        spacerIndexes.push(leftGroupItemsCount);
      } else if (leftGroupItemsCount + rightGroupItemsCount < minItemsCount) {
        for (let spacerIndex = leftGroupItemsCount; spacerIndex < minItemsCount - rightGroupItemsCount; spacerIndex++) {
          spacerIndexes.push(spacerIndex);
        }
      }
    } else {
      if (leftGroupItemsCount > 0 && leftGroupItemsCount < minItemsCount && rightGroupItemsCount === 0) {
        for (let spacerIndex = 0; spacerIndex < minItemsCount - leftGroupItemsCount; spacerIndex++) {
          spacerIndexes.push(spacerIndex + leftGroupItemsCount);
        }
      } else if (leftGroupItemsCount === 0 && rightGroupItemsCount > 0 && rightGroupItemsCount < minItemsCount) {
        for (let spacerIndex = 0; spacerIndex < minItemsCount - rightGroupItemsCount; spacerIndex++) {
          spacerIndexes.push(spacerIndex);
        }
      }
    }
    return spacerIndexes;
  }
  function addOutputEndpoints(node2, nodeTypeData) {
    const rootTypeIndexData = {};
    const typeIndexData = {};
    if (!data.value) {
      return;
    }
    outputs2.value = getNodeOutputs(workflowObject, data.value, nodeTypeData) || [];
    let maxLabelLength = 0;
    const outputConfigurations = [];
    outputs2.value.forEach((value, i) => {
      let outputConfiguration;
      if (typeof value === "string") {
        outputConfiguration = {
          type: value
        };
      } else {
        outputConfiguration = value;
      }
      if (nodeTypeData.outputNames?.[i]) {
        outputConfiguration.displayName = nodeTypeData.outputNames[i];
      }
      if (outputConfiguration.displayName) {
        maxLabelLength = outputConfiguration.displayName.length > maxLabelLength ? outputConfiguration.displayName.length : maxLabelLength;
      }
      outputConfigurations.push(outputConfiguration);
    });
    const endpointLabelLength = getEndpointLabelLength(maxLabelLength);
    outputs2.value.forEach((_value, i) => {
      const outputConfiguration = outputConfigurations[i];
      const outputName = outputConfiguration.type;
      const rootCategoryOutputName = outputName === NodeConnectionType.Main ? NodeConnectionType.Main : "other";
      if (rootTypeIndexData.hasOwnProperty(rootCategoryOutputName)) {
        rootTypeIndexData[rootCategoryOutputName]++;
      } else {
        rootTypeIndexData[rootCategoryOutputName] = 0;
      }
      if (typeIndexData.hasOwnProperty(outputName)) {
        typeIndexData[outputName]++;
      } else {
        typeIndexData[outputName] = 0;
      }
      const rootTypeIndex = rootTypeIndexData[rootCategoryOutputName];
      const typeIndex = typeIndexData[outputName];
      const outputsOfSameRootType = outputs2.value.filter((outputData) => {
        const thisOutputName = typeof outputData === "string" ? outputData : outputData.type;
        return outputName === NodeConnectionType.Main ? thisOutputName === NodeConnectionType.Main : thisOutputName !== NodeConnectionType.Main;
      });
      const anchorPosition = getAnchorPosition(
        outputName,
        "output",
        outputsOfSameRootType.length
      )[rootTypeIndex];
      if (!isValidNodeConnectionType(outputName)) {
        return;
      }
      const scope = getEndpointScope(outputName);
      const newEndpointData = {
        uuid: getOutputEndpointUUID(nodeId.value, outputName, typeIndex),
        anchor: anchorPosition,
        maxConnections: -1,
        endpoint: {
          type: "Dot",
          options: {
            radius: nodeTypeData && outputsOfSameRootType.length > 2 ? 7 : 9
          }
        },
        hoverPaintStyle: getOutputEndpointStyle(nodeTypeData, "--color-primary"),
        scope,
        source: true,
        target: outputName !== NodeConnectionType.Main,
        enabled: !isReadOnly,
        parameters: {
          connection: "source",
          nodeId: nodeId.value,
          type: outputName,
          index: typeIndex
        },
        hoverClass: "dot-output-endpoint-hover",
        connectionsDirected: true,
        dragAllowedWhenFull: false,
        ...getOutputConnectionStyle(outputName, outputConfiguration, nodeTypeData)
      };
      const endpoint = instance?.addEndpoint(
        refs.value[data.value?.name ?? ""],
        newEndpointData
      );
      if (!endpoint) {
        return;
      }
      addEndpointTestingData(endpoint, "output", typeIndex);
      if (outputConfiguration.displayName && isValidNodeConnectionType(outputName)) {
        const overlaySpec = getOutputNameOverlay(
          outputConfiguration.displayName,
          outputName,
          outputConfiguration?.category
        );
        endpoint.addOverlay(overlaySpec);
      }
      if (!Array.isArray(endpoint)) {
        endpoint.__meta = {
          nodeName: node2.name,
          nodeId: nodeId.value,
          index: typeIndex,
          totalEndpoints: outputsOfSameRootType.length,
          endpointLabelLength
        };
      }
      if (!isReadOnly && outputName === NodeConnectionType.Main) {
        const plusEndpointData = {
          uuid: getOutputEndpointUUID(nodeId.value, outputName, typeIndex),
          anchor: anchorPosition,
          maxConnections: -1,
          endpoint: {
            type: "N8nPlus",
            options: {
              dimensions: 24,
              connectedEndpoint: endpoint,
              showOutputLabel: outputs2.value.length === 1,
              size: outputs2.value.length >= 3 ? "small" : "medium",
              endpointLabelLength,
              hoverMessage: i18n.baseText("nodeBase.clickToAddNodeOrDragToConnect")
            }
          },
          source: true,
          target: false,
          enabled: !isReadOnly,
          paintStyle: {
            outlineStroke: "none"
          },
          hoverPaintStyle: {
            outlineStroke: "none"
          },
          parameters: {
            connection: "source",
            nodeId: nodeId.value,
            type: outputName,
            index: typeIndex,
            category: outputConfiguration?.category
          },
          cssClass: "plus-draggable-endpoint",
          dragAllowedWhenFull: false
        };
        if (outputConfiguration?.category) {
          plusEndpointData.cssClass = `${plusEndpointData.cssClass} ${outputConfiguration?.category}`;
        }
        if (!instance || !data.value) {
          return;
        }
        const plusEndpoint = instance.addEndpoint(
          refs.value[data.value.name],
          plusEndpointData
        );
        addEndpointTestingData(plusEndpoint, "plus", typeIndex);
        if (!Array.isArray(plusEndpoint)) {
          plusEndpoint.__meta = {
            nodeName: node2.name,
            nodeId: nodeId.value,
            index: typeIndex,
            nodeType: node2.type,
            totalEndpoints: outputsOfSameRootType.length
          };
        }
      }
    });
  }
  function addNode(node2) {
    const nodeTypeData = nodeTypesStore.getNodeType(node2.type, node2.typeVersion) ?? nodeTypesStore.getNodeType(NO_OP_NODE_TYPE);
    addInputEndpoints(node2, nodeTypeData);
    addOutputEndpoints(node2, nodeTypeData);
  }
  function getEndpointColor(connectionType2) {
    return `--node-type-${connectionType2}-color`;
  }
  function getInputConnectionStyle(connectionType2, nodeTypeData) {
    if (connectionType2 === NodeConnectionType.Main) {
      return {
        paintStyle: getInputEndpointStyle(
          nodeTypeData,
          getEndpointColor(NodeConnectionType.Main),
          connectionType2
        )
      };
    }
    if (!isValidNodeConnectionType(connectionType2)) {
      return {};
    }
    const createSupplementalConnectionType = (connectionName) => ({
      endpoint: createAddInputEndpointSpec(
        connectionName,
        getEndpointColor(connectionName)
      )
    });
    return createSupplementalConnectionType(connectionType2);
  }
  function getOutputConnectionStyle(connectionType2, outputConfiguration, nodeTypeData) {
    const createSupplementalConnectionType = (connectionName) => ({
      endpoint: createDiamondOutputEndpointSpec(),
      paintStyle: getOutputEndpointStyle(
        nodeTypeData,
        getEndpointColor(connectionName)
      ),
      hoverPaintStyle: getOutputEndpointStyle(
        nodeTypeData,
        getEndpointColor(connectionName)
      )
    });
    const type = "output";
    if (connectionType2 === NodeConnectionType.Main) {
      if (outputConfiguration.category === "error") {
        return {
          paintStyle: {
            ...getOutputEndpointStyle(
              nodeTypeData,
              getEndpointColor(NodeConnectionType.Main)
            ),
            fill: "var(--color-danger)"
          },
          cssClass: `dot-${type}-endpoint`
        };
      }
      return {
        paintStyle: getOutputEndpointStyle(
          nodeTypeData,
          getEndpointColor(NodeConnectionType.Main)
        ),
        cssClass: `dot-${type}-endpoint`
      };
    }
    if (!isValidNodeConnectionType(connectionType2)) {
      return {};
    }
    return createSupplementalConnectionType(connectionType2);
  }
  function touchEnd(_e) {
    if (deviceSupport.isTouchDevice && uiStore.isActionActive["dragActive"]) {
      uiStore.removeActiveAction("dragActive");
    }
  }
  function mouseLeftClick(e) {
    const path = e.path || e.composedPath?.();
    for (let index = 0; index < path.length; index++) {
      if (path[index].className && typeof path[index].className === "string" && path[index].className.includes("no-select-on-click")) {
        return;
      }
    }
    if (!deviceSupport.isTouchDevice) {
      if (uiStore.isActionActive["dragActive"]) {
        uiStore.removeActiveAction("dragActive");
      } else {
        if (!deviceSupport.isCtrlKeyPressed(e)) {
          emit("deselectAllNodes");
        }
        if (uiStore.isNodeSelected[data.value?.name ?? ""]) {
          emit("deselectNode", name);
        } else {
          emit("nodeSelected", name);
        }
      }
    }
  }
  return {
    getSpacerIndexes,
    addInputEndpoints,
    addOutputEndpoints,
    addNode,
    mouseLeftClick,
    touchEnd,
    inputs,
    outputs: outputs2
  };
}
const _hoisted_1$4 = ["id", "data-name"];
const _hoisted_2$3 = { class: "select-sticky-background" };
const _hoisted_3$1 = ["title"];
const _hoisted_4$1 = ["title"];
const _hoisted_5$1 = { class: "content" };
const _hoisted_6$1 = ["onClick"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  ...{ name: "Sticky" },
  __name: "Sticky",
  props: {
    nodeViewScale: { default: 1 },
    gridSize: { default: GRID_SIZE },
    name: {},
    instance: {},
    isReadOnly: { type: Boolean },
    isActive: { type: Boolean },
    hideActions: { type: Boolean },
    disableSelecting: { type: Boolean },
    showCustomTooltip: { type: Boolean },
    workflow: {}
  },
  emits: ["removeNode", "nodeSelected"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const deviceSupport = useDeviceSupport();
    const telemetry = useTelemetry();
    const toast = useToast();
    const ndvStore = useNDVStore();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const workflowsStore = useWorkflowsStore();
    const { APP_Z_INDEXES } = useStyles();
    const i18n = useI18n();
    const isResizing = ref(false);
    const isTouchActive = ref(false);
    const forceActions = ref(false);
    const isColorPopoverVisible = ref(false);
    const stickOptions = ref();
    const isEditing = ref(false);
    const setForceActions = (value) => {
      forceActions.value = value;
    };
    const setColorPopoverVisible = (value) => {
      isColorPopoverVisible.value = value;
    };
    const contextMenu = useContextMenu((action2) => {
      if (action2 === "change_color") {
        setForceActions(true);
        setColorPopoverVisible(true);
      }
    });
    const nodeBase = useNodeBase({
      name: props.name,
      instance: props.instance,
      workflowObject: props.workflow,
      isReadOnly: props.isReadOnly,
      emit
    });
    onClickOutside(stickOptions, () => setColorPopoverVisible(false));
    __expose({
      deviceSupport,
      toast,
      contextMenu,
      forceActions,
      ...nodeBase,
      setForceActions,
      isColorPopoverVisible,
      setColorPopoverVisible,
      stickOptions
    });
    const data = computed(() => workflowsStore.getNodeByName(props.name));
    const node2 = computed(() => workflowsStore.getNodeByName(props.name));
    const nodeId = computed(() => data.value?.id);
    const nodeType = computed(() => {
      return data.value && nodeTypesStore.getNodeType(data.value.type, data.value.typeVersion);
    });
    const defaultText = computed(() => {
      if (!nodeType.value) {
        return "";
      }
      const properties = nodeType.value.properties;
      const content2 = properties.find((property) => property.name === "content");
      return content2 && isString(content2.default) ? content2.default : "";
    });
    const isSelected = computed(
      () => uiStore.getSelectedNodes.find(({ name }) => name === data.value?.name) !== void 0
    );
    const position = computed(() => node2.value ? node2.value.position : [0, 0]);
    const height = computed(
      () => node2.value && isNumber(node2.value.parameters.height) ? node2.value.parameters.height : 0
    );
    const width = computed(
      () => node2.value && isNumber(node2.value.parameters.width) ? node2.value.parameters.width : 0
    );
    const stickySize = computed(() => ({
      height: height.value + "px",
      width: width.value + "px"
    }));
    const stickyPosition = computed(() => ({
      left: position.value[0] + "px",
      top: position.value[1] + "px",
      zIndex: props.isActive ? APP_Z_INDEXES.ACTIVE_STICKY : -1 * Math.floor(height.value * width.value / 1e3)
    }));
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const showActions = computed(
      () => !(props.hideActions || isEditing.value || props.isReadOnly || workflowRunning.value || isResizing.value) || forceActions.value
    );
    onMounted(() => {
      if (data.value !== null) {
        try {
          nodeBase.addNode(data.value);
        } catch (error) {
        }
      }
    });
    const onShowPopover = () => setForceActions(true);
    const onHidePopover = () => setForceActions(false);
    const deleteNode = async () => {
      assert(data.value);
      await nextTick();
      emit("removeNode", data.value.name);
    };
    const changeColor = (index) => {
      workflowsStore.updateNodeProperties({
        name: props.name,
        properties: {
          parameters: {
            ...node2.value?.parameters,
            color: index
          },
          position: node2.value?.position ?? [0, 0]
        }
      });
    };
    const onEdit = (edit) => {
      isEditing.value = edit;
      if (edit && !props.isActive && node2.value) {
        ndvStore.activeNodeName = node2.value.name;
      } else if (props.isActive && !edit) {
        ndvStore.activeNodeName = null;
      }
    };
    const onMarkdownClick = (link) => {
      if (link) {
        telemetry.track("User clicked note link", { type: "other" });
      }
    };
    const setParameters = (params) => {
      if (node2.value) {
        const nodeParameters = {
          content: isString(params.content) ? params.content : node2.value.parameters.content,
          height: isNumber(params.height) ? params.height : node2.value.parameters.height,
          width: isNumber(params.width) ? params.width : node2.value.parameters.width,
          color: isString(params.color) ? params.color : node2.value.parameters.color
        };
        workflowsStore.setNodeParameters({
          key: node2.value.id,
          name: node2.value.name,
          value: nodeParameters
        });
      }
    };
    const onInputChange = (content2) => {
      if (!node2.value) {
        return;
      }
      node2.value.parameters.content = content2;
      setParameters({ content: content2 });
    };
    const setPosition = (newPosition) => {
      if (!node2.value) return;
      workflowsStore.updateNodeProperties({
        name: node2.value.name,
        properties: { position: newPosition }
      });
    };
    const onResizeStart = () => {
      isResizing.value = true;
      if (!isSelected.value && node2.value) {
        emit("nodeSelected", node2.value.name, false, true);
      }
    };
    const onResize = ({
      height: height2,
      width: width2,
      dX,
      dY
    }) => {
      if (!node2.value) {
        return;
      }
      if (dX !== 0 || dY !== 0) {
        setPosition([node2.value.position[0] + (dX || 0), node2.value.position[1] + (dY || 0)]);
      }
      setParameters({ height: height2, width: width2 });
    };
    const onResizeEnd = () => {
      isResizing.value = false;
    };
    const touchStart = () => {
      if (deviceSupport.isTouchDevice && !deviceSupport.isMacOs && !isTouchActive.value) {
        isTouchActive.value = true;
        setTimeout(() => {
          isTouchActive.value = false;
        }, 2e3);
      }
    };
    const onContextMenu = (e) => {
      if (node2.value && !props.isActive) {
        contextMenu.open(e, { source: "node-right-click", nodeId: node2.value.id });
      } else {
        e.stopPropagation();
      }
    };
    return (_ctx, _cache) => {
      const _component_N8nResizeableSticky = resolveComponent("N8nResizeableSticky");
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_popover = resolveComponent("n8n-popover");
      const _directive_touch = resolveDirective("touch");
      return openBlock(), createElementBlock("div", {
        id: nodeId.value,
        ref: data.value?.name,
        class: "sticky-wrapper",
        style: normalizeStyle(stickyPosition.value),
        "data-name": data.value?.name,
        "data-test-id": "sticky"
      }, [
        createBaseVNode("div", {
          class: normalizeClass({
            "sticky-default": true,
            "touch-active": isTouchActive.value,
            "is-touch-device": unref(deviceSupport).isTouchDevice,
            "is-read-only": _ctx.isReadOnly
          }),
          style: normalizeStyle(stickySize.value)
        }, [
          withDirectives(createBaseVNode("div", _hoisted_2$3, null, 512), [
            [vShow, isSelected.value]
          ]),
          withDirectives((openBlock(), createElementBlock("div", {
            class: "sticky-box",
            onClick: _cache[0] || (_cache[0] = withModifiers(
              //@ts-ignore
              (...args) => unref(nodeBase).mouseLeftClick && unref(nodeBase).mouseLeftClick(...args),
              ["left"]
            )),
            onContextmenu: onContextMenu
          }, [
            node2.value ? (openBlock(), createBlock(_component_N8nResizeableSticky, {
              key: 0,
              id: node2.value.id,
              "model-value": node2.value.parameters.content,
              height: node2.value.parameters.height,
              width: node2.value.parameters.width,
              scale: _ctx.nodeViewScale,
              "background-color": node2.value.parameters.color,
              "read-only": _ctx.isReadOnly,
              "default-text": defaultText.value,
              "edit-mode": _ctx.isActive && !_ctx.isReadOnly,
              "grid-size": _ctx.gridSize,
              onEdit,
              onResizestart: onResizeStart,
              onResize,
              onResizeend: onResizeEnd,
              onMarkdownClick,
              "onUpdate:modelValue": onInputChange
            }, null, 8, ["id", "model-value", "height", "width", "scale", "background-color", "read-only", "default-text", "edit-mode", "grid-size"])) : createCommentVNode("", true)
          ], 32)), [
            [_directive_touch, touchStart, "start"],
            [_directive_touch, unref(nodeBase).touchEnd, "end"]
          ]),
          withDirectives(createBaseVNode("div", {
            ref_key: "stickOptions",
            ref: stickOptions,
            class: normalizeClass({ "sticky-options": true, "no-select-on-click": true, "force-show": forceActions.value })
          }, [
            withDirectives((openBlock(), createElementBlock("div", {
              class: "option",
              "data-test-id": "delete-sticky",
              title: unref(i18n).baseText("node.delete")
            }, [
              createVNode(_component_font_awesome_icon, { icon: "trash" })
            ], 8, _hoisted_3$1)), [
              [_directive_touch, deleteNode, "tap"]
            ]),
            createVNode(_component_n8n_popover, {
              effect: "dark",
              trigger: "click",
              placement: "top",
              "popper-style": { width: "208px" },
              visible: isColorPopoverVisible.value,
              onShow: onShowPopover,
              onHide: onHidePopover
            }, {
              reference: withCtx(() => [
                createBaseVNode("div", {
                  class: "option",
                  "data-test-id": "change-sticky-color",
                  title: unref(i18n).baseText("node.changeColor"),
                  onClick: _cache[1] || (_cache[1] = () => setColorPopoverVisible(!isColorPopoverVisible.value))
                }, [
                  createVNode(_component_font_awesome_icon, { icon: "palette" })
                ], 8, _hoisted_4$1)
              ]),
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_5$1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(Array.from({ length: 7 }), (_, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(["color", `sticky-color-${index + 1}`]),
                      "data-test-id": "color",
                      style: normalizeStyle({
                        "border-width": "1px",
                        "border-style": "solid",
                        "border-color": "var(--color-foreground-xdark)",
                        "background-color": `var(--color-sticky-background-${index + 1})`,
                        "box-shadow": index === 0 && node2.value?.parameters.color === "" || index + 1 === node2.value?.parameters.color ? `0 0 0 1px var(--color-sticky-background-${index + 1})` : "none"
                      }),
                      onClick: ($event) => changeColor(index + 1)
                    }, null, 14, _hoisted_6$1);
                  }), 128))
                ])
              ]),
              _: 1
            }, 8, ["visible"])
          ], 2), [
            [vShow, showActions.value]
          ])
        ], 6)
      ], 12, _hoisted_1$4);
    };
  }
});
const __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-dcc29189"]]);
const _hoisted_1$3 = ["id", "data-name", "data-node-type"];
const _hoisted_2$2 = { class: "select-background" };
const _hoisted_3 = {
  key: 0,
  class: "trigger-icon"
};
const _hoisted_4 = {
  key: 0,
  class: "node-issues",
  "data-test-id": "node-issues"
};
const _hoisted_5 = {
  key: 1,
  class: "waiting"
};
const _hoisted_6 = ["textContent"];
const _hoisted_7 = {
  key: 2,
  class: "node-pin-data-icon"
};
const _hoisted_8 = {
  key: 0,
  class: "items-count"
};
const _hoisted_9 = { key: 3 };
const _hoisted_10 = {
  key: 4,
  class: "data-count"
};
const _hoisted_11 = {
  key: 0,
  class: "items-count"
};
const _hoisted_12 = ["title"];
const _hoisted_13 = ["title"];
const _hoisted_14 = { class: "node-trigger-tooltip__wrapper" };
const _hoisted_15 = ["textContent"];
const _hoisted_16 = { class: "node-description" };
const _hoisted_17 = ["title"];
const _hoisted_18 = { "data-test-id": "canvas-node-box-title" };
const _hoisted_19 = { key: 0 };
const _hoisted_20 = ["title"];
const _hoisted_21 = { class: "node-options-inner" };
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "Node",
  props: {
    name: {},
    instance: {},
    workflow: {},
    isReadOnly: { type: Boolean, default: false },
    isActive: { type: Boolean, default: false },
    hideActions: { type: Boolean, default: false },
    disableSelecting: { type: Boolean, default: false },
    showCustomTooltip: { type: Boolean, default: false },
    isProductionExecutionPreview: { type: Boolean, default: false },
    disablePointerEvents: { type: Boolean, default: false },
    hideNodeIssues: { type: Boolean, default: false }
  },
  emits: ["run", "runWorkflow", "removeNode", "toggleDisableNode"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const uiStore = useUIStore();
    const contextMenu = useContextMenu();
    const nodeHelpers = useNodeHelpers();
    const pinnedData = usePinnedData(workflowsStore.getNodeByName(props.name));
    const deviceSupport = useDeviceSupport();
    const { callDebounced } = useDebounce();
    const i18n = useI18n();
    const telemetry = useTelemetry();
    const nodeBase = useNodeBase({
      name: props.name,
      instance: props.instance,
      workflowObject: props.workflow,
      isReadOnly: props.isReadOnly,
      emit
    });
    const isTouchActive = ref(false);
    const nodeSubtitle = ref("");
    const showTriggerNodeTooltip = ref(false);
    const pinDataDiscoveryTooltipVisible = ref(false);
    const dragging2 = ref(false);
    const node2 = computed(() => workflowsStore.getNodeByName(props.name));
    const nodeId = computed(() => node2.value?.id ?? "");
    const showPinnedDataInfo = computed(
      () => pinnedData.hasData.value && !props.isProductionExecutionPreview
    );
    const isScheduledGroup = computed(() => nodeType.value?.group.includes("schedule") === true);
    const iconColorDefault = computed(() => {
      if (isConfigNode.value) {
        return "var(--color-text-base)";
      }
      return void 0;
    });
    const nodeRunData = computed(() => {
      if (!node2.value) return [];
      return workflowsStore.getWorkflowResultDataByNodeName(node2.value.name) ?? [];
    });
    const hasIssues2 = computed(() => {
      if (nodeExecutionStatus.value && ["crashed", "error"].includes(nodeExecutionStatus.value))
        return true;
      if (pinnedData.hasData.value) return false;
      if (node2.value?.issues !== void 0 && Object.keys(node2.value.issues).length) {
        return true;
      }
      return false;
    });
    const workflowDataItems = computed(() => {
      const workflowResultDataNode = nodeRunData.value;
      if (workflowResultDataNode === null) {
        return 0;
      }
      return workflowResultDataNode.length;
    });
    const canvasOffsetPosition = computed(() => uiStore.nodeViewOffsetPosition);
    const getTriggerNodeTooltip = computed(() => {
      if (nodeType.value !== null && nodeType.value.hasOwnProperty("eventTriggerDescription")) {
        const nodeName = i18n.shortNodeType(nodeType.value.name);
        const { eventTriggerDescription } = nodeType.value;
        return i18n.nodeText().eventTriggerDescription(nodeName, eventTriggerDescription ?? "");
      } else {
        return i18n.baseText("node.waitingForYouToCreateAnEventIn", {
          interpolate: {
            nodeType: nodeType.value ? getTriggerNodeServiceName(nodeType.value) : ""
          }
        });
      }
    });
    const isPollingTypeNode = computed(() => !!nodeType.value?.polling);
    const isExecuting = computed(() => {
      if (!node2.value || !workflowRunning.value) return false;
      return workflowsStore.isNodeExecuting(node2.value.name);
    });
    const isSingleActiveTriggerNode = computed(() => {
      const nodes = workflowsStore.workflowTriggerNodes.filter((triggerNode) => {
        const nodeType2 = nodeTypesStore.getNodeType(triggerNode.type, triggerNode.typeVersion);
        return nodeType2 && nodeType2.eventTriggerDescription !== "" && !triggerNode.disabled;
      });
      return nodes.length === 1;
    });
    const isManualTypeNode = computed(() => node2.value?.type === MANUAL_TRIGGER_NODE_TYPE);
    const isConfigNode = computed(() => {
      if (!node2.value) return false;
      return nodeTypesStore.isConfigNode(props.workflow, node2.value, node2.value.type ?? "");
    });
    const isConfigurableNode = computed(() => {
      if (!node2.value) return false;
      return nodeTypesStore.isConfigurableNode(props.workflow, node2.value, node2.value?.type ?? "");
    });
    const isTriggerNode = computed(
      () => node2.value ? nodeTypesStore.isTriggerNode(node2.value.type) : false
    );
    const isTriggerNodeTooltipEmpty = computed(
      () => nodeType.value !== null ? nodeType.value.eventTriggerDescription === "" : false
    );
    const isNodeDisabled = computed(() => node2.value?.disabled ?? false);
    const nodeType = computed(
      () => node2.value && nodeTypesStore.getNodeType(node2.value.type, node2.value.typeVersion)
    );
    const nodeWrapperClass = computed(() => {
      const classes = {
        "node-wrapper": true,
        "node-wrapper--trigger": isTriggerNode.value,
        "node-wrapper--configurable": isConfigurableNode.value,
        "node-wrapper--config": isConfigNode.value
      };
      if (nodeBase.outputs.value.length) {
        const outputTypes = getConnectionTypes(nodeBase.outputs.value);
        const otherOutputs = outputTypes.filter((outputName) => outputName !== NodeConnectionType.Main);
        if (otherOutputs.length) {
          otherOutputs.forEach((outputName) => {
            classes[`node-wrapper--connection-type-${outputName}`] = true;
          });
        }
      }
      return classes;
    });
    const nodeWrapperStyles = computed(() => {
      const styles = {
        left: position.value[0] + "px",
        top: position.value[1] + "px"
      };
      if (node2.value && nodeType.value) {
        const inputs = getNodeInputs(props.workflow, node2.value, nodeType.value) ?? [];
        const inputTypes = getConnectionTypes(inputs);
        const nonMainInputs = inputTypes.filter((input) => input !== NodeConnectionType.Main);
        if (nonMainInputs.length) {
          inputs.filter(
            (input) => typeof input !== "string" && input.required
          );
          let spacerCount = 0;
          styles["--configurable-node-input-count"] = nonMainInputs.length + spacerCount;
        }
        const mainInputs = inputTypes.filter((output) => output === NodeConnectionType.Main);
        styles["--node-main-input-count"] = mainInputs.length;
        let outputs2 = [];
        if (props.workflow.nodes[node2.value.name]) {
          outputs2 = getNodeOutputs(props.workflow, node2.value, nodeType.value);
        }
        const outputTypes = getConnectionTypes(outputs2);
        const mainOutputs = outputTypes.filter((output) => output === NodeConnectionType.Main);
        styles["--node-main-output-count"] = mainOutputs.length;
      }
      return styles;
    });
    const nodeClass = computed(() => {
      return {
        "node-box": true,
        disabled: node2.value?.disabled,
        executing: isExecuting.value
      };
    });
    const nodeExecutionStatus = computed(() => {
      const nodeExecutionRunData = workflowsStore.getWorkflowRunData?.[props.name];
      if (nodeExecutionRunData) {
        return nodeExecutionRunData.filter(Boolean)?.[0]?.executionStatus ?? "";
      }
      return "";
    });
    const nodeIssues = computed(() => {
      const issues = [];
      const nodeExecutionRunData = workflowsStore.getWorkflowRunData?.[props.name];
      if (nodeExecutionRunData) {
        nodeExecutionRunData.forEach((executionRunData) => {
          if (executionRunData?.error) {
            const { message, description } = executionRunData.error;
            const issue = `${message}${description ? ` (${description})` : ""}`;
            issues.push(xss(issue));
          }
        });
      }
      if (node2.value?.issues !== void 0) {
        issues.push(...nodeIssuesToString(node2.value.issues, node2.value));
      }
      return issues;
    });
    const nodeDisabledTitle = computed(() => {
      return node2.value?.disabled ? i18n.baseText("node.enable") : i18n.baseText("node.disable");
    });
    const position = computed(() => node2.value ? node2.value.position : [0, 0]);
    const showDisabledLineThrough = computed(
      () => !isConfigurableNode.value && !!(node2.value?.disabled && nodeBase.inputs.value.length === 1 && nodeBase.outputs.value.length === 1)
    );
    const nodeTitle = computed(() => {
      if (node2.value?.name === "Start") {
        return i18n.headerText({
          key: "headers.start.displayName",
          fallback: "Start"
        });
      }
      return node2.value?.name ?? "";
    });
    const waiting = computed(() => {
      const workflowExecution = workflowsStore.getWorkflowExecution;
      if (workflowExecution?.waitTill && !workflowExecution?.finished) {
        const lastNodeExecuted = get(workflowExecution, "data.resultData.lastNodeExecuted");
        if (props.name === lastNodeExecuted) {
          const node22 = props.workflow.getNode(lastNodeExecuted);
          if (node22 && node22.type === WAIT_NODE_TYPE && ["webhook", "form"].includes(node22.parameters.resume)) {
            const event = node22.parameters.resume === "webhook" ? i18n.baseText("node.theNodeIsWaitingWebhookCall") : i18n.baseText("node.theNodeIsWaitingFormCall");
            return event;
          }
          if (node22?.parameters.operation === SEND_AND_WAIT_OPERATION) {
            return i18n.baseText("node.theNodeIsWaitingUserInput");
          }
          if (node22?.type === FORM_NODE_TYPE) {
            return i18n.baseText("node.theNodeIsWaitingFormCall");
          }
          const waitDate = new Date(workflowExecution.waitTill);
          if (waitDate.getTime() === WAIT_INDEFINITELY.getTime()) {
            return i18n.baseText("node.theNodeIsWaitingIndefinitelyForAnIncomingWebhookCall");
          }
          return i18n.baseText("node.nodeIsWaitingTill", {
            interpolate: {
              date: waitDate.toLocaleDateString(),
              time: waitDate.toLocaleTimeString()
            }
          });
        }
      }
      return void 0;
    });
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const nodeStyle = computed(() => {
      const returnStyles = {};
      let borderColor = "--color-foreground-xdark";
      if (isConfigurableNode.value || isConfigNode.value) {
        borderColor = "--color-foreground-dark";
      }
      if (node2.value?.disabled) {
        borderColor = "--color-foreground-base";
      } else if (!isExecuting.value) {
        if (hasIssues2.value && !props.hideNodeIssues) {
          if (nodeRunData.value?.[0]?.error?.functionality !== "configuration-node") {
            borderColor = "--color-danger";
            returnStyles["border-width"] = "2px";
            returnStyles["border-style"] = "solid";
          }
        } else if (!!waiting.value || showPinnedDataInfo.value) {
          borderColor = "--color-node-pinned-border";
        } else if (nodeExecutionStatus.value === "unknown") {
          borderColor = "--color-foreground-xdark";
        } else if (workflowDataItems.value) {
          returnStyles["border-width"] = "2px";
          returnStyles["border-style"] = "solid";
          borderColor = "--color-success";
        }
      }
      returnStyles["border-color"] = `var(${borderColor})`;
      return returnStyles;
    });
    const isSelected = computed(
      () => uiStore.getSelectedNodes.find((n) => n.name === node2.value?.name) !== void 0
    );
    const shiftOutputCount = computed(() => !!(nodeType.value && nodeBase.outputs.value.length > 2));
    const shouldShowTriggerTooltip = computed(() => {
      return !!node2.value && isTriggerNode.value && !isPollingTypeNode.value && !pinnedData.hasData.value && !isNodeDisabled.value && workflowRunning.value && workflowDataItems.value === 0 && isSingleActiveTriggerNode.value && !isTriggerNodeTooltipEmpty.value && !hasIssues2.value && !dragging2.value;
    });
    const isContextMenuOpen = computed(
      () => contextMenu.isOpen.value && contextMenu.target.value?.source === "node-button" && contextMenu.target.value.nodeId === node2.value?.id
    );
    const iconNodeType = computed(() => {
      if (node2.value?.type === SIMULATE_NODE_TYPE || node2.value?.type === SIMULATE_TRIGGER_NODE_TYPE) {
        const icon2 = node2.value.parameters?.icon;
        const iconValue = props.workflow.expression.getSimpleParameterValue(
          node2.value,
          icon2,
          "internal",
          {}
        );
        if (iconValue && typeof iconValue === "string") {
          return nodeTypesStore.getNodeType(iconValue);
        }
      }
      return nodeType.value;
    });
    const hasSeenPinDataTooltip = useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG);
    watch(
      () => props.isActive,
      (newValue, oldValue) => {
        if (!newValue && oldValue) {
          setSubtitle();
        }
      }
    );
    watch(canvasOffsetPosition, () => {
      if (showTriggerNodeTooltip.value) {
        showTriggerNodeTooltip.value = false;
        setTimeout(() => {
          showTriggerNodeTooltip.value = shouldShowTriggerTooltip.value;
        }, 200);
      }
      if (pinDataDiscoveryTooltipVisible.value) {
        pinDataDiscoveryTooltipVisible.value = false;
        setTimeout(() => {
          pinDataDiscoveryTooltipVisible.value = true;
        }, 200);
      }
    });
    watch(shouldShowTriggerTooltip, (newValue) => {
      if (newValue) {
        setTimeout(() => {
          showTriggerNodeTooltip.value = shouldShowTriggerTooltip.value;
        }, 2500);
      } else {
        showTriggerNodeTooltip.value = false;
      }
    });
    watch(
      nodeRunData,
      (newValue) => {
        if (!node2.value) {
          return;
        }
        emit("run", { name: node2.value.name, data: newValue, waiting: !!waiting.value });
      },
      { deep: true }
    );
    const unwatchWorkflowDataItems = watch(workflowDataItems, (dataItemsCount) => {
      if (!hasSeenPinDataTooltip.value) showPinDataDiscoveryTooltip(dataItemsCount);
    });
    onMounted(() => {
      if (node2.value !== null) {
        try {
          nodeBase.addNode(node2.value);
        } catch (error) {
        }
      }
      setTimeout(() => {
        setSubtitle();
      }, 0);
      setTimeout(() => {
        if (nodeRunData.value && node2.value) {
          emit("run", {
            name: node2.value.name,
            data: nodeRunData.value,
            waiting: !!waiting.value
          });
        }
      }, 0);
    });
    function showPinDataDiscoveryTooltip(dataItemsCount) {
      if (!isTriggerNode.value || isManualTypeNode.value || isScheduledGroup.value || uiStore.isAnyModalOpen || dataItemsCount === 0 || pinnedData.hasData.value)
        return;
      useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG).value = "true";
      pinDataDiscoveryTooltipVisible.value = true;
      unwatchWorkflowDataItems();
    }
    function setSubtitle() {
      if (!node2.value || !nodeType.value) return;
      try {
        const subtitle2 = nodeHelpers.getNodeSubtitle(node2.value, nodeType.value, props.workflow) ?? "";
        nodeSubtitle.value = subtitle2.includes(CUSTOM_API_CALL_KEY) ? "" : subtitle2;
      } catch (e) {
      }
    }
    function executeNode() {
      if (!node2.value) return;
      emit("runWorkflow", node2.value.name, "Node.executeNode");
      telemetry.track("User clicked node hover button", {
        node_type: node2.value.type,
        button_name: "execute",
        workflow_id: workflowsStore.workflowId
      });
    }
    function deleteNode() {
      if (!node2.value) return;
      telemetry.track("User clicked node hover button", {
        node_type: node2.value.type,
        button_name: "delete",
        workflow_id: workflowsStore.workflowId
      });
      emit("removeNode", node2.value.name);
    }
    function toggleDisableNode(event) {
      if (!node2.value) return;
      event.currentTarget.blur();
      telemetry.track("User clicked node hover button", {
        node_type: node2.value?.type,
        button_name: "disable",
        workflow_id: workflowsStore.workflowId
      });
      emit("toggleDisableNode", node2.value);
    }
    function onClick(event) {
      void callDebounced(onClickDebounced, { debounceTime: 50, trailing: true }, event);
    }
    function onClickDebounced(...args) {
      const event = args[0];
      const isDoubleClick = event.detail >= 2;
      if (isDoubleClick) {
        setNodeActive();
      } else {
        nodeBase.mouseLeftClick(event);
      }
    }
    function setNodeActive() {
      ndvStore.activeNodeName = node2.value ? node2.value.name : "";
      pinDataDiscoveryTooltipVisible.value = false;
    }
    function touchStart() {
      if (deviceSupport.isTouchDevice && !deviceSupport.isMacOs && !isTouchActive.value) {
        isTouchActive.value = true;
        setTimeout(() => {
          isTouchActive.value = false;
        }, 2e3);
      }
    }
    const touchEnd = nodeBase.touchEnd;
    function openContextMenu(event, source) {
      if (node2.value) {
        contextMenu.open(event, { source, nodeId: node2.value.id });
      }
    }
    return (_ctx, _cache) => {
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      const _directive_n8n_html = resolveDirective("n8n-html");
      const _directive_touch = resolveDirective("touch");
      return node2.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        id: nodeId.value,
        ref: node2.value.name,
        class: normalizeClass(nodeWrapperClass.value),
        style: normalizeStyle(nodeWrapperStyles.value),
        "data-test-id": "canvas-node",
        "data-name": node2.value.name,
        "data-node-type": nodeType.value?.name,
        onContextmenu: _cache[3] || (_cache[3] = (e) => openContextMenu(e, "node-right-click"))
      }, [
        withDirectives(createBaseVNode("div", _hoisted_2$2, null, 512), [
          [vShow, isSelected.value]
        ]),
        createBaseVNode("div", {
          class: normalizeClass({
            "node-default": true,
            "touch-active": isTouchActive.value,
            "is-touch-device": unref(deviceSupport).isTouchDevice,
            "menu-open": isContextMenuOpen.value,
            "disable-pointer-events": _ctx.disablePointerEvents
          })
        }, [
          withDirectives((openBlock(), createElementBlock("div", {
            class: normalizeClass(nodeClass.value),
            style: normalizeStyle(nodeStyle.value),
            onClick: withModifiers(onClick, ["left"])
          }, [
            isTriggerNode.value ? (openBlock(), createElementBlock("i", _hoisted_3, [
              createVNode(_component_n8n_tooltip, { placement: "bottom" }, {
                content: withCtx(() => [
                  withDirectives(createBaseVNode("span", null, null, 512), [
                    [_directive_n8n_html, unref(i18n).baseText("node.thisIsATriggerNode")]
                  ])
                ]),
                default: withCtx(() => [
                  createVNode(unref(FontAwesomeIcon), {
                    icon: "bolt",
                    size: "lg"
                  })
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true),
            !node2.value.disabled ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass({ "node-info-icon": true, "shift-icon": shiftOutputCount.value })
            }, [
              hasIssues2.value && !_ctx.hideNodeIssues ? (openBlock(), createElementBlock("div", _hoisted_4, [
                createVNode(_component_n8n_tooltip, {
                  "show-after": 500,
                  placement: "bottom"
                }, {
                  content: withCtx(() => [
                    createVNode(TitledList, {
                      title: `${unref(i18n).baseText("node.issues")}:`,
                      items: nodeIssues.value
                    }, null, 8, ["title", "items"])
                  ]),
                  default: withCtx(() => [
                    createVNode(unref(FontAwesomeIcon), { icon: "exclamation-triangle" })
                  ]),
                  _: 1
                })
              ])) : waiting.value || nodeExecutionStatus.value === "waiting" ? (openBlock(), createElementBlock("div", _hoisted_5, [
                createVNode(_component_n8n_tooltip, { placement: "bottom" }, {
                  content: withCtx(() => [
                    createBaseVNode("div", {
                      textContent: toDisplayString(waiting.value)
                    }, null, 8, _hoisted_6)
                  ]),
                  default: withCtx(() => [
                    createVNode(unref(FontAwesomeIcon), { icon: "clock" })
                  ]),
                  _: 1
                })
              ])) : showPinnedDataInfo.value ? (openBlock(), createElementBlock("span", _hoisted_7, [
                createVNode(unref(FontAwesomeIcon), { icon: "thumbtack" }),
                workflowDataItems.value > 1 ? (openBlock(), createElementBlock("span", _hoisted_8, toDisplayString(workflowDataItems.value), 1)) : createCommentVNode("", true)
              ])) : nodeExecutionStatus.value === "unknown" ? (openBlock(), createElementBlock("span", _hoisted_9)) : workflowDataItems.value ? (openBlock(), createElementBlock("span", _hoisted_10, [
                createVNode(unref(FontAwesomeIcon), { icon: "check" }),
                workflowDataItems.value > 1 ? (openBlock(), createElementBlock("span", _hoisted_11, toDisplayString(workflowDataItems.value), 1)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ], 2)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "node-executing-info",
              title: unref(i18n).baseText("node.nodeIsExecuting")
            }, [
              createVNode(unref(FontAwesomeIcon), {
                icon: "sync-alt",
                spin: ""
              })
            ], 8, _hoisted_12),
            waiting.value ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: "node-waiting-spinner",
              title: waiting.value
            }, [
              createVNode(unref(FontAwesomeIcon), {
                icon: "sync-alt",
                spin: ""
              })
            ], 8, _hoisted_13)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_14, [
              createVNode(_component_n8n_tooltip, {
                placement: "top",
                "show-after": 500,
                visible: showTriggerNodeTooltip.value,
                "popper-class": "node-trigger-tooltip__wrapper--item"
              }, {
                content: withCtx(() => [
                  createBaseVNode("div", {
                    textContent: toDisplayString(getTriggerNodeTooltip.value)
                  }, null, 8, _hoisted_15)
                ]),
                default: withCtx(() => [
                  _cache[4] || (_cache[4] = createBaseVNode("span", null, null, -1))
                ]),
                _: 1
              }, 8, ["visible"]),
              isTriggerNode.value ? (openBlock(), createBlock(_component_n8n_tooltip, {
                key: 0,
                placement: "top",
                visible: pinDataDiscoveryTooltipVisible.value,
                "popper-class": "node-trigger-tooltip__wrapper--item"
              }, {
                content: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n).baseText("node.discovery.pinData.canvas")), 1)
                ]),
                default: withCtx(() => [
                  _cache[5] || (_cache[5] = createBaseVNode("span", null, null, -1))
                ]),
                _: 1
              }, 8, ["visible"])) : createCommentVNode("", true)
            ]),
            createVNode(_sfc_main$z, {
              class: "node-icon",
              "node-type": iconNodeType.value,
              size: 40,
              shrink: false,
              "color-default": iconColorDefault.value,
              disabled: node2.value.disabled
            }, null, 8, ["node-type", "color-default", "disabled"])
          ], 6)), [
            [_directive_touch, touchStart, "start"],
            [_directive_touch, unref(touchEnd), "end"]
          ]),
          showDisabledLineThrough.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass({
              "disabled-line-through": true,
              success: !["unknown"].includes(nodeExecutionStatus.value) && workflowDataItems.value > 0
            })
          }, null, 2)) : createCommentVNode("", true)
        ], 2),
        createBaseVNode("div", _hoisted_16, [
          createBaseVNode("div", {
            class: "node-name",
            title: nodeTitle.value
          }, [
            createBaseVNode("p", _hoisted_18, toDisplayString(nodeTitle.value), 1),
            node2.value.disabled ? (openBlock(), createElementBlock("p", _hoisted_19, "(" + toDisplayString(unref(i18n).baseText("node.disabled")) + ")", 1)) : createCommentVNode("", true)
          ], 8, _hoisted_17),
          nodeSubtitle.value !== void 0 ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "node-subtitle",
            title: nodeSubtitle.value
          }, toDisplayString(nodeSubtitle.value), 9, _hoisted_20)) : createCommentVNode("", true)
        ]),
        !_ctx.isReadOnly ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          class: "node-options no-select-on-click",
          onContextmenu: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"]))
        }, [
          createBaseVNode("div", _hoisted_21, [
            !isConfigNode.value ? (openBlock(), createBlock(unref(_sfc_main$B), {
              key: 0,
              "data-test-id": "execute-node-button",
              type: "tertiary",
              text: "",
              size: "small",
              icon: "play",
              disabled: workflowRunning.value,
              title: unref(i18n).baseText("node.testStep"),
              onClick: executeNode
            }, null, 8, ["disabled", "title"])) : createCommentVNode("", true),
            createVNode(unref(_sfc_main$B), {
              "data-test-id": "disable-node-button",
              type: "tertiary",
              text: "",
              size: "small",
              icon: "power-off",
              title: nodeDisabledTitle.value,
              onClick: toggleDisableNode
            }, null, 8, ["title"]),
            createVNode(unref(_sfc_main$B), {
              "data-test-id": "delete-node-button",
              type: "tertiary",
              size: "small",
              text: "",
              icon: "trash",
              title: unref(i18n).baseText("node.delete"),
              onClick: deleteNode
            }, null, 8, ["title"]),
            createVNode(unref(_sfc_main$B), {
              "data-test-id": "overflow-node-button",
              type: "tertiary",
              size: "small",
              text: "",
              icon: "ellipsis-h",
              onClick: _cache[0] || (_cache[0] = (e) => openContextMenu(e, "node-button"))
            })
          ])
        ], 544)), [
          [vShow, !_ctx.hideActions]
        ]) : createCommentVNode("", true)
      ], 46, _hoisted_1$3)) : createCommentVNode("", true);
    };
  }
});
const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-47aff4de"]]);
const state = reactive({
  customActions: {},
  delegatedClickHandler: null
});
function useGlobalLinkActions() {
  function registerCustomAction({ key, action: action2 }) {
    state.customActions[key] = action2;
  }
  function unregisterCustomAction(key) {
    const { [key]: _, ...rest } = state.customActions;
    state.customActions = rest;
  }
  function getElementAttributes(element) {
    const attributesObject = {};
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.name.startsWith("data-action-parameter-")) {
        attributesObject[attr.name.replace("data-action-parameter-", "")] = attr.value;
      }
    }
    return attributesObject;
  }
  function delegateClick(e) {
    const clickedElement = e.target;
    if (!(clickedElement instanceof Element) || clickedElement.tagName !== "A") return;
    const actionAttribute = clickedElement.getAttribute("data-action");
    if (actionAttribute && typeof availableActions.value[actionAttribute] === "function") {
      e.preventDefault();
      const elementAttributes = getElementAttributes(clickedElement);
      availableActions.value[actionAttribute](elementAttributes);
    }
  }
  function reload() {
    if (window.top) {
      window.top.location.reload();
    } else {
      window.location.reload();
    }
  }
  const availableActions = computed(() => ({
    reload,
    ...state.customActions
  }));
  onMounted(() => {
    if (state.delegatedClickHandler) return;
    state.delegatedClickHandler = delegateClick;
    window.addEventListener("click", delegateClick);
    globalLinkActionsEventBus.on("registerGlobalLinkAction", registerCustomAction);
  });
  onUnmounted(() => {
    window.removeEventListener("click", delegateClick);
    state.delegatedClickHandler = null;
    globalLinkActionsEventBus.off("registerGlobalLinkAction", registerCustomAction);
  });
  return {
    registerCustomAction,
    unregisterCustomAction
  };
}
function useCanvasMouseSelect() {
  const selectActive = ref(false);
  const selectBox = ref(document.createElement("span"));
  const { isTouchDevice, isCtrlKeyPressed } = useDeviceSupport();
  const uiStore = useUIStore();
  const canvasStore = useCanvasStore();
  const workflowsStore = useWorkflowsStore();
  const { isOpen: isContextMenuOpen } = useContextMenu();
  const { APP_Z_INDEXES } = useStyles();
  function _setSelectBoxStyle(styles) {
    Object.assign(selectBox.value.style, styles);
  }
  function _showSelectBox(event) {
    const [x, y] = getMousePositionWithinNodeView(event);
    selectBox.value = Object.assign(selectBox.value, { x, y });
    _setSelectBoxStyle({
      left: selectBox.value.x + "px",
      top: selectBox.value.y + "px",
      visibility: "visible"
    });
    selectActive.value = true;
  }
  function _updateSelectBox(event) {
    const selectionBox = _getSelectionBox(event);
    _setSelectBoxStyle({
      left: selectionBox.x + "px",
      top: selectionBox.y + "px",
      width: selectionBox.width + "px",
      height: selectionBox.height + "px"
    });
  }
  function _hideSelectBox() {
    selectBox.value.x = 0;
    selectBox.value.y = 0;
    _setSelectBoxStyle({
      visibility: "hidden",
      left: "0px",
      top: "0px",
      width: "0px",
      height: "0px"
    });
    selectActive.value = false;
  }
  function _getSelectionBox(event) {
    const [x, y] = getMousePositionWithinNodeView(event);
    return {
      x: Math.min(x, selectBox.value.x),
      y: Math.min(y, selectBox.value.y),
      width: Math.abs(x - selectBox.value.x),
      height: Math.abs(y - selectBox.value.y)
    };
  }
  function _getNodesInSelection(event) {
    const returnNodes = [];
    const selectionBox = _getSelectionBox(event);
    workflowsStore.allNodes.forEach((node2) => {
      if (node2.position[0] < selectionBox.x || node2.position[0] > selectionBox.x + selectionBox.width) {
        return;
      }
      if (node2.position[1] < selectionBox.y || node2.position[1] > selectionBox.y + selectionBox.height) {
        return;
      }
      returnNodes.push(node2);
    });
    return returnNodes;
  }
  function _createSelectBox() {
    selectBox.value.id = "select-box";
    _setSelectBoxStyle({
      margin: "0px auto",
      border: "2px dotted #FF0000",
      // Positioned absolutely within #node-view. This is consistent with how nodes are positioned.
      position: "absolute",
      zIndex: `${APP_Z_INDEXES.SELECT_BOX}`,
      visibility: "hidden"
    });
    selectBox.value.addEventListener("mouseup", mouseUpMouseSelect);
    const nodeViewEl = document.querySelector("#node-view");
    nodeViewEl.appendChild(selectBox.value);
  }
  function _mouseMoveSelect(e) {
    if (e.buttons === 0) {
      mouseUpMouseSelect(e);
      return;
    }
    _updateSelectBox(e);
  }
  function mouseUpMouseSelect(e) {
    if ("button" in e && e.button === 2 || isContextMenuOpen.value) return;
    if (!selectActive.value) {
      if (isTouchDevice && e.target instanceof HTMLElement) {
        if (e.target && e.target.id.includes("node-view")) {
          deselectAllNodes();
        }
      }
      return;
    }
    document.removeEventListener("mousemove", _mouseMoveSelect);
    deselectAllNodes();
    const selectedNodes = _getNodesInSelection(e);
    selectedNodes.forEach((node2) => {
      nodeSelected(node2);
    });
    if (selectedNodes.length === 1) {
      uiStore.lastSelectedNode = selectedNodes[0].name;
    }
    _hideSelectBox();
  }
  function mouseDownMouseSelect(e, moveButtonPressed) {
    if (isCtrlKeyPressed(e) || moveButtonPressed || e.button === 2) {
      return;
    }
    if (uiStore.isActionActive["dragActive"]) {
      return;
    }
    _showSelectBox(e);
    document.addEventListener("mousemove", _mouseMoveSelect);
  }
  function getMousePositionWithinNodeView(event) {
    const mousePosition = getMousePosition(event);
    const [relativeX, relativeY] = canvasStore.canvasPositionFromPagePosition(mousePosition);
    const nodeViewScale = canvasStore.nodeViewScale;
    const nodeViewOffsetPosition = uiStore.nodeViewOffsetPosition;
    return getRelativePosition(relativeX, relativeY, nodeViewScale, nodeViewOffsetPosition);
  }
  function nodeDeselected(node2) {
    uiStore.removeNodeFromSelection(node2);
    instance.value.removeFromDragSelection(instance.value.getManagedElement(node2?.id));
  }
  function nodeSelected(node2) {
    uiStore.addSelectedNode(node2);
    instance.value.addToDragSelection(instance.value.getManagedElement(node2?.id));
  }
  function deselectAllNodes() {
    instance.value.clearDragSelection();
    uiStore.resetSelectedNodes();
    uiStore.lastSelectedNode = null;
    uiStore.lastSelectedNodeOutputIndex = null;
    canvasStore.newNodeInsertPosition = null;
    canvasStore.setLastSelectedConnection(void 0);
  }
  const instance = computed(() => canvasStore.jsPlumbInstance);
  function initializeCanvasMouseSelect() {
    _createSelectBox();
  }
  return {
    selectActive,
    getMousePositionWithinNodeView,
    mouseUpMouseSelect,
    mouseDownMouseSelect,
    nodeDeselected,
    nodeSelected,
    deselectAllNodes,
    initializeCanvasMouseSelect
  };
}
const _hoisted_1$2 = ["textContent"];
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "CanvasAddButton",
  props: {
    showTooltip: { type: Boolean },
    position: {}
  },
  setup(__props) {
    const i18n = useI18n();
    const props = __props;
    const nodeCreatorStore = useNodeCreatorStore();
    const containerCssVars = computed(() => ({
      "--trigger-placeholder-left-position": `${props.position[0]}px`,
      "--trigger-placeholder-top-position": `${props.position[1]}px`
    }));
    return (_ctx, _cache) => {
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createElementBlock("div", {
        ref: "container",
        class: normalizeClass(_ctx.$style.canvasAddButton),
        style: normalizeStyle(containerCssVars.value),
        "data-test-id": "canvas-add-button"
      }, [
        createVNode(_component_n8n_tooltip, {
          placement: "top",
          visible: _ctx.showTooltip,
          disabled: unref(nodeCreatorStore).showScrim,
          "popper-class": _ctx.$style.tooltip,
          "show-after": 700
        }, {
          content: withCtx(() => [
            createTextVNode(toDisplayString(unref(i18n).baseText("nodeView.canvasAddButton.addATriggerNodeBeforeExecuting")), 1)
          ]),
          default: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(_ctx.$style.button),
              "data-test-id": "canvas-plus-button",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
            }, [
              createVNode(_component_font_awesome_icon, {
                icon: "plus",
                size: "lg"
              })
            ], 2)
          ]),
          _: 1
        }, 8, ["visible", "disabled", "popper-class"]),
        createBaseVNode("p", {
          class: normalizeClass(_ctx.$style.label),
          textContent: toDisplayString(unref(i18n).baseText("nodeView.canvasAddButton.addFirstStep"))
        }, null, 10, _hoisted_1$2)
      ], 6);
    };
  }
});
const canvasAddButton = "_canvasAddButton_b7y18_123";
const button = "_button_b7y18_135";
const label = "_label_b7y18_156";
const style0$2 = {
  canvasAddButton,
  button,
  label
};
const cssModules$3 = {
  "$style": style0$2
};
const CanvasAddButton = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__cssModules", cssModules$3]]);
function useCanvasPanning(elementRef, options = {}) {
  const uiStore = useUIStore();
  const moveLastPosition = ref([0, 0]);
  const deviceSupport = useDeviceSupport();
  function panCanvas(e) {
    const offsetPosition = uiStore.nodeViewOffsetPosition;
    const [x, y] = getMousePosition(e);
    const nodeViewOffsetPositionX = offsetPosition[0] + (x - moveLastPosition.value[0]);
    const nodeViewOffsetPositionY = offsetPosition[1] + (y - moveLastPosition.value[1]);
    uiStore.nodeViewOffsetPosition = [nodeViewOffsetPositionX, nodeViewOffsetPositionY];
    moveLastPosition.value = [x, y];
    return [nodeViewOffsetPositionX, nodeViewOffsetPositionY];
  }
  function onMouseDown(e, moveButtonPressed) {
    if (!(deviceSupport.isCtrlKeyPressed(e) || moveButtonPressed)) {
      return;
    }
    if (uiStore.isActionActive["dragActive"]) {
      return;
    }
    if (e.button !== MOUSE_EVENT_BUTTON.MIDDLE) {
      uiStore.nodeViewMoveInProgress = true;
    }
    const [x, y] = getMousePosition(e);
    moveLastPosition.value = [x, y];
    const element = unref(elementRef);
    element?.addEventListener("mousemove", onMouseMove);
  }
  function onMouseUp() {
    if (!uiStore.nodeViewMoveInProgress) {
      return;
    }
    const element = unref(elementRef);
    element?.removeEventListener("mousemove", onMouseMove);
    uiStore.nodeViewMoveInProgress = false;
  }
  function onMouseMove(e) {
    const element = unref(elementRef);
    if (e.target && !(element === e.target || element?.contains(e.target))) {
      return;
    }
    if (uiStore.isActionActive["dragActive"]) {
      return;
    }
    if (e instanceof MouseEvent && e.buttons === MOUSE_EVENT_BUTTONS.MIDDLE) {
      uiStore.nodeViewMoveInProgress = true;
    }
    if (e instanceof MouseEvent && e.buttons === MOUSE_EVENT_BUTTONS.NONE) {
      const onMouseMoveEnd = unref(options.onMouseMoveEnd);
      onMouseMoveEnd?.(e);
      return;
    }
    panCanvas(e);
  }
  return {
    moveLastPosition,
    onMouseDown,
    onMouseUp,
    onMouseMove,
    panCanvas
  };
}
const _hoisted_1$1 = { "data-action": "reload" };
const _hoisted_2$1 = {
  href: "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/",
  target: "_blank"
};
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "NodeViewUnfinishedWorkflowMessage",
  setup(__props) {
    const i18 = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("a", _hoisted_1$1, toDisplayString(unref(i18).baseText("nodeView.refresh")), 1),
        createTextVNode(" " + toDisplayString(unref(i18).baseText("nodeView.toSeeTheLatestStatus")) + ". ", 1),
        _cache[0] || (_cache[0] = createBaseVNode("br", null, null, -1)),
        createBaseVNode("a", _hoisted_2$1, toDisplayString(unref(i18).baseText("nodeView.moreInfo")), 1)
      ]);
    };
  }
});
const LazyNodeCreation = defineAsyncComponent(
  async () => await __vitePreload(() => import("./NodeCreation-KBmCqr6_.js").then((n) => n.N), true ? __vite__mapDeps([20,1,2,6,7,8,21]) : void 0)
);
const LazyCanvasControls = defineAsyncComponent(
  async () => await __vitePreload(() => import("./CanvasControls-Crujpx17.js"), true ? __vite__mapDeps([22,1,2,23]) : void 0)
);
const LazySetupWorkflowCredentialsButton = defineAsyncComponent(
  async () => await __vitePreload(() => import("./SetupWorkflowCredentialsButton-Cro6GHxL.js"), true ? __vite__mapDeps([24,1,2]) : void 0)
);
const _sfc_main$8 = defineComponent({
  name: "NodeView",
  components: {
    NodeDetailsView: __unplugin_components_2,
    Node: __unplugin_components_0,
    Sticky: __unplugin_components_1,
    CanvasAddButton,
    KeyboardShortcutTooltip,
    LazyNodeCreation,
    LazyCanvasControls,
    ContextMenu,
    LazySetupWorkflowCredentialsButton
  },
  setup() {
    const nodeViewRootRef = ref(null);
    const nodeViewRef = ref(null);
    const onMouseMoveEnd = ref(null);
    const router = useRouter();
    const route = useRoute();
    const posthogStore = usePostHog();
    const ndvStore = useNDVStore();
    const externalHooks = useExternalHooks();
    const i18n = useI18n();
    const contextMenu = useContextMenu();
    const dataSchema = useDataSchema();
    const nodeHelpers = useNodeHelpers();
    const clipboard = useClipboard();
    const { activeNode } = storeToRefs(ndvStore);
    const pinnedData = usePinnedData(activeNode);
    const deviceSupport = useDeviceSupport();
    const { callDebounced } = useDebounce();
    const canvasPanning = useCanvasPanning(nodeViewRootRef, { onMouseMoveEnd });
    const workflowHelpers = useWorkflowHelpers({ router });
    const { runWorkflow, stopCurrentExecution } = useRunWorkflow({
      router
    });
    const { addBeforeUnloadEventBindings, removeBeforeUnloadEventBindings } = useBeforeUnload({
      route
    });
    return {
      i18n,
      contextMenu,
      dataSchema,
      nodeHelpers,
      externalHooks,
      clipboard,
      pinnedData,
      deviceSupport,
      canvasPanning,
      nodeViewRootRef,
      nodeViewRef,
      onMouseMoveEnd,
      workflowHelpers,
      posthogStore,
      runWorkflow,
      stopCurrentExecution,
      callDebounced,
      ...useCanvasMouseSelect(),
      ...useGlobalLinkActions(),
      documentTitle: useDocumentTitle(),
      ...useToast(),
      ...useMessage(),
      ...useUniqueNodeName(),
      ...useExecutionDebugging(),
      addBeforeUnloadEventBindings,
      removeBeforeUnloadEventBindings
    };
  },
  data() {
    return {
      GRID_SIZE,
      STICKY_NODE_TYPE,
      createNodeActive: false,
      lastClickPosition: [450, 450],
      ctrlKeyPressed: false,
      moveCanvasKeyPressed: false,
      stopExecutionInProgress: false,
      blankRedirect: false,
      pullConnActive: false,
      dropPrevented: false,
      connectionDragScope: {
        type: null,
        connection: null
      },
      renamingActive: false,
      showStickyButton: false,
      isExecutionPreview: false,
      showTriggerMissingTooltip: false,
      workflowData: null,
      activeConnection: null,
      enterTimer: void 0,
      exitTimer: void 0,
      readOnlyNotification: null,
      // jsplumb automatically deletes all loose connections which is in turn recorded
      // in undo history as a user action.
      // This should prevent automatically removed connections from populating undo stack
      suspendRecordingDetachedConnections: false,
      NODE_CREATOR_OPEN_SOURCES,
      eventsAttached: false,
      canOpenNDV: true,
      hideNodeIssues: false
    };
  },
  computed: {
    ...mapStores(
      useCanvasStore,
      useTagsStore,
      useCredentialsStore,
      useNodeCreatorStore,
      useNodeTypesStore,
      useNDVStore,
      useRootStore,
      useSettingsStore,
      useTemplatesStore,
      useUIStore,
      useWorkflowsStore,
      useUsersStore,
      useNodeCreatorStore,
      useEnvironmentsStore,
      useWorkflowsEEStore,
      useHistoryStore,
      useExternalSecretsStore,
      usePushConnectionStore,
      useSourceControlStore,
      useExecutionsStore,
      useProjectsStore,
      useNpsSurveyStore
    ),
    nativelyNumberSuffixedDefaults() {
      return this.nodeTypesStore.nativelyNumberSuffixedDefaults;
    },
    currentUser() {
      return this.usersStore.currentUser;
    },
    activeNode() {
      return this.ndvStore.activeNode;
    },
    executionWaitingForWebhook() {
      return this.workflowsStore.executionWaitingForWebhook;
    },
    isDemo() {
      return this.$route.name === VIEWS.DEMO;
    },
    showCanvasAddButton() {
      return !this.isLoading && !this.containsTrigger && !this.isDemo && !this.readOnlyEnv && !!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
    },
    lastSelectedNode() {
      return this.uiStore.getLastSelectedNode;
    },
    nodes() {
      return this.workflowsStore.allNodes;
    },
    nodesToRender() {
      return this.workflowsStore.allNodes.filter((node2) => node2.type !== STICKY_NODE_TYPE);
    },
    stickiesToRender() {
      return this.workflowsStore.allNodes.filter((node2) => node2.type === STICKY_NODE_TYPE);
    },
    runButtonText() {
      if (!this.workflowRunning) {
        return this.i18n.baseText("nodeView.runButtonText.executeWorkflow");
      }
      if (this.executionWaitingForWebhook) {
        return this.i18n.baseText("nodeView.runButtonText.waitingForTriggerEvent");
      }
      return this.i18n.baseText("nodeView.runButtonText.executingWorkflow");
    },
    workflowStyle() {
      const offsetPosition = this.uiStore.nodeViewOffsetPosition;
      return {
        left: offsetPosition[0] + "px",
        top: offsetPosition[1] + "px"
      };
    },
    canvasAddButtonStyle() {
      return {
        "pointer-events": this.createNodeActive ? "none" : "all"
      };
    },
    backgroundStyle() {
      return getBackgroundStyles(
        this.nodeViewScale,
        this.uiStore.nodeViewOffsetPosition,
        this.isExecutionPreview || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
      );
    },
    workflowClasses() {
      const returnClasses = [];
      if (this.ctrlKeyPressed || this.moveCanvasKeyPressed) {
        if (this.uiStore.nodeViewMoveInProgress) {
          returnClasses.push("move-in-process");
        } else {
          returnClasses.push("move-active");
        }
      }
      if (this.selectActive || this.ctrlKeyPressed || this.moveCanvasKeyPressed) {
        returnClasses.push("do-not-select");
      }
      if (this.connectionDragScope.type) {
        returnClasses.push("connection-drag-scope-active");
        returnClasses.push(`connection-drag-scope-active-type-${this.connectionDragScope.type}`);
        returnClasses.push(
          `connection-drag-scope-active-connection-${this.connectionDragScope.connection}`
        );
      }
      return returnClasses;
    },
    workflowExecution() {
      return this.workflowsStore.getWorkflowExecution;
    },
    workflowRunning() {
      return this.workflowsStore.isWorkflowRunning;
    },
    currentWorkflow() {
      return this.$route.params.name?.toString() || this.workflowsStore.workflowId;
    },
    workflowName() {
      return this.workflowsStore.workflowName;
    },
    allTriggersDisabled() {
      const disabledTriggerNodes = this.triggerNodes.filter((node2) => node2.disabled);
      return disabledTriggerNodes.length === this.triggerNodes.length;
    },
    triggerNodes() {
      return this.nodes.filter(
        (node2) => node2.type === START_NODE_TYPE || this.nodeTypesStore.isTriggerNode(node2.type)
      );
    },
    containsTrigger() {
      return this.triggerNodes.length > 0;
    },
    containsChatNodes() {
      return !this.executionWaitingForWebhook && !!this.nodes.find(
        (node2) => [MANUAL_CHAT_TRIGGER_NODE_TYPE, CHAT_TRIGGER_NODE_TYPE].includes(node2.type) && node2.disabled !== true
      );
    },
    canvasChatNode() {
      return this.nodes.find((node2) => node2.type === CHAT_TRIGGER_NODE_TYPE);
    },
    isManualChatOnly() {
      if (!this.canvasChatNode) return false;
      return this.containsChatNodes && this.triggerNodes.length === 1 && !this.pinnedChatNodeData;
    },
    pinnedChatNodeData() {
      if (!this.canvasChatNode) return null;
      return this.workflowsStore.pinDataByNodeName(this.canvasChatNode.name);
    },
    isExecutionDisabled() {
      if (this.containsChatNodes && this.triggerNodes.every((node2) => node2.disabled || node2.type === CHAT_TRIGGER_NODE_TYPE) && !this.pinnedChatNodeData) {
        return true;
      }
      return !this.containsTrigger || this.allTriggersDisabled;
    },
    getNodeViewOffsetPosition() {
      return this.uiStore.nodeViewOffsetPosition;
    },
    nodeViewScale() {
      return this.canvasStore.nodeViewScale;
    },
    instance() {
      return this.canvasStore.jsPlumbInstance;
    },
    isLoading() {
      return this.canvasStore.isLoading;
    },
    currentWorkflowObject() {
      return this.workflowsStore.getCurrentWorkflow();
    },
    readOnlyEnv() {
      return this.sourceControlStore.preferences.branchReadOnly;
    },
    isReadOnlyRoute() {
      return this.$route?.meta?.readOnlyCanvas === true;
    },
    isProductionExecutionPreview() {
      return this.nodeHelpers.isProductionExecutionPreview.value;
    },
    workflowPermissions() {
      return getResourcePermissions(
        this.workflowsStore.getWorkflowById(this.currentWorkflow)?.scopes
      ).workflow;
    },
    projectPermissions() {
      const project = this.$route.query?.projectId ? this.projectsStore.myProjects.find((p) => p.id === this.$route.query.projectId) : this.projectsStore.currentProject ?? this.projectsStore.personalProject;
      return getResourcePermissions(project?.scopes);
    },
    isChatOpen() {
      return this.workflowsStore.isChatPanelOpen;
    }
  },
  watch: {
    // Listen to route changes and load the workflow accordingly
    async $route(to, from) {
      await this.readOnlyEnvRouteCheck();
      const currentTab = getNodeViewTab(to);
      const nodeViewNotInitialized = !this.uiStore.nodeViewInitialized;
      let workflowChanged = from.params.name !== to.params.name && // Both 'new' and __EMPTY__ are new workflow names, so ignore them when detecting if wf changed
      !(from.params.name === "new" && this.currentWorkflow === PLACEHOLDER_EMPTY_WORKFLOW_ID) && !(from.name === VIEWS.NEW_WORKFLOW) && // Also ignore if workflow id changes when saving new workflow
      to.params.action !== "workflowSave";
      const isOpeningTemplate = to.name === VIEWS.TEMPLATE_IMPORT;
      if (currentTab === MAIN_HEADER_TABS.WORKFLOW || isOpeningTemplate) {
        if (workflowChanged || nodeViewNotInitialized || isOpeningTemplate) {
          this.canvasStore.startLoading();
          if (nodeViewNotInitialized) {
            const previousDirtyState = this.uiStore.stateIsDirty;
            this.resetWorkspace();
            this.uiStore.stateIsDirty = previousDirtyState;
          }
          await this.initView();
          this.canvasStore.stopLoading();
          if (this.blankRedirect) {
            this.blankRedirect = false;
          }
        }
        await this.checkAndInitDebugMode();
      }
      if (currentTab === MAIN_HEADER_TABS.EXECUTIONS) {
        workflowChanged = from.params.name !== to.params.name && !(to.params.name === "new" && from.params.name === void 0);
        if (workflowChanged) {
          this.uiStore.nodeViewInitialized = false;
        }
      }
    },
    activeNode() {
      this.createNodeActive = false;
    },
    containsTrigger(containsTrigger) {
      if (containsTrigger === false)
        this.canvasStore.setRecenteredCanvasAddButtonPosition(this.getNodeViewOffsetPosition);
    },
    nodeViewScale(newScale) {
      const elementRef = this.nodeViewRef;
      if (elementRef) {
        elementRef.style.transform = `scale(${newScale})`;
      }
    }
  },
  errorCaptured: (err) => {
    console.error("errorCaptured");
    console.error(err);
  },
  async mounted() {
    this.onMouseMoveEnd = this.mouseUp;
    this.initializeCanvasMouseSelect();
    this.resetWorkspace();
    if (!this.nodeViewRef) {
      this.showError(
        new Error("NodeView reference not found"),
        this.i18n.baseText("nodeView.showError.mounted1.title"),
        this.i18n.baseText("nodeView.showError.mounted1.message") + ":"
      );
      return;
    }
    this.canvasStore.initInstance(this.nodeViewRef);
    this.documentTitle.reset();
    window.addEventListener("message", this.onPostMessageReceived);
    this.clipboard.onPaste.value = this.onClipboardPasteEvent;
    this.canvasStore.startLoading();
    const loadPromises = (() => {
      if (this.settingsStore.isPreviewMode && this.isDemo) return [];
      const promises = [this.loadActiveWorkflows(), this.loadCredentialTypes()];
      if (this.settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Variables]) {
        promises.push(this.loadVariables());
      }
      if (this.settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.ExternalSecrets]) {
        promises.push(this.loadSecrets());
      }
      return promises;
    })();
    if (this.nodeTypesStore.allNodeTypes.length === 0) {
      loadPromises.push(this.loadNodeTypes());
    }
    try {
      await Promise.all(loadPromises);
    } catch (error) {
      this.showError(
        error,
        this.i18n.baseText("nodeView.showError.mounted1.title"),
        this.i18n.baseText("nodeView.showError.mounted1.message") + ":"
      );
      return;
    }
    ready(async () => {
      try {
        try {
          this.bindCanvasEvents();
        } catch {
        }
        await this.initView();
        if (window.parent) {
          window.parent.postMessage(
            JSON.stringify({ command: "n8nReady", version: this.rootStore.versionCli }),
            "*"
          );
        }
      } catch (error) {
        this.showError(
          error,
          this.i18n.baseText("nodeView.showError.mounted2.title"),
          this.i18n.baseText("nodeView.showError.mounted2.message") + ":"
        );
      }
      this.canvasStore.stopLoading();
      setTimeout(() => {
        void this.usersStore.showPersonalizationSurvey();
        this.nodeHelpers.addPinDataConnections(this.workflowsStore.pinnedWorkflowData);
      }, 0);
    });
    void this.externalHooks.run("nodeView.mount").catch(() => {
    });
    sourceControlEventBus.on("pull", this.onSourceControlPull);
    this.registerCustomAction({
      key: "openNodeDetail",
      action: ({ node: node2 }) => {
        this.nodeSelectedByName(node2, true);
      }
    });
    this.registerCustomAction({
      key: "openSelectiveNodeCreator",
      action: this.openSelectiveNodeCreator
    });
    this.registerCustomAction({
      key: "showNodeCreator",
      action: () => {
        this.ndvStore.activeNodeName = null;
        void this.$nextTick(() => {
          this.showTriggerCreator(NODE_CREATOR_OPEN_SOURCES.TAB);
        });
      }
    });
    await this.readOnlyEnvRouteCheck();
    this.canvasStore.isDemo = this.isDemo;
  },
  activated() {
    const openSideMenu = this.uiStore.addFirstStepOnLoad;
    if (openSideMenu) {
      this.showTriggerCreator(NODE_CREATOR_OPEN_SOURCES.TRIGGER_PLACEHOLDER_BUTTON);
    }
    this.uiStore.addFirstStepOnLoad = false;
    this.bindCanvasEvents();
    document.addEventListener("keydown", this.keyDown);
    document.addEventListener("keyup", this.keyUp);
    window.addEventListener("message", this.onPostMessageReceived);
    window.addEventListener("pageshow", this.onPageShow);
    nodeViewEventBus.on("newWorkflow", this.newWorkflow);
    nodeViewEventBus.on("importWorkflowData", this.onImportWorkflowDataEvent);
    nodeViewEventBus.on("importWorkflowUrl", this.onImportWorkflowUrlEvent);
    nodeViewEventBus.on("openChat", this.onOpenChat);
    historyBus.on("nodeMove", this.onMoveNode);
    historyBus.on("revertAddNode", this.onRevertAddNode);
    historyBus.on("revertRemoveNode", this.onRevertRemoveNode);
    historyBus.on("revertAddConnection", this.onRevertAddConnection);
    historyBus.on("revertRemoveConnection", this.onRevertRemoveConnection);
    historyBus.on("revertRenameNode", this.onRevertNameChange);
    historyBus.on("enableNodeToggle", this.onRevertEnableToggle);
    dataPinningEventBus.on("pin-data", this.nodeHelpers.addPinDataConnections);
    dataPinningEventBus.on("unpin-data", this.nodeHelpers.removePinDataConnections);
    nodeViewEventBus.on("saveWorkflow", this.saveCurrentWorkflowExternal);
    this.canvasStore.isDemo = this.isDemo;
    this.addBeforeUnloadEventBindings();
  },
  deactivated() {
    this.unbindCanvasEvents();
    document.removeEventListener("keydown", this.keyDown);
    document.removeEventListener("keyup", this.keyUp);
    window.removeEventListener("message", this.onPostMessageReceived);
    window.removeEventListener("pageshow", this.onPageShow);
    nodeViewEventBus.off("newWorkflow", this.newWorkflow);
    nodeViewEventBus.off("importWorkflowData", this.onImportWorkflowDataEvent);
    nodeViewEventBus.off("importWorkflowUrl", this.onImportWorkflowUrlEvent);
    nodeViewEventBus.off("openChat", this.onOpenChat);
    historyBus.off("nodeMove", this.onMoveNode);
    historyBus.off("revertAddNode", this.onRevertAddNode);
    historyBus.off("revertRemoveNode", this.onRevertRemoveNode);
    historyBus.off("revertAddConnection", this.onRevertAddConnection);
    historyBus.off("revertRemoveConnection", this.onRevertRemoveConnection);
    historyBus.off("revertRenameNode", this.onRevertNameChange);
    historyBus.off("enableNodeToggle", this.onRevertEnableToggle);
    dataPinningEventBus.off("pin-data", this.nodeHelpers.addPinDataConnections);
    dataPinningEventBus.off("unpin-data", this.nodeHelpers.removePinDataConnections);
    nodeViewEventBus.off("saveWorkflow", this.saveCurrentWorkflowExternal);
    this.removeBeforeUnloadEventBindings();
  },
  beforeMount() {
    if (!this.isDemo) {
      this.pushStore.pushConnect();
    }
  },
  beforeUnmount() {
    document.removeEventListener("keydown", this.keyDown);
    document.removeEventListener("keyup", this.keyUp);
    this.unregisterCustomAction("showNodeCreator");
    this.unregisterCustomAction("openNodeDetail");
    this.unregisterCustomAction("openSelectiveNodeCreator");
    if (!this.isDemo) {
      this.pushStore.pushDisconnect();
    }
    this.resetWorkspace();
    this.instance.unbind();
    this.instance.destroy();
    this.uiStore.stateIsDirty = false;
    this.workflowsStore.resetChatMessages();
    window.removeEventListener("message", this.onPostMessageReceived);
    nodeViewEventBus.off("newWorkflow", this.newWorkflow);
    nodeViewEventBus.off("importWorkflowData", this.onImportWorkflowDataEvent);
    nodeViewEventBus.off("importWorkflowUrl", this.onImportWorkflowUrlEvent);
    this.workflowsStore.setWorkflowId(PLACEHOLDER_EMPTY_WORKFLOW_ID);
    sourceControlEventBus.off("pull", this.onSourceControlPull);
  },
  methods: {
    async openSelectiveNodeCreator({
      connectiontype,
      node: node2,
      creatorview
    }) {
      const nodeName = node2 ?? this.ndvStore.activeNodeName;
      const nodeData = nodeName ? this.workflowsStore.getNodeByName(nodeName) : null;
      this.ndvStore.activeNodeName = null;
      await this.redrawNode(node2);
      setTimeout(() => {
        if (creatorview) {
          this.onToggleNodeCreator({
            createNodeActive: true,
            nodeCreatorView: creatorview
          });
        } else if (connectiontype && nodeData) {
          this.insertNodeAfterSelected({
            index: 0,
            endpointUuid: `${nodeData.id}-input${connectiontype}0`,
            eventSource: NODE_CREATOR_OPEN_SOURCES.NOTICE_ERROR_MESSAGE,
            outputType: connectiontype,
            sourceId: nodeData.id
          });
        }
      });
    },
    editAllowedCheck() {
      if (this.readOnlyNotification) {
        return false;
      }
      if (this.isReadOnlyRoute || this.readOnlyEnv) {
        this.readOnlyNotification = this.showMessage({
          title: this.i18n.baseText(
            this.readOnlyEnv ? `readOnlyEnv.showMessage.${this.isReadOnlyRoute ? "executions" : "workflows"}.title` : "readOnly.showMessage.executions.title"
          ),
          message: this.i18n.baseText(
            this.readOnlyEnv ? `readOnlyEnv.showMessage.${this.isReadOnlyRoute ? "executions" : "workflows"}.message` : "readOnly.showMessage.executions.message"
          ),
          type: "info",
          onClose: () => {
            this.readOnlyNotification = null;
          }
        });
        return false;
      }
      return !!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
    },
    showTriggerMissingToltip(isVisible) {
      this.showTriggerMissingTooltip = isVisible;
    },
    onRunNode(nodeName, source) {
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      const telemetryPayload = {
        node_type: node2 ? node2.type : null,
        workflow_id: this.workflowsStore.workflowId,
        source: "canvas",
        push_ref: this.ndvStore.pushRef
      };
      this.$telemetry.track("User clicked execute node button", telemetryPayload);
      void this.externalHooks.run("nodeView.onRunNode", telemetryPayload);
      void this.runWorkflow({ destinationNode: nodeName, source });
    },
    async onOpenChat() {
      const telemetryPayload = {
        workflow_id: this.workflowsStore.workflowId
      };
      this.$telemetry.track("User clicked chat open button", telemetryPayload);
      void this.externalHooks.run("nodeView.onOpenChat", telemetryPayload);
      this.workflowsStore.setPanelOpen("chat", !this.workflowsStore.isChatPanelOpen);
    },
    async onRunWorkflow() {
      void this.workflowHelpers.getWorkflowDataToSave().then((workflowData) => {
        const telemetryPayload = {
          workflow_id: this.workflowsStore.workflowId,
          node_graph_string: JSON.stringify(
            generateNodesGraph(
              workflowData,
              this.workflowHelpers.getNodeTypes(),
              { isCloudDeployment: this.settingsStore.isCloudDeployment }
            ).nodeGraph
          )
        };
        this.$telemetry.track("User clicked execute workflow button", telemetryPayload);
        void this.externalHooks.run("nodeView.onRunWorkflow", telemetryPayload);
      });
      void this.runWorkflow({});
      this.refreshEndpointsErrorsState();
    },
    resetEndpointsErrors() {
      const allEndpoints = Object.values(this.instance.getManagedElements()).flatMap(
        (el) => el.endpoints
      );
      allEndpoints.filter((endpoint) => endpoint?.endpoint.type === N8nAddInputEndpointType).forEach((endpoint) => {
        const n8nAddInputEndpoint = endpoint?.endpoint;
        if (n8nAddInputEndpoint && (endpoint?.connections ?? []).length > 0) {
          n8nAddInputEndpoint.resetError();
        }
      });
    },
    refreshEndpointsErrorsState() {
      const nodeIssues = this.workflowsStore.allNodes.filter((n) => n.issues);
      this.resetEndpointsErrors();
      nodeIssues.forEach((node2) => {
        const managedNode = this.instance.getManagedElement(node2.id);
        const endpoints = this.instance.getEndpoints(managedNode);
        Object.keys(node2?.issues?.input ?? {}).forEach((connectionType2) => {
          const inputEndpointsWithIssues = endpoints.filter(
            (e) => e._defaultType.scope === connectionType2
          );
          inputEndpointsWithIssues.forEach((endpoint) => {
            const n8nAddInputEndpoint = endpoint?.endpoint;
            if (n8nAddInputEndpoint) {
              n8nAddInputEndpoint.setError();
            }
          });
        });
      });
    },
    onRunContainerClick() {
      if (this.containsTrigger && !this.allTriggersDisabled) return;
      const message = this.containsTrigger && this.allTriggersDisabled ? this.i18n.baseText("nodeView.addOrEnableTriggerNode") : this.i18n.baseText("nodeView.addATriggerNodeFirst");
      const notice = this.showMessage({
        type: "info",
        title: this.i18n.baseText("nodeView.cantExecuteNoTrigger"),
        message,
        duration: 3e3,
        onClick: () => setTimeout(() => {
          if (this.createNodeActive) notice.close();
        }, 0)
      });
    },
    async clearExecutionData() {
      this.workflowsStore.workflowExecutionData = null;
      this.nodeHelpers.updateNodesExecutionIssues();
    },
    async onSaveKeyboardShortcut(e) {
      let saved = await this.workflowHelpers.saveCurrentWorkflow();
      if (saved) {
        await this.npsSurveyStore.fetchPromptsData();
        if (this.$route.name === VIEWS.EXECUTION_DEBUG) {
          await this.$router.replace({
            name: VIEWS.WORKFLOW,
            params: { name: this.currentWorkflow }
          });
        }
      }
      if (this.activeNode) {
        if (e.target instanceof HTMLInputElement) {
          saved = e.target.readOnly;
        } else {
          saved = true;
        }
        if (saved) {
          this.showMessage({
            title: this.i18n.baseText("generic.workflowSaved"),
            type: "success"
          });
        }
      }
    },
    async onCanvasAddButtonCLick() {
      this.showTriggerCreator(NODE_CREATOR_OPEN_SOURCES.TRIGGER_PLACEHOLDER_BUTTON);
    },
    showTriggerCreator(source) {
      if (this.createNodeActive) return;
      this.ndvStore.activeNodeName = null;
      this.nodeCreatorStore.setSelectedView(TRIGGER_NODE_CREATOR_VIEW);
      this.nodeCreatorStore.setShowScrim(true);
      this.onToggleNodeCreator({
        source,
        createNodeActive: true,
        nodeCreatorView: TRIGGER_NODE_CREATOR_VIEW
      });
    },
    async openExecution(executionId) {
      this.canvasStore.startLoading();
      this.resetWorkspace();
      let data;
      try {
        data = await this.workflowsStore.getExecution(executionId);
      } catch (error) {
        this.showError(error, this.i18n.baseText("nodeView.showError.openExecution.title"));
        return;
      }
      if (data === void 0) {
        throw new Error(`Execution with id "${executionId}" could not be found!`);
      }
      this.workflowsStore.setWorkflowName({
        newName: data.workflowData.name,
        setStateDirty: false
      });
      this.workflowsStore.setWorkflowId(PLACEHOLDER_EMPTY_WORKFLOW_ID);
      this.workflowsStore.setWorkflowExecutionData(data);
      if (data.workflowData.pinData && data.mode === "manual") {
        this.workflowsStore.setWorkflowPinData(data.workflowData.pinData);
      }
      if (data.workflowData.sharedWithProjects) {
        this.workflowsEEStore.setWorkflowSharedWith({
          workflowId: data.workflowData.id,
          sharedWithProjects: data.workflowData.sharedWithProjects
        });
      }
      if (data.workflowData.usedCredentials) {
        this.workflowsStore.setUsedCredentials(data.workflowData.usedCredentials);
      }
      await this.nodeHelpers.addNodes(
        deepCopy(data.workflowData.nodes),
        deepCopy(data.workflowData.connections)
      );
      await this.$nextTick();
      this.canvasStore.zoomToFit();
      this.uiStore.stateIsDirty = false;
      void this.externalHooks.run("execution.open", {
        workflowId: data.workflowData.id,
        workflowName: data.workflowData.name,
        executionId
      });
      this.$telemetry.track("User opened read-only execution", {
        workflow_id: data.workflowData.id,
        execution_mode: data.mode,
        execution_finished: data.finished
      });
      if (!data.finished && data.data?.resultData?.error) {
        let nodeErrorFound = false;
        if (data.data.resultData.runData) {
          const runData = data.data.resultData.runData;
          errorCheck: for (const nodeName of Object.keys(runData)) {
            for (const taskData of runData[nodeName]) {
              if (taskData.error) {
                nodeErrorFound = true;
                break errorCheck;
              }
            }
          }
        }
        if (!nodeErrorFound && (data.data.resultData.error.stack || data.data.resultData.error.message)) {
          console.error(`Execution ${executionId} error:`);
          console.error(data.data.resultData.error.stack);
          this.showMessage({
            title: this.i18n.baseText("nodeView.showError.workflowError"),
            message: data.data.resultData.error.message,
            type: "error",
            duration: 0
          });
        }
      }
      if (data.waitTill) {
        this.showMessage({
          title: this.i18n.baseText("nodeView.thisExecutionHasntFinishedYet"),
          message: h(_sfc_main$9),
          type: "warning",
          duration: 0
        });
      }
      this.canvasStore.stopLoading();
    },
    async importWorkflowExact(data) {
      if (!data.workflow.nodes || !data.workflow.connections) {
        throw new Error("Invalid workflow object");
      }
      this.resetWorkspace();
      data.workflow.nodes = getFixedNodesList(data.workflow.nodes);
      await this.nodeHelpers.addNodes(data.workflow.nodes, data.workflow.connections);
      if (data.workflow.pinData) {
        this.workflowsStore.setWorkflowPinData(data.workflow.pinData);
      }
      await this.$nextTick();
      this.canvasStore.zoomToFit();
    },
    async openWorkflowTemplateFromJson(data) {
      if (!data.workflow.nodes || !data.workflow.connections) {
        this.showError(
          new Error(this.i18n.baseText("nodeView.couldntLoadWorkflow.invalidWorkflowObject")),
          this.i18n.baseText("nodeView.couldntImportWorkflow")
        );
        await this.$router.replace({ name: VIEWS.NEW_WORKFLOW });
        return;
      }
      this.canvasStore.startLoading();
      this.canvasStore.setLoadingText(this.i18n.baseText("nodeView.loadingTemplate"));
      this.resetWorkspace();
      this.workflowsStore.currentWorkflowExecutions = [];
      this.executionsStore.activeExecution = null;
      this.blankRedirect = true;
      await this.$router.replace({
        name: VIEWS.NEW_WORKFLOW,
        query: { templateId: data.workflow.meta.templateId }
      });
      const convertedNodes = data.workflow.nodes.map(
        this.workflowsStore.convertTemplateNodeToNodeUi
      );
      await this.nodeHelpers.addNodes(convertedNodes, data.workflow.connections);
      this.workflowData = await this.workflowsStore.getNewWorkflowData(
        data.workflow.name,
        this.projectsStore.currentProjectId
      ) || {};
      await this.$nextTick();
      this.canvasStore.zoomToFit();
      this.uiStore.stateIsDirty = true;
      this.canvasStore.stopLoading();
    },
    async openWorkflowTemplate(templateId) {
      this.canvasStore.startLoading();
      this.canvasStore.setLoadingText(this.i18n.baseText("nodeView.loadingTemplate"));
      this.resetWorkspace();
      this.workflowsStore.currentWorkflowExecutions = [];
      this.executionsStore.activeExecution = null;
      let data;
      try {
        void this.externalHooks.run("template.requested", { templateId });
        data = await this.templatesStore.getFixedWorkflowTemplate(templateId);
        if (!data) {
          throw new Error(
            this.i18n.baseText("nodeView.workflowTemplateWithIdCouldNotBeFound", {
              interpolate: { templateId }
            })
          );
        }
      } catch (error) {
        this.showError(error, this.i18n.baseText("nodeView.couldntImportWorkflow"));
        await this.$router.replace({ name: VIEWS.NEW_WORKFLOW });
        return;
      }
      this.$telemetry.track(
        "User inserted workflow template",
        {
          source: "workflow",
          template_id: tryToParseNumber(templateId),
          wf_template_repo_session_id: this.templatesStore.previousSessionId
        },
        {
          withPostHog: true
        }
      );
      this.blankRedirect = true;
      await this.$router.replace({ name: VIEWS.NEW_WORKFLOW, query: { templateId } });
      const convertedNodes = data.workflow.nodes.map(
        this.workflowsStore.convertTemplateNodeToNodeUi
      );
      await this.nodeHelpers.addNodes(convertedNodes, data.workflow.connections);
      this.workflowData = await this.workflowsStore.getNewWorkflowData(
        data.name,
        this.projectsStore.currentProjectId
      ) || {};
      this.workflowsStore.addToWorkflowMetadata({ templateId });
      await this.$nextTick();
      this.canvasStore.zoomToFit();
      this.uiStore.stateIsDirty = true;
      void this.externalHooks.run("template.open", {
        templateId,
        templateName: data.name,
        workflow: data.workflow
      });
      this.canvasStore.stopLoading();
    },
    async openWorkflow(workflow) {
      this.canvasStore.startLoading();
      const selectedExecution = this.executionsStore.activeExecution;
      this.resetWorkspace();
      this.workflowHelpers.initState(workflow);
      if (workflow.sharedWithProjects) {
        this.workflowsEEStore.setWorkflowSharedWith({
          workflowId: workflow.id,
          sharedWithProjects: workflow.sharedWithProjects
        });
      }
      if (workflow.usedCredentials) {
        this.workflowsStore.setUsedCredentials(workflow.usedCredentials);
      }
      await this.nodeHelpers.addNodes(workflow.nodes, workflow.connections);
      if (!this.nodeHelpers.credentialsUpdated.value) {
        this.uiStore.stateIsDirty = false;
      }
      this.canvasStore.zoomToFit();
      void this.externalHooks.run("workflow.open", {
        workflowId: workflow.id,
        workflowName: workflow.name
      });
      if (selectedExecution?.workflowId !== workflow.id) {
        this.executionsStore.activeExecution = null;
        this.workflowsStore.currentWorkflowExecutions = [];
      } else {
        this.executionsStore.activeExecution = selectedExecution;
      }
      this.canvasStore.stopLoading();
    },
    touchTap(e) {
      if (this.deviceSupport.isTouchDevice) {
        this.mouseDown(e);
      }
    },
    mouseDown(e) {
      this.lastClickPosition = this.getMousePositionWithinNodeView(e);
      if (e instanceof MouseEvent && e.button === 1) {
        this.moveCanvasKeyPressed = true;
      }
      this.mouseDownMouseSelect(e, this.moveCanvasKeyPressed);
      this.canvasPanning.onMouseDown(e, this.moveCanvasKeyPressed);
      this.createNodeActive = false;
    },
    mouseUp(e) {
      if (e instanceof MouseEvent && e.button === 1) {
        this.moveCanvasKeyPressed = false;
      }
      this.mouseUpMouseSelect(e);
      this.canvasPanning.onMouseUp();
    },
    keyUp(e) {
      if (e.key === this.deviceSupport.controlKeyCode) {
        this.ctrlKeyPressed = false;
      }
      if (e.key === " ") {
        this.moveCanvasKeyPressed = false;
      }
    },
    async keyDown(e) {
      this.contextMenu.close();
      const ctrlModifier = this.deviceSupport.isCtrlKeyPressed(e) && !e.shiftKey && !e.altKey;
      const shiftModifier = e.shiftKey && !e.altKey && !this.deviceSupport.isCtrlKeyPressed(e);
      const ctrlAltModifier = this.deviceSupport.isCtrlKeyPressed(e) && e.altKey && !e.shiftKey;
      const noModifierKeys = !this.deviceSupport.isCtrlKeyPressed(e) && !e.shiftKey && !e.altKey;
      const readOnly = this.isReadOnlyRoute || this.readOnlyEnv || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
      if (e.key === "s" && ctrlModifier && !readOnly) {
        e.stopPropagation();
        e.preventDefault();
        const workflowIsSaved = !this.uiStore.stateIsDirty;
        if (workflowIsSaved) {
          return;
        }
        void this.callDebounced(this.onSaveKeyboardShortcut, { debounceTime: 1e3 }, e);
        return;
      }
      const path = e?.composedPath() ?? [];
      for (const element of path) {
        if (element instanceof HTMLElement && element.className && typeof element.className === "string" && element.className.includes("ignore-key-press-canvas")) {
          return;
        }
      }
      if (window.document.body.classList.contains("el-popup-parent--hidden")) {
        return;
      }
      if (e.key === "Escape" && noModifierKeys) {
        this.createNodeActive = false;
        if (this.activeNode) {
          void this.externalHooks.run("dataDisplay.nodeEditingFinished");
          this.ndvStore.activeNodeName = null;
        }
        return;
      }
      if (this.activeNode) {
        return;
      }
      const selectedNodes = this.uiStore.getSelectedNodes.map((node2) => node2 && this.workflowsStore.getNodeByName(node2.name)).filter((node2) => !!node2);
      if (e.key === "d" && noModifierKeys && !readOnly) {
        void this.callDebounced(this.toggleActivationNodes, { debounceTime: 350 }, selectedNodes);
      } else if (e.key === "d" && ctrlModifier && !readOnly) {
        if (selectedNodes.length > 0) {
          e.preventDefault();
          void this.duplicateNodes(selectedNodes);
        }
      } else if (e.key === "p" && noModifierKeys && !readOnly) {
        if (selectedNodes.length > 0) {
          e.preventDefault();
          this.togglePinNodes(selectedNodes, "keyboard-shortcut");
        }
      } else if ((e.key === "Delete" || e.key === "Backspace") && noModifierKeys && !readOnly) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.deleteNodes, { debounceTime: 500 }, selectedNodes);
      } else if (e.key === "Tab" && noModifierKeys && !readOnly) {
        this.onToggleNodeCreator({
          source: NODE_CREATOR_OPEN_SOURCES.TAB,
          createNodeActive: !this.createNodeActive && !this.isReadOnlyRoute && !this.readOnlyEnv
        });
      } else if (e.key === "Enter" && ctrlModifier && !readOnly && !this.isExecutionDisabled) {
        void this.onRunWorkflow();
      } else if (e.key === "S" && shiftModifier && !readOnly) {
        void this.onAddNodes({ nodes: [{ type: STICKY_NODE_TYPE }], connections: [] });
      } else if (e.key === this.deviceSupport.controlKeyCode) {
        this.ctrlKeyPressed = true;
      } else if (e.key === " ") {
        this.moveCanvasKeyPressed = true;
      } else if (e.key === "F2" && noModifierKeys && !readOnly) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode !== null && lastSelectedNode.type !== STICKY_NODE_TYPE) {
          void this.callDebounced(
            this.renameNodePrompt,
            { debounceTime: 1500 },
            lastSelectedNode.name
          );
        }
      } else if (e.key === "a" && ctrlModifier) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.selectAllNodes, { debounceTime: 1e3 });
      } else if (e.key === "c" && ctrlModifier) {
        void this.callDebounced(this.copyNodes, { debounceTime: 1e3 }, selectedNodes);
      } else if (e.key === "x" && ctrlModifier && !readOnly) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.cutNodes, { debounceTime: 1e3 }, selectedNodes);
      } else if (e.key === "n" && ctrlAltModifier) {
        e.stopPropagation();
        e.preventDefault();
        if (this.isDemo) {
          return;
        }
        if (this.$router.currentRoute.value.name === VIEWS.NEW_WORKFLOW) {
          nodeViewEventBus.emit("newWorkflow");
        } else {
          void this.$router.push({ name: VIEWS.NEW_WORKFLOW });
        }
        this.showMessage({
          title: this.i18n.baseText("nodeView.showMessage.keyDown.title"),
          type: "success"
        });
      } else if (e.key === "Enter" && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode !== null) {
          if (lastSelectedNode.type === STICKY_NODE_TYPE && (this.isReadOnlyRoute || this.readOnlyEnv || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update))) {
            return;
          }
          this.ndvStore.activeNodeName = lastSelectedNode.name;
        }
      } else if (e.key === "ArrowRight" && shiftModifier) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.selectDownstreamNodes, {
          debounceTime: 1e3
        });
      } else if (e.key === "ArrowRight" && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode === null) {
          return;
        }
        const connections2 = this.workflowsStore.outgoingConnectionsByNodeName(
          lastSelectedNode.name
        );
        if (connections2.main === void 0 || connections2.main.length === 0 || !connections2.main[0]) {
          return;
        }
        void this.callDebounced(
          this.nodeSelectedByName,
          { debounceTime: 100 },
          connections2.main[0][0].node,
          false,
          true
        );
      } else if (e.key === "ArrowLeft" && shiftModifier) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.selectUpstreamNodes, {
          debounceTime: 1e3
        });
      } else if (e.key === "ArrowLeft" && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode === null) {
          return;
        }
        const workflow = this.workflowHelpers.getCurrentWorkflow();
        if (!workflow.connectionsByDestinationNode.hasOwnProperty(lastSelectedNode.name)) {
          return;
        }
        const connections2 = workflow.connectionsByDestinationNode[lastSelectedNode.name];
        if (connections2.main === void 0 || connections2.main.length === 0 || !connections2.main[0]) {
          return;
        }
        void this.callDebounced(
          this.nodeSelectedByName,
          { debounceTime: 100 },
          connections2.main[0][0].node,
          false,
          true
        );
      } else if (["ArrowUp", "ArrowDown"].includes(e.key) && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode === null) {
          return;
        }
        const workflow = this.workflowHelpers.getCurrentWorkflow();
        if (!workflow.connectionsByDestinationNode.hasOwnProperty(lastSelectedNode.name)) {
          return;
        }
        const connections2 = workflow.connectionsByDestinationNode[lastSelectedNode.name];
        if (!Array.isArray(connections2.main) || !connections2.main.length) {
          return;
        }
        const parentNode = connections2.main[0]?.[0].node;
        if (!parentNode) {
          return;
        }
        const connectionsParent = this.workflowsStore.outgoingConnectionsByNodeName(parentNode);
        if (!Array.isArray(connectionsParent.main) || !connectionsParent.main.length) {
          return;
        }
        let siblingNode;
        let lastCheckedNodePosition = e.key === "ArrowUp" ? -99999999 : 99999999;
        let nextSelectNode = null;
        for (const ouputConnections of connectionsParent.main) {
          for (const ouputConnection of ouputConnections ?? []) {
            if (ouputConnection.node === lastSelectedNode.name) {
              continue;
            }
            siblingNode = this.workflowsStore.getNodeByName(ouputConnection.node);
            if (siblingNode) {
              if (e.key === "ArrowUp") {
                if (siblingNode.position[1] <= lastSelectedNode.position[1] && siblingNode.position[1] > lastCheckedNodePosition) {
                  nextSelectNode = siblingNode.name;
                  lastCheckedNodePosition = siblingNode.position[1];
                }
              } else {
                if (siblingNode.position[1] >= lastSelectedNode.position[1] && siblingNode.position[1] < lastCheckedNodePosition) {
                  nextSelectNode = siblingNode.name;
                  lastCheckedNodePosition = siblingNode.position[1];
                }
              }
            }
          }
        }
        if (nextSelectNode !== null) {
          void this.callDebounced(
            this.nodeSelectedByName,
            { debounceTime: 100 },
            nextSelectNode,
            false,
            true
          );
        }
      }
    },
    toggleActivationNodes(nodes) {
      if (!this.editAllowedCheck()) {
        return;
      }
      this.nodeHelpers.disableNodes(nodes, { trackHistory: true, trackBulk: true });
    },
    togglePinNodes(nodes, source) {
      if (!this.editAllowedCheck()) {
        return;
      }
      this.historyStore.startRecordingUndo();
      const nextStatePinned = nodes.some(
        (node2) => !this.workflowsStore.pinDataByNodeName(node2.name)
      );
      for (const node2 of nodes) {
        const pinnedDataForNode = usePinnedData(node2);
        if (nextStatePinned) {
          const dataToPin = this.dataSchema.getInputDataWithPinned(node2);
          if (dataToPin.length !== 0) {
            pinnedDataForNode.setData(dataToPin, source);
          }
        } else {
          pinnedDataForNode.unsetData(source);
        }
      }
      this.historyStore.stopRecordingUndo();
    },
    deleteNodes(nodes) {
      this.historyStore.startRecordingUndo();
      nodes.forEach((node2) => {
        this.removeNode(node2.name, true, false);
      });
      setTimeout(() => {
        this.historyStore.stopRecordingUndo();
      }, 200);
    },
    selectAllNodes() {
      this.nodes.forEach((node2) => {
        this.nodeSelectedByName(node2.name);
      });
    },
    selectUpstreamNodes() {
      const lastSelectedNode = this.lastSelectedNode;
      if (lastSelectedNode === null) {
        return;
      }
      this.deselectAllNodes();
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const checkNodes = this.workflowHelpers.getConnectedNodes(
        "upstream",
        workflow,
        lastSelectedNode.name
      );
      for (const nodeName of checkNodes) {
        this.nodeSelectedByName(nodeName);
      }
      this.nodeSelectedByName(lastSelectedNode.name);
    },
    selectDownstreamNodes() {
      const lastSelectedNode = this.lastSelectedNode;
      if (lastSelectedNode === null) {
        return;
      }
      this.deselectAllNodes();
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const checkNodes = this.workflowHelpers.getConnectedNodes(
        "downstream",
        workflow,
        lastSelectedNode.name
      );
      for (const nodeName of checkNodes) {
        this.nodeSelectedByName(nodeName);
      }
      this.nodeSelectedByName(lastSelectedNode.name);
    },
    pushDownstreamNodes(sourceNodeName, margin, recordHistory = false) {
      const sourceNode = this.workflowsStore.nodesByName[sourceNodeName];
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const checkNodes = this.workflowHelpers.getConnectedNodes(
        "downstream",
        workflow,
        sourceNodeName
      );
      for (const nodeName of checkNodes) {
        const node2 = this.workflowsStore.nodesByName[nodeName];
        const oldPosition = node2.position;
        if (node2.position[0] < sourceNode.position[0]) {
          continue;
        }
        const updateInformation = {
          name: nodeName,
          properties: {
            position: [node2.position[0] + margin, node2.position[1]]
          }
        };
        this.workflowsStore.updateNodeProperties(updateInformation);
        this.onNodeMoved(node2);
        if (recordHistory && oldPosition[0] !== updateInformation.properties.position[0] || oldPosition[1] !== updateInformation.properties.position[1]) {
          this.historyStore.pushCommandToUndo(
            new MoveNodeCommand(nodeName, oldPosition, updateInformation.properties.position),
            recordHistory
          );
        }
      }
    },
    cutNodes(nodes) {
      const deleteCopiedNodes = !this.isReadOnlyRoute && !this.readOnlyEnv && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
      this.copyNodes(nodes, deleteCopiedNodes);
      if (deleteCopiedNodes) {
        this.deleteNodes(nodes);
      }
    },
    copyNodes(nodes, isCut = false) {
      void this.getNodesToSave(nodes).then((data) => {
        const workflowToCopy = {
          meta: {
            ...this.workflowsStore.workflow.meta,
            instanceId: this.rootStore.instanceId
          },
          ...data
        };
        delete workflowToCopy.meta.templateCredsSetupCompleted;
        this.workflowHelpers.removeForeignCredentialsFromWorkflow(
          workflowToCopy,
          this.credentialsStore.allCredentials
        );
        const nodeData = JSON.stringify(workflowToCopy, null, 2);
        void this.clipboard.copy(nodeData);
        if (data.nodes.length > 0) {
          if (!isCut) {
            this.showMessage({
              title: this.i18n.baseText("generic.copiedToClipboard"),
              message: "",
              type: "success"
            });
          }
          this.$telemetry.track("User copied nodes", {
            node_types: data.nodes.map((node2) => node2.type),
            workflow_id: this.workflowsStore.workflowId
          });
        }
      });
    },
    async stopExecution() {
      const executionId = this.workflowsStore.activeExecutionId;
      if (executionId === null) {
        return;
      }
      try {
        this.stopExecutionInProgress = true;
        await this.executionsStore.stopCurrentExecution(executionId);
      } catch (error) {
        const execution = await this.workflowsStore.getExecution(executionId);
        if (execution === void 0) {
          this.workflowsStore.executingNode.length = 0;
          this.uiStore.removeActiveAction("workflowRunning");
          this.workflowHelpers.setDocumentTitle(this.workflowsStore.workflowName, "IDLE");
          this.showMessage({
            title: this.i18n.baseText("nodeView.showMessage.stopExecutionCatch.unsaved.title"),
            message: this.i18n.baseText("nodeView.showMessage.stopExecutionCatch.unsaved.message"),
            type: "success"
          });
        } else if (execution?.finished) {
          const executedData = {
            data: execution.data,
            finished: execution.finished,
            mode: execution.mode,
            startedAt: execution.startedAt,
            stoppedAt: execution.stoppedAt
          };
          this.workflowHelpers.setDocumentTitle(execution.workflowData.name, "IDLE");
          this.workflowsStore.executingNode.length = 0;
          this.workflowsStore.setWorkflowExecutionData(executedData);
          this.uiStore.removeActiveAction("workflowRunning");
          this.showMessage({
            title: this.i18n.baseText("nodeView.showMessage.stopExecutionCatch.title"),
            message: this.i18n.baseText("nodeView.showMessage.stopExecutionCatch.message"),
            type: "success"
          });
        } else {
          this.showError(error, this.i18n.baseText("nodeView.showError.stopExecution.title"));
        }
      } finally {
        this.workflowsStore.markExecutionAsStopped();
      }
      this.stopExecutionInProgress = false;
      void this.workflowHelpers.getWorkflowDataToSave().then((workflowData) => {
        const trackProps = {
          workflow_id: this.workflowsStore.workflowId,
          node_graph_string: JSON.stringify(
            generateNodesGraph(
              workflowData,
              this.workflowHelpers.getNodeTypes(),
              { isCloudDeployment: this.settingsStore.isCloudDeployment }
            ).nodeGraph
          )
        };
        this.$telemetry.track("User clicked stop workflow execution", trackProps);
      });
    },
    async stopWaitingForWebhook() {
      try {
        await this.workflowsStore.removeTestWebhook(this.workflowsStore.workflowId);
      } catch (error) {
        this.showError(error, this.i18n.baseText("nodeView.showError.stopWaitingForWebhook.title"));
        return;
      }
    },
    /**
     * This method gets called when data got pasted into the window
     */
    async onClipboardPasteEvent(plainTextData) {
      if (this.readOnlyEnv || this.isReadOnlyRoute || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
        return;
      }
      const currentTab = getNodeViewTab(this.$route);
      if (currentTab === MAIN_HEADER_TABS.WORKFLOW) {
        let workflowData;
        if (!this.editAllowedCheck()) {
          return;
        }
        if (plainTextData.match(VALID_WORKFLOW_IMPORT_URL_REGEX)) {
          if (!this.editAllowedCheck()) {
            return;
          }
          const importConfirm = await this.confirm(
            this.i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.message", {
              interpolate: { plainTextData }
            }),
            this.i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.headline"),
            {
              type: "warning",
              confirmButtonText: this.i18n.baseText(
                "nodeView.confirmMessage.onClipboardPasteEvent.confirmButtonText"
              ),
              cancelButtonText: this.i18n.baseText(
                "nodeView.confirmMessage.onClipboardPasteEvent.cancelButtonText"
              )
            }
          );
          if (importConfirm !== MODAL_CONFIRM) {
            return;
          }
          workflowData = await this.getWorkflowDataFromUrl(plainTextData);
          if (workflowData === void 0) {
            return;
          }
        } else {
          try {
            workflowData = JSON.parse(plainTextData);
            if (!this.editAllowedCheck()) {
              return;
            }
          } catch (e) {
            return;
          }
        }
        if (!workflowData) {
          return;
        }
        return await this.importWorkflowData(workflowData, "paste", false);
      }
    },
    // Returns the workflow data from a given URL. If no data gets found or
    // data is invalid it returns undefined and displays an error message by itself.
    async getWorkflowDataFromUrl(url) {
      let workflowData;
      this.canvasStore.startLoading();
      try {
        workflowData = await this.workflowsStore.getWorkflowFromUrl(url);
      } catch (error) {
        this.canvasStore.stopLoading();
        this.showError(
          error,
          this.i18n.baseText("nodeView.showError.getWorkflowDataFromUrl.title")
        );
        return;
      }
      this.canvasStore.stopLoading();
      return workflowData;
    },
    // Imports the given workflow data into the current workflow
    async importWorkflowData(workflowData, source, importTags = true) {
      if (!workflowData.hasOwnProperty("nodes") || !workflowData.hasOwnProperty("connections")) {
        return;
      }
      try {
        const nodeIdMap = {};
        if (workflowData.nodes) {
          const nodeNames = workflowData.nodes.map((node2) => node2.name);
          workflowData.nodes.forEach((node2) => {
            if (!node2.name) {
              const nodeType = this.nodeTypesStore.getNodeType(node2.type);
              const newName = this.uniqueNodeName(nodeType?.displayName ?? node2.type, nodeNames);
              node2.name = newName;
              nodeNames.push(newName);
            }
            if (node2.webhookId && UPDATE_WEBHOOK_ID_NODE_TYPES.includes(node2.type)) {
              const isDuplicate = Object.values(
                this.workflowHelpers.getCurrentWorkflow().nodes
              ).some((n) => n.webhookId === node2.webhookId);
              if (isDuplicate) {
                node2.webhookId = v4();
                if (node2.parameters.path) {
                  node2.parameters.path = node2.webhookId;
                } else if (node2.parameters.options.path) {
                  node2.parameters.options.path = node2.webhookId;
                }
              }
            }
            if (node2.id) {
              const newId = v4();
              nodeIdMap[newId] = node2.id;
              node2.id = newId;
            } else {
              node2.id = v4();
            }
          });
        }
        this.removeUnknownCredentials(workflowData);
        const currInstanceId = this.rootStore.instanceId;
        const nodeGraph = JSON.stringify(
          generateNodesGraph(
            workflowData,
            this.workflowHelpers.getNodeTypes(),
            {
              nodeIdMap,
              sourceInstanceId: workflowData.meta && workflowData.meta.instanceId !== currInstanceId ? workflowData.meta.instanceId : "",
              isCloudDeployment: this.settingsStore.isCloudDeployment
            }
          ).nodeGraph
        );
        if (source === "paste") {
          this.$telemetry.track("User pasted nodes", {
            workflow_id: this.workflowsStore.workflowId,
            node_graph_string: nodeGraph
          });
        } else if (source === "duplicate") {
          this.$telemetry.track("User duplicated nodes", {
            workflow_id: this.workflowsStore.workflowId,
            node_graph_string: nodeGraph
          });
        } else {
          this.$telemetry.track("User imported workflow", {
            source,
            workflow_id: this.workflowsStore.workflowId,
            node_graph_string: nodeGraph
          });
        }
        this.deselectAllNodes();
        this.workflowHelpers.updateNodePositions(
          workflowData,
          getNewNodePosition(this.nodes, this.lastClickPosition)
        );
        const data = await this.addNodesToWorkflow(workflowData);
        setTimeout(() => {
          (data?.nodes ?? []).forEach((node2) => {
            this.nodeSelectedByName(node2.name);
          });
        });
        const tagsEnabled = this.settingsStore.areTagsEnabled;
        if (importTags && tagsEnabled && Array.isArray(workflowData.tags)) {
          const allTags = await this.tagsStore.fetchAll();
          const tagNames = new Set(allTags.map((tag) => tag.name));
          const workflowTags = workflowData.tags;
          const notFound = workflowTags.filter((tag) => !tagNames.has(tag.name));
          const creatingTagPromises = [];
          for (const tag of notFound) {
            const creationPromise = this.tagsStore.create(tag.name).then((tag2) => {
              allTags.push(tag2);
              return tag2;
            });
            creatingTagPromises.push(creationPromise);
          }
          await Promise.all(creatingTagPromises);
          const tagIds = workflowTags.reduce((accu, imported) => {
            const tag = allTags.find((tag2) => tag2.name === imported.name);
            if (tag) {
              accu.push(tag.id);
            }
            return accu;
          }, []);
          this.workflowsStore.addWorkflowTagIds(tagIds);
          setTimeout(() => {
            this.nodeHelpers.addPinDataConnections(this.workflowsStore.pinnedWorkflowData);
          });
        }
      } catch (error) {
        this.showError(error, this.i18n.baseText("nodeView.showError.importWorkflowData.title"));
      }
    },
    removeUnknownCredentials(workflow) {
      if (!workflow?.nodes) return;
      for (const node2 of workflow.nodes) {
        if (!node2.credentials) continue;
        for (const [name, credential] of Object.entries(node2.credentials)) {
          if (typeof credential === "string" || credential.id === null) continue;
          if (!this.credentialsStore.getCredentialById(credential.id)) {
            delete node2.credentials[name];
          }
        }
      }
    },
    onDragOver(event) {
      event.preventDefault();
    },
    async onDrop(event) {
      if (!event.dataTransfer) {
        return;
      }
      const dropData = jsonParse(
        event.dataTransfer.getData(DRAG_EVENT_DATA_KEY)
      );
      if (dropData) {
        const mousePosition = this.getMousePositionWithinNodeView(event);
        const insertNodePosition = [mousePosition[0], mousePosition[1]];
        await this.onAddNodes(dropData, true, insertNodePosition);
        this.createNodeActive = false;
      }
    },
    nodeDeselectedByName(nodeName) {
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        this.nodeDeselected(node2);
      }
    },
    nodeSelectedByName(nodeName, setActive = false, deselectAllOthers) {
      if (deselectAllOthers === true) {
        this.deselectAllNodes();
      }
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        this.nodeSelected(node2);
        this.uiStore.lastSelectedNode = node2.name;
        this.uiStore.lastSelectedNodeOutputIndex = null;
        this.uiStore.lastSelectedNodeEndpointUuid = null;
        this.canvasStore.newNodeInsertPosition = null;
        this.canvasStore.setLastSelectedConnection(void 0);
        if (setActive) {
          this.ndvStore.activeNodeName = node2.name;
        }
      }
    },
    showMaxNodeTypeError(nodeTypeData) {
      const maxNodes = nodeTypeData.maxNodes;
      this.showMessage({
        title: this.i18n.baseText("nodeView.showMessage.showMaxNodeTypeError.title"),
        message: this.i18n.baseText("nodeView.showMessage.showMaxNodeTypeError.message", {
          adjustToNumber: maxNodes,
          interpolate: { nodeTypeDataDisplayName: nodeTypeData.displayName }
        }),
        type: "error",
        duration: 0
      });
    },
    async getNewNodeWithDefaultCredential(nodeTypeData, overrides) {
      let nodeVersion = nodeTypeData.defaultVersion;
      if (nodeVersion === void 0) {
        nodeVersion = Array.isArray(nodeTypeData.version) ? nodeTypeData.version.slice(-1)[0] : nodeTypeData.version;
      }
      const newNodeData = {
        id: v4(),
        name: overrides.name ?? nodeTypeData.defaults.name,
        type: nodeTypeData.name,
        typeVersion: nodeVersion,
        position: [0, 0],
        parameters: {}
      };
      const credentialPerType = nodeTypeData.credentials?.map((type) => this.credentialsStore.getUsableCredentialByType(type.name)).flat();
      if (credentialPerType && credentialPerType.length === 1) {
        const defaultCredential = credentialPerType[0];
        const selectedCredentials = this.credentialsStore.getCredentialById(defaultCredential.id);
        const selected = { id: selectedCredentials.id, name: selectedCredentials.name };
        const credentials = {
          [defaultCredential.type]: selected
        };
        await this.nodeHelpers.loadNodesProperties(
          [newNodeData].map((node2) => ({ name: node2.type, version: node2.typeVersion }))
        );
        const nodeType = this.nodeTypesStore.getNodeType(newNodeData.type, newNodeData.typeVersion);
        const nodeParameters = getNodeParameters(
          nodeType?.properties || [],
          {},
          true,
          false,
          newNodeData
        );
        if (nodeTypeData.credentials) {
          const authentication = nodeTypeData.credentials.find(
            (type) => type.name === defaultCredential.type
          );
          if (authentication?.displayOptions?.hide) {
            return newNodeData;
          }
          const authDisplayOptions = authentication?.displayOptions?.show;
          if (!authDisplayOptions) {
            newNodeData.credentials = credentials;
            return newNodeData;
          }
          if (Object.keys(authDisplayOptions).length === 1 && authDisplayOptions.authentication) {
            newNodeData.credentials = credentials;
            let parameters = {};
            for (const displayOption of Object.keys(authDisplayOptions)) {
              if (nodeParameters && !nodeParameters[displayOption]) {
                parameters = {};
                newNodeData.credentials = void 0;
                break;
              }
              const optionValue = authDisplayOptions[displayOption]?.[0];
              if (optionValue && typeof optionValue === "string") {
                parameters[displayOption] = optionValue;
              }
              newNodeData.parameters = {
                ...newNodeData.parameters,
                ...parameters
              };
            }
          }
        }
      }
      return newNodeData;
    },
    async injectNode(nodeTypeName, options = {}, showDetail = true, trackHistory = false, isAutoAdd = false) {
      const nodeTypeData = this.nodeTypesStore.getNodeType(nodeTypeName);
      if (nodeTypeData === null) {
        this.showMessage({
          title: this.i18n.baseText("nodeView.showMessage.addNodeButton.title"),
          message: this.i18n.baseText("nodeView.showMessage.addNodeButton.message", {
            interpolate: { nodeTypeName }
          }),
          type: "error"
        });
        return;
      }
      if (nodeTypeData.maxNodes !== void 0 && this.workflowHelpers.getNodeTypeCount(nodeTypeName) >= nodeTypeData.maxNodes) {
        this.showMaxNodeTypeError(nodeTypeData);
        return;
      }
      const newNodeData = await this.getNewNodeWithDefaultCredential(nodeTypeData, {
        name: options.name
      });
      const lastSelectedNode = this.lastSelectedNode;
      if (options.position) {
        newNodeData.position = getNewNodePosition(
          this.canvasStore.getNodesWithPlaceholderNode(),
          options.position
        );
      } else if (lastSelectedNode) {
        const lastSelectedConnection = this.canvasStore.lastSelectedConnection;
        if (lastSelectedConnection) {
          const [diffX] = getConnectorLengths(lastSelectedConnection);
          if (diffX <= MAX_X_TO_PUSH_DOWNSTREAM_NODES) {
            this.pushDownstreamNodes(
              lastSelectedNode.name,
              PUSH_NODES_OFFSET,
              trackHistory
            );
          }
        }
        if (this.canvasStore.newNodeInsertPosition) {
          newNodeData.position = getNewNodePosition(this.nodes, [
            this.canvasStore.newNodeInsertPosition[0] + GRID_SIZE,
            this.canvasStore.newNodeInsertPosition[1] - NODE_SIZE / 2
          ]);
          this.canvasStore.newNodeInsertPosition = null;
        } else {
          let yOffset = 0;
          const workflow = this.workflowHelpers.getCurrentWorkflow();
          if (lastSelectedConnection) {
            const sourceNodeType = this.nodeTypesStore.getNodeType(
              lastSelectedNode.type,
              lastSelectedNode.typeVersion
            );
            if (sourceNodeType) {
              const sourceNodeOutputs = getNodeOutputs(
                workflow,
                lastSelectedNode,
                sourceNodeType
              );
              const sourceNodeOutputTypes = getConnectionTypes(sourceNodeOutputs);
              const sourceNodeOutputMainOutputs = sourceNodeOutputTypes.filter(
                (output) => output === NodeConnectionType.Main
              );
              if (sourceNodeOutputMainOutputs.length > 1) {
                const offset = generateOffsets(
                  sourceNodeOutputMainOutputs.length,
                  NODE_SIZE,
                  GRID_SIZE
                );
                const sourceOutputIndex = lastSelectedConnection.__meta ? lastSelectedConnection.__meta.sourceOutputIndex : 0;
                yOffset = offset[sourceOutputIndex];
              }
            }
          }
          let outputs2 = [];
          try {
            outputs2 = getNodeOutputs(workflow, newNodeData, nodeTypeData);
          } catch (e) {
          }
          const outputTypes = getConnectionTypes(outputs2);
          const lastSelectedNodeType = this.nodeTypesStore.getNodeType(
            lastSelectedNode.type,
            lastSelectedNode.typeVersion
          );
          const lastSelectedNodeWorkflow = workflow.getNode(lastSelectedNode.name);
          if (!lastSelectedNodeWorkflow || !lastSelectedNodeType) {
            console.error("Could not find last selected node or node type");
            return;
          }
          if (outputTypes.length > 0 && outputTypes.every((outputName) => outputName !== NodeConnectionType.Main)) {
            const lastSelectedInputs = getNodeInputs(
              workflow,
              lastSelectedNodeWorkflow,
              lastSelectedNodeType
            );
            const lastSelectedInputTypes = getConnectionTypes(lastSelectedInputs);
            const scopedConnectionIndex = (lastSelectedInputTypes || []).filter((input) => input !== NodeConnectionType.Main).findIndex((inputType) => outputs2[0] === inputType);
            newNodeData.position = getNewNodePosition(
              this.nodes,
              [
                lastSelectedNode.position[0] + NODE_SIZE / (Math.max(lastSelectedNodeType?.inputs?.length ?? 1), 1) * scopedConnectionIndex,
                lastSelectedNode.position[1] + PUSH_NODES_OFFSET
              ],
              [100, 0]
            );
          } else {
            const inputs = getNodeInputs(
              workflow,
              lastSelectedNode,
              lastSelectedNodeType
            );
            const inputsTypes = getConnectionTypes(inputs);
            let pushOffset = PUSH_NODES_OFFSET;
            if (!!inputsTypes.find((input) => input !== NodeConnectionType.Main)) {
              pushOffset += 150;
            }
            newNodeData.position = getNewNodePosition(
              this.nodes,
              [lastSelectedNode.position[0] + pushOffset, lastSelectedNode.position[1] + yOffset],
              [100, 0]
            );
          }
        }
      } else {
        const position = this.nodeTypesStore.isTriggerNode(nodeTypeName) && !this.containsTrigger ? this.canvasStore.canvasAddButtonPosition : (
          // If no node is active find a free spot
          this.lastClickPosition
        );
        newNodeData.position = getNewNodePosition(this.nodes, position);
      }
      const localizedName = this.i18n.localizeNodeName(newNodeData.name, newNodeData.type);
      newNodeData.name = this.uniqueNodeName(localizedName);
      if (nodeTypeData.webhooks?.length) {
        newNodeData.webhookId = v4();
      }
      await this.nodeHelpers.addNodes([newNodeData], void 0, trackHistory);
      this.workflowsStore.setNodePristine(newNodeData.name, true);
      this.uiStore.stateIsDirty = true;
      if (nodeTypeName === STICKY_NODE_TYPE) {
        this.$telemetry.track("User inserted workflow note", {
          workflow_id: this.workflowsStore.workflowId
        });
      } else {
        void this.externalHooks.run("nodeView.addNodeButton", { nodeTypeName });
        this.nodeCreatorStore.onNodeAddedToCanvas({
          node_type: nodeTypeName,
          node_version: newNodeData.typeVersion,
          is_auto_add: isAutoAdd,
          workflow_id: this.workflowsStore.workflowId,
          drag_and_drop: options.dragAndDrop,
          input_node_type: lastSelectedNode ? lastSelectedNode.type : void 0
        });
      }
      if (trackHistory && !isAutoAdd) {
        this.deselectAllNodes();
        setTimeout(() => {
          this.nodeSelectedByName(
            newNodeData.name,
            showDetail && nodeTypeName !== STICKY_NODE_TYPE
          );
        });
      }
      return newNodeData;
    },
    getConnection(sourceNodeName, sourceNodeOutputIndex, targetNodeName, targetNodeOuputIndex, type) {
      const nodeConnections = this.workflowsStore.outgoingConnectionsByNodeName(sourceNodeName)[type];
      if (nodeConnections) {
        const connections2 = nodeConnections[sourceNodeOutputIndex];
        if (connections2) {
          return connections2.find(
            (connection) => connection.node === targetNodeName && connection.index === targetNodeOuputIndex
          );
        }
      }
      return void 0;
    },
    connectTwoNodes(sourceNodeName, sourceNodeOutputIndex, targetNodeName, targetNodeOutputIndex, type) {
      this.uiStore.stateIsDirty = true;
      const sourceNode = this.workflowsStore.getNodeByName(sourceNodeName);
      const targetNode = this.workflowsStore.getNodeByName(targetNodeName);
      if (sourceNode && targetNode && !this.checkNodeConnectionAllowed(sourceNode, targetNode, type)) {
        return;
      }
      if (this.getConnection(
        sourceNodeName,
        sourceNodeOutputIndex,
        targetNodeName,
        targetNodeOutputIndex,
        type
      )) {
        return;
      }
      const connectionData = [
        {
          node: sourceNodeName,
          type,
          index: sourceNodeOutputIndex
        },
        {
          node: targetNodeName,
          type,
          index: targetNodeOutputIndex
        }
      ];
      this.nodeHelpers.addConnection(connectionData);
    },
    async addNode(nodeTypeName, options = {}, showDetail = true, trackHistory = false, isAutoAdd = false) {
      if (!this.editAllowedCheck()) {
        return;
      }
      const lastSelectedNode = this.lastSelectedNode;
      const lastSelectedNodeOutputIndex = this.uiStore.lastSelectedNodeOutputIndex;
      const lastSelectedNodeEndpointUuid = this.uiStore.lastSelectedNodeEndpointUuid;
      const lastSelectedConnection = this.canvasStore.lastSelectedConnection;
      this.historyStore.startRecordingUndo();
      const newNodeData = await this.injectNode(
        nodeTypeName,
        options,
        showDetail,
        trackHistory,
        isAutoAdd
      );
      if (!newNodeData) {
        return;
      }
      const outputIndex = lastSelectedNodeOutputIndex || 0;
      const targetEndpoint = lastSelectedNodeEndpointUuid || "";
      if (lastSelectedNodeEndpointUuid && !isAutoAdd && lastSelectedNode) {
        const lastSelectedEndpoint = this.instance.getEndpoint(lastSelectedNodeEndpointUuid);
        if (lastSelectedEndpoint && this.checkNodeConnectionAllowed(
          lastSelectedNode,
          newNodeData,
          lastSelectedEndpoint.scope
        )) {
          const connectionType2 = lastSelectedEndpoint.scope;
          const newNodeElement = this.instance.getManagedElement(newNodeData.id);
          const newNodeConnections = this.instance.getEndpoints(newNodeElement);
          const viableConnection = newNodeConnections.find((conn) => {
            return conn.scope === connectionType2 && lastSelectedEndpoint.parameters.connection !== conn.parameters.connection;
          });
          this.instance?.connect({
            uuids: [targetEndpoint, viableConnection?.uuid || ""],
            detachable: !this.isReadOnlyRoute && !this.readOnlyEnv && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
          });
          this.historyStore.stopRecordingUndo();
          return;
        }
      }
      if (lastSelectedNode && !isAutoAdd) {
        await this.$nextTick();
        if (lastSelectedConnection?.__meta) {
          this.nodeHelpers.deleteJSPlumbConnection(lastSelectedConnection, trackHistory);
          const targetNodeName = lastSelectedConnection.__meta.targetNodeName;
          const targetOutputIndex = lastSelectedConnection.__meta.targetOutputIndex;
          this.connectTwoNodes(
            newNodeData.name,
            0,
            targetNodeName,
            targetOutputIndex,
            NodeConnectionType.Main
          );
        }
        this.connectTwoNodes(
          lastSelectedNode.name,
          outputIndex,
          newNodeData.name,
          0,
          NodeConnectionType.Main
        );
      }
      this.historyStore.stopRecordingUndo();
    },
    getNodeCreatorFilter(nodeName, outputType) {
      let filter;
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const workflowNode = workflow.getNode(nodeName);
      if (!workflowNode) return { nodes: [] };
      const nodeType = this.nodeTypesStore.getNodeType(
        workflowNode?.type,
        workflowNode.typeVersion
      );
      if (nodeType) {
        const inputs = getNodeInputs(workflow, workflowNode, nodeType);
        const filterFound = inputs.filter((input) => {
          if (typeof input === "string" || input.type !== outputType || !input.filter) {
            return false;
          }
          return true;
        });
        if (filterFound.length) {
          filter = filterFound[0].filter;
        }
      }
      return filter;
    },
    insertNodeAfterSelected(info) {
      const type = info.outputType ?? NodeConnectionType.Main;
      const sourceNode = this.workflowsStore.getNodeById(info.sourceId);
      if (!sourceNode) {
        return;
      }
      this.uiStore.lastSelectedNode = sourceNode.name;
      this.uiStore.lastSelectedNodeEndpointUuid = info.endpointUuid ?? info.connection?.target.jtk?.endpoint.uuid;
      this.uiStore.lastSelectedNodeOutputIndex = info.index;
      this.canvasStore.newNodeInsertPosition = null;
      if (info.connection) {
        this.canvasStore.setLastSelectedConnection(info.connection);
      }
      this.onToggleNodeCreator({
        source: info.eventSource,
        createNodeActive: true,
        nodeCreatorView: info.nodeCreatorView
      });
      const isOutput = info.connection?.endpoints[0].parameters.connection === "source";
      const isScopedConnection = type !== NodeConnectionType.Main && nodeConnectionTypes.includes(type);
      if (isScopedConnection) {
        useViewStacks().gotoCompatibleConnectionView(
          type,
          isOutput,
          this.getNodeCreatorFilter(sourceNode.name, type)
        ).catch(() => {
        });
      }
    },
    async onEventConnectionAbort(connection) {
      try {
        if (this.dropPrevented) {
          this.dropPrevented = false;
          return;
        }
        if (this.nodeHelpers.pullConnActiveNodeName.value) {
          const sourceNode = this.workflowsStore.getNodeById(connection.parameters.nodeId);
          const connectionType2 = connection.parameters.type ?? NodeConnectionType.Main;
          const overrideTargetEndpoint = connection?.connector?.overrideTargetEndpoint;
          if (sourceNode) {
            const isTarget = connection.parameters.connection === "target";
            const sourceNodeName = isTarget ? this.nodeHelpers.pullConnActiveNodeName.value : sourceNode.name;
            const targetNodeName = isTarget ? sourceNode.name : this.nodeHelpers.pullConnActiveNodeName.value;
            const outputIndex = connection.parameters.index;
            resetConnectionAfterPull(connection);
            await this.$nextTick();
            this.connectTwoNodes(
              sourceNodeName,
              outputIndex,
              targetNodeName,
              overrideTargetEndpoint?.parameters?.index ?? 0,
              connectionType2
            );
            this.nodeHelpers.pullConnActiveNodeName.value = null;
            this.dropPrevented = false;
          }
          return;
        }
        this.insertNodeAfterSelected({
          sourceId: connection.parameters.nodeId,
          index: connection.parameters.index,
          eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_DROP,
          connection,
          outputType: connection.parameters.type
        });
      } catch (e) {
        console.error(e);
      }
    },
    checkNodeConnectionAllowed(sourceNode, targetNode, targetInfoType) {
      const targetNodeType = this.nodeTypesStore.getNodeType(
        targetNode.type,
        targetNode.typeVersion
      );
      if (targetNodeType?.inputs?.length) {
        const workflow = this.workflowHelpers.getCurrentWorkflow();
        const workflowNode = workflow.getNode(targetNode.name);
        let inputs = [];
        if (targetNodeType && workflowNode) {
          inputs = getNodeInputs(workflow, workflowNode, targetNodeType);
        }
        for (const input of inputs || []) {
          if (typeof input === "string" || input.type !== targetInfoType || !input.filter) {
            continue;
          }
          if (input.filter.nodes.length) {
            if (!input.filter.nodes.includes(sourceNode.type)) {
              this.dropPrevented = true;
              this.showToast({
                title: this.i18n.baseText("nodeView.showError.nodeNodeCompatible.title"),
                message: this.i18n.baseText("nodeView.showError.nodeNodeCompatible.message", {
                  interpolate: { sourceNodeName: sourceNode.name, targetNodeName: targetNode.name }
                }),
                type: "error",
                duration: 5e3
              });
              return false;
            }
          }
        }
      }
      return true;
    },
    onInterceptBeforeDrop(info) {
      try {
        let sourceInfo;
        let targetInfo;
        if (info.connection.endpoints[0].parameters.connection === "target") {
          sourceInfo = info.dropEndpoint.parameters;
          targetInfo = info.connection.endpoints[0].parameters;
        } else {
          sourceInfo = info.connection.endpoints[0].parameters;
          targetInfo = info.dropEndpoint.parameters;
        }
        if (sourceInfo.type !== targetInfo.type || sourceInfo.connection === targetInfo.connection) {
          this.dropPrevented = true;
          return false;
        }
        const sourceNode = this.workflowsStore.getNodeById(sourceInfo.nodeId);
        const targetNode = this.workflowsStore.getNodeById(targetInfo.nodeId);
        const sourceNodeName = sourceNode?.name || "";
        const targetNodeName = targetNode?.name || "";
        if (sourceNode && targetNode) {
          if (!this.checkNodeConnectionAllowed(sourceNode, targetNode, targetInfo.type)) {
            return false;
          }
        }
        if (this.getConnection(
          sourceNodeName,
          sourceInfo.index,
          targetNodeName,
          targetInfo.index,
          sourceInfo.type
        )) {
          this.dropPrevented = true;
          this.nodeHelpers.pullConnActiveNodeName.value = null;
          return false;
        }
        return true;
      } catch (e) {
        console.error(e);
        return true;
      }
    },
    onEventConnection(info) {
      try {
        if (info.sourceEndpoint.parameters.connection === "target") {
          const tempEndpoint = info.sourceEndpoint;
          info.sourceEndpoint = info.targetEndpoint;
          info.targetEndpoint = tempEndpoint;
        }
        const sourceInfo = info.sourceEndpoint.parameters;
        const targetInfo = info.targetEndpoint.parameters;
        const sourceNodeName = this.workflowsStore.getNodeById(sourceInfo.nodeId)?.name;
        const targetNodeName = this.workflowsStore.getNodeById(targetInfo.nodeId)?.name;
        if (sourceNodeName && targetNodeName) {
          info.connection.__meta = {
            sourceNodeName,
            sourceOutputIndex: sourceInfo.index,
            targetNodeName,
            targetOutputIndex: targetInfo.index
          };
        }
        resetConnection(info.connection);
        moveBackInputLabelPosition(info.targetEndpoint);
        if (!sourceNodeName || !targetNodeName) {
          console.error("Could not find source or target node name");
          return;
        }
        const connectionData = [
          {
            node: sourceNodeName,
            type: sourceInfo.type,
            index: sourceInfo.index
          },
          {
            node: targetNodeName,
            type: targetInfo.type,
            index: targetInfo.index
          }
        ];
        this.dropPrevented = true;
        this.workflowsStore.addConnection({ connection: connectionData });
        if (!this.isReadOnlyRoute && !this.readOnlyEnv && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
          hideOutputNameLabel(info.sourceEndpoint);
          addConnectionActionsOverlay(
            info.connection,
            () => {
              this.activeConnection = null;
              this.nodeHelpers.deleteJSPlumbConnection(info.connection);
            },
            () => {
              this.insertNodeAfterSelected({
                sourceId: info.sourceEndpoint.parameters.nodeId,
                index: sourceInfo.index,
                connection: info.connection,
                eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_ACTION
              });
            }
          );
          const endpointArrow = getOverlay(
            info.connection,
            OVERLAY_ENDPOINT_ARROW_ID
          );
          if (sourceInfo.type !== NodeConnectionType.Main) {
            info.connection.setPaintStyle(
              getConnectorPaintStyleData(info.connection, info.sourceEndpoint.parameters.category)
            );
            endpointArrow?.setVisible(false);
          }
        }
        this.dropPrevented = false;
        if (!this.isLoading) {
          this.uiStore.stateIsDirty = true;
          if (!this.suspendRecordingDetachedConnections) {
            this.historyStore.pushCommandToUndo(new AddConnectionCommand(connectionData));
          }
          if (!this.nodeHelpers.isInsertingNodes.value) {
            this.nodeHelpers.updateNodesInputIssues();
            this.resetEndpointsErrors();
            setTimeout(() => {
              addConnectionTestData(
                info.source,
                info.target,
                info.connection?.connector?.hasOwnProperty("canvas") ? info.connection.connector.canvas : void 0
              );
            }, 0);
          }
        }
      } catch (e) {
        console.error(e);
      }
    },
    onDragMove() {
      const totalNodes = this.nodes.length;
      void this.callDebounced(this.updateConnectionsOverlays, {
        debounceTime: totalNodes > 20 ? 200 : 0
      });
    },
    updateConnectionsOverlays() {
      this.instance?.connections.forEach((connection) => {
        showOrHideItemsLabel(connection);
        showOrHideMidpointArrow(connection);
        Object.values(connection.overlays).forEach((overlay) => {
          if (!overlay.canvas) return;
          this.instance?.repaint(overlay.canvas);
        });
      });
    },
    isConnectionActive(connection) {
      if (!connection?.id || !this.activeConnection?.id) return false;
      return this.activeConnection?.id === connection.id;
    },
    onConnectionMouseOver(connection) {
      try {
        if (this.exitTimer !== void 0) {
          clearTimeout(this.exitTimer);
          this.exitTimer = void 0;
        }
        if (
          // @ts-expect-error Deprecated file
          // eslint-disable-next-line no-constant-binary-expression
          !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
        )
          return;
        this.enterTimer = setTimeout(() => {
          if (this.activeConnection && !this.isConnectionActive(connection) && isJSPlumbConnection(this.activeConnection)) {
            hideConnectionActions(this.activeConnection);
          }
          this.enterTimer = void 0;
          if (connection) {
            showConnectionActions(connection);
            this.activeConnection = connection;
          }
        }, 150);
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionMouseOut(connection) {
      try {
        if (this.exitTimer) return;
        if (this.enterTimer) {
          clearTimeout(this.enterTimer);
          this.enterTimer = void 0;
        }
        if (
          // @ts-expect-error Deprecated file
          // eslint-disable-next-line no-constant-binary-expression
          !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
        )
          return;
        this.exitTimer = setTimeout(() => {
          this.exitTimer = void 0;
          if (connection && this.isConnectionActive(connection) && isJSPlumbConnection(this.activeConnection)) {
            hideConnectionActions(this.activeConnection);
            this.activeConnection = null;
          }
        }, 500);
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionMoved(info) {
      try {
        resetInputLabelPosition(info.connection);
        const sourceInfo = info.connection.parameters;
        const targetInfo = info.originalEndpoint.parameters;
        const connectionInfo = [
          {
            node: this.workflowsStore.getNodeById(sourceInfo.nodeId)?.name || "",
            type: sourceInfo.type,
            index: sourceInfo.index
          },
          {
            node: this.workflowsStore.getNodeById(targetInfo.nodeId)?.name || "",
            type: targetInfo.type,
            index: targetInfo.index
          }
        ];
        this.nodeHelpers.removeConnection(connectionInfo, false);
      } catch (e) {
        console.error(e);
      }
    },
    onEndpointMouseOver(endpoint, mouse) {
      if (!endpoint.isTarget || mouse.target !== endpoint.endpoint.canvas) return;
      this.instance.setHover(endpoint, true);
    },
    onEndpointMouseOut(endpoint) {
      if (!endpoint.isTarget) return;
      this.instance.setHover(endpoint, false);
    },
    async onConnectionDetached(info) {
      try {
        if (info.sourceEndpoint.parameters.connection === "target") {
          const tempEndpoint = info.sourceEndpoint;
          info.sourceEndpoint = info.targetEndpoint;
          info.targetEndpoint = tempEndpoint;
        }
        const connectionInfo = getConnectionInfo(info);
        resetInputLabelPosition(info.targetEndpoint);
        showOutputNameLabel(info.sourceEndpoint, info.connection);
        info.connection.removeOverlays();
        this.nodeHelpers.removeConnectionByConnectionInfo(info, false, false);
        if (this.nodeHelpers.pullConnActiveNodeName.value) {
          this.historyStore.startRecordingUndo();
          const sourceNode = this.workflowsStore.getNodeById(info.connection.parameters.nodeId);
          if (!sourceNode) {
            throw new Error("Could not find source node");
          }
          const sourceNodeName = sourceNode.name;
          const outputIndex = info.connection.parameters.index;
          const overrideTargetEndpoint = info.connection.connector.overrideTargetEndpoint;
          if (connectionInfo) {
            this.historyStore.pushCommandToUndo(new RemoveConnectionCommand(connectionInfo));
          }
          this.connectTwoNodes(
            sourceNodeName,
            outputIndex,
            this.nodeHelpers.pullConnActiveNodeName.value,
            overrideTargetEndpoint?.parameters?.index ?? 0,
            NodeConnectionType.Main
          );
          this.nodeHelpers.pullConnActiveNodeName.value = null;
          await this.$nextTick();
          this.historyStore.stopRecordingUndo();
        } else if (!this.historyStore.bulkInProgress && !this.suspendRecordingDetachedConnections && connectionInfo) {
          const removeCommand = new RemoveConnectionCommand(connectionInfo);
          this.historyStore.pushCommandToUndo(removeCommand);
        }
        void this.nodeHelpers.updateNodesInputIssues();
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionDrag(connection) {
      connection.overlays["midpoint-arrow"]?.setVisible(false);
      try {
        this.nodeHelpers.pullConnActiveNodeName.value = null;
        this.pullConnActive = true;
        this.canvasStore.newNodeInsertPosition = null;
        hideConnectionActions(connection);
        resetConnection(connection);
        const scope = connection.scope;
        const scopedEndpoints = Array.from(
          document.querySelectorAll(`[data-jtk-scope-${scope}=true]`)
        );
        const connectionType2 = connection.parameters.connection;
        const requiredType = connectionType2 === "source" ? "target" : "source";
        const filteredEndpoints = scopedEndpoints.filter((el) => {
          if (!isJSPlumbEndpointElement(el)) return false;
          const endpoint = el.jtk.endpoint;
          if (!endpoint) return false;
          const isSameNode = endpoint.parameters.nodeId === connection.parameters.nodeId;
          const endpointType = endpoint.parameters.connection;
          return !isSameNode && endpointType === requiredType;
        });
        const onMouseMove = (e) => {
          if (!connection) {
            return;
          }
          const intersectingEndpoints = filteredEndpoints.filter((element) => {
            if (!isJSPlumbEndpointElement(element)) return false;
            const endpoint = element.jtk.endpoint;
            if (element.classList.contains("jtk-floating-endpoint")) {
              return false;
            }
            const isEndpointIntersect = isElementIntersection(element, e, 50);
            const isNodeElementIntersect = isElementIntersection(
              endpoint.element,
              e,
              30
            );
            if (isEndpointIntersect || isNodeElementIntersect) {
              const node2 = this.workflowsStore.getNodeById(endpoint.parameters.nodeId);
              if (node2) {
                const nodeType = this.nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
                if (!nodeType) return false;
                return true;
              }
            }
            return false;
          }).sort((a, b) => {
            const aEndpointIntersect = calculateElementIntersection(a, e, 50);
            const bEndpointIntersect = calculateElementIntersection(b, e, 50);
            if (!aEndpointIntersect?.y && !bEndpointIntersect?.y) {
              return 0;
            }
            if (!aEndpointIntersect?.y) return 1;
            if (!bEndpointIntersect?.y) return -1;
            return bEndpointIntersect.y - aEndpointIntersect.y;
          });
          if (intersectingEndpoints.length > 0 && isJSPlumbEndpointElement(intersectingEndpoints[0])) {
            const intersectingEndpoint = intersectingEndpoints[0];
            const endpoint = intersectingEndpoint.jtk.endpoint;
            const node2 = this.workflowsStore.getNodeById(endpoint.parameters.nodeId);
            this.nodeHelpers.pullConnActiveNodeName.value = node2?.name ?? null;
            showDropConnectionState(connection, endpoint);
          } else {
            showPullConnectionState(connection);
            this.nodeHelpers.pullConnActiveNodeName.value = null;
          }
        };
        const onMouseUp = (e) => {
          this.pullConnActive = false;
          this.canvasStore.newNodeInsertPosition = this.getMousePositionWithinNodeView(e);
          resetConnectionAfterPull(connection);
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
          this.connectionDragScope = {
            type: null,
            connection: null
          };
        };
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("touchmove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("touchend", onMouseMove);
        this.connectionDragScope = {
          type: connection.parameters.type,
          connection: connection.parameters.connection
        };
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionDragAbortDetached() {
      Object.values(this.instance?.endpointsByElement).flatMap((endpoints) => Object.values(endpoints)).filter((endpoint) => endpoint.endpoint.type === "N8nPlus").forEach((endpoint) => setTimeout(() => endpoint.instance.revalidate(endpoint.element), 0));
    },
    onPlusEndpointClick(endpoint) {
      this.insertNodeAfterSelected({
        sourceId: endpoint.__meta.nodeId,
        index: endpoint.__meta.index,
        eventSource: NODE_CREATOR_OPEN_SOURCES.PLUS_ENDPOINT,
        outputType: getEndpointScope(endpoint.scope),
        endpointUuid: endpoint.uuid
      });
    },
    onAddInputEndpointClick(endpoint) {
      if (endpoint?.__meta) {
        this.insertNodeAfterSelected({
          sourceId: endpoint.__meta.nodeId,
          index: endpoint.__meta.index,
          eventSource: NODE_CREATOR_OPEN_SOURCES.ADD_INPUT_ENDPOINT,
          nodeCreatorView: AI_NODE_CREATOR_VIEW,
          outputType: getEndpointScope(endpoint.scope),
          endpointUuid: endpoint.uuid
        });
      }
    },
    bindCanvasEvents() {
      if (this.eventsAttached) return;
      this.instance.bind(EVENT_CONNECTION_ABORT, this.onEventConnectionAbort);
      this.instance.bind(INTERCEPT_BEFORE_DROP, this.onInterceptBeforeDrop);
      this.instance.bind(EVENT_CONNECTION, this.onEventConnection);
      this.instance.bind(EVENT_DRAG_MOVE, this.onDragMove);
      this.instance.bind(EVENT_CONNECTION_MOUSEOVER, this.onConnectionMouseOver);
      this.instance.bind(EVENT_CONNECTION_MOUSEOUT, this.onConnectionMouseOut);
      this.instance.bind(EVENT_CONNECTION_MOVED, this.onConnectionMoved);
      this.instance.bind(EVENT_ENDPOINT_MOUSEOVER, this.onEndpointMouseOver);
      this.instance.bind(EVENT_ENDPOINT_MOUSEOUT, this.onEndpointMouseOut);
      this.instance.bind(EVENT_CONNECTION_DETACHED, this.onConnectionDetached);
      this.instance.bind(EVENT_CONNECTION_DRAG, this.onConnectionDrag);
      this.instance.bind(
        [EVENT_CONNECTION_DRAG, EVENT_CONNECTION_ABORT, EVENT_CONNECTION_DETACHED],
        this.onConnectionDragAbortDetached
      );
      this.instance.bind(EVENT_PLUS_ENDPOINT_CLICK, this.onPlusEndpointClick);
      this.instance.bind(EVENT_ADD_INPUT_ENDPOINT_CLICK, this.onAddInputEndpointClick);
      this.eventsAttached = true;
    },
    unbindCanvasEvents() {
      this.instance.unbind(EVENT_CONNECTION_ABORT, this.onEventConnectionAbort);
      this.instance.unbind(INTERCEPT_BEFORE_DROP, this.onInterceptBeforeDrop);
      this.instance.unbind(EVENT_CONNECTION, this.onEventConnection);
      this.instance.unbind(EVENT_DRAG_MOVE, this.onDragMove);
      this.instance.unbind(EVENT_CONNECTION_MOUSEOVER, this.onConnectionMouseOver);
      this.instance.unbind(EVENT_CONNECTION_MOUSEOUT, this.onConnectionMouseOut);
      this.instance.unbind(EVENT_CONNECTION_MOVED, this.onConnectionMoved);
      this.instance.unbind(EVENT_ENDPOINT_MOUSEOVER, this.onEndpointMouseOver);
      this.instance.unbind(EVENT_ENDPOINT_MOUSEOUT, this.onEndpointMouseOut);
      this.instance.unbind(EVENT_CONNECTION_DETACHED, this.onConnectionDetached);
      this.instance.unbind(EVENT_CONNECTION_DRAG, this.onConnectionDrag);
      this.instance.unbind(EVENT_CONNECTION_DRAG, this.onConnectionDragAbortDetached);
      this.instance.unbind(EVENT_CONNECTION_ABORT, this.onConnectionDragAbortDetached);
      this.instance.unbind(EVENT_CONNECTION_DETACHED, this.onConnectionDragAbortDetached);
      this.instance.unbind(EVENT_PLUS_ENDPOINT_CLICK, this.onPlusEndpointClick);
      this.instance.unbind(EVENT_ADD_INPUT_ENDPOINT_CLICK, this.onAddInputEndpointClick);
      this.eventsAttached = false;
    },
    unbindEndpointEventListeners() {
      if (this.instance) {
        const elements = this.instance.getManagedElements();
        for (const element of Object.values(elements)) {
          const endpoints = element.endpoints;
          for (const endpoint of endpoints || []) {
            const endpointInstance = endpoint?.endpoint;
            if (endpointInstance && endpointInstance.type === N8nPlusEndpointType) {
              endpointInstance.unbindEvents();
            }
          }
        }
      }
      this.eventsAttached = false;
    },
    makeNewWorkflowShareable() {
      const { currentProject, personalProject } = this.projectsStore;
      const homeProject = currentProject ?? personalProject ?? {};
      const scopes = currentProject?.scopes ?? personalProject?.scopes ?? [];
      this.workflowsStore.workflow.homeProject = homeProject;
      this.workflowsStore.workflow.scopes = scopes;
    },
    async newWorkflow() {
      const { getVariant } = usePostHog();
      this.canvasStore.startLoading();
      this.resetWorkspace();
      this.workflowData = await this.workflowsStore.getNewWorkflowData(
        void 0,
        this.projectsStore.currentProjectId
      );
      this.workflowsStore.currentWorkflowExecutions = [];
      this.executionsStore.activeExecution = null;
      this.uiStore.stateIsDirty = false;
      this.canvasStore.setZoomLevel(1, [0, 0]);
      this.canvasStore.zoomToFit();
      this.uiStore.nodeViewInitialized = true;
      this.historyStore.reset();
      this.executionsStore.activeExecution = null;
      this.makeNewWorkflowShareable();
      this.canvasStore.stopLoading();
      if (getVariant(CANVAS_AUTO_ADD_MANUAL_TRIGGER_EXPERIMENT.name) === CANVAS_AUTO_ADD_MANUAL_TRIGGER_EXPERIMENT.variant) {
        const manualTriggerNode = this.canvasStore.getAutoAddManualTriggerNode();
        if (manualTriggerNode) {
          await this.nodeHelpers.addNodes([manualTriggerNode]);
          this.uiStore.lastSelectedNode = manualTriggerNode.name;
        }
      }
    },
    async initView() {
      await this.loadCredentialsForWorkflow();
      if (this.$route.query.action === "workflowSave") {
        this.uiStore.stateIsDirty = false;
        await this.$router.replace({
          query: { ...this.$route.query, action: void 0 }
        });
        return;
      }
      if (this.blankRedirect) {
        this.blankRedirect = false;
      } else if (this.$route.name === VIEWS.TEMPLATE_IMPORT) {
        const templateId = this.$route.params.id;
        const loadWorkflowFromJSON = this.$route.query.fromJson === "true";
        if (loadWorkflowFromJSON) {
          const isAiCreditsExperimentEnabled = this.posthogStore.getVariant(AI_CREDITS_EXPERIMENT.name) === AI_CREDITS_EXPERIMENT.variant;
          const easyAiWorkflowJson = getEasyAiWorkflowJson({
            isInstanceInAiFreeCreditsExperiment: isAiCreditsExperimentEnabled,
            withOpenAiFreeCredits: useSettingsStore().aiCreditsQuota
          });
          await this.openWorkflowTemplateFromJson({ workflow: easyAiWorkflowJson });
        } else {
          await this.openWorkflowTemplate(templateId.toString());
        }
      } else {
        if (this.uiStore.stateIsDirty && !this.readOnlyEnv && !this.isReadOnlyRoute && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
          const confirmModal = await this.confirm(
            this.i18n.baseText("generic.unsavedWork.confirmMessage.message"),
            {
              title: this.i18n.baseText("generic.unsavedWork.confirmMessage.headline"),
              type: "warning",
              confirmButtonText: this.i18n.baseText(
                "generic.unsavedWork.confirmMessage.confirmButtonText"
              ),
              cancelButtonText: this.i18n.baseText(
                "generic.unsavedWork.confirmMessage.cancelButtonText"
              ),
              showClose: true
            }
          );
          if (confirmModal === MODAL_CONFIRM) {
            const saved = await this.workflowHelpers.saveCurrentWorkflow();
            if (saved) await this.npsSurveyStore.fetchPromptsData();
          } else if (confirmModal === MODAL_CANCEL) {
            return;
          }
        }
        let workflowId = null;
        if (this.$route.params.name) {
          workflowId = this.$route.params.name.toString();
        }
        if (workflowId !== null) {
          let workflow = void 0;
          try {
            workflow = await this.workflowsStore.fetchWorkflow(workflowId);
          } catch (error) {
            this.showError(error, this.i18n.baseText("openWorkflow.workflowNotFoundError"));
            void this.$router.push({
              name: VIEWS.NEW_WORKFLOW
            });
          }
          if (workflow) {
            this.workflowHelpers.setDocumentTitle(workflow.name, "IDLE");
            await this.openWorkflow(workflow);
            await this.checkAndInitDebugMode();
            await this.projectsStore.setProjectNavActiveIdByWorkflowHomeProject(
              workflow.homeProject
            );
            if (workflow.meta?.onboardingId) {
              this.$telemetry.track(
                `User opened workflow from onboarding template with ID ${workflow.meta.onboardingId}`,
                {
                  workflow_id: workflow.id
                },
                {
                  withPostHog: true
                }
              );
            }
          }
        } else if (this.$route.meta?.nodeView === true) {
          await this.newWorkflow();
        }
      }
      this.historyStore.reset();
      if (!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
        this.canvasStore.setReadOnly(true);
      }
      this.uiStore.nodeViewInitialized = true;
      document.addEventListener("keydown", this.keyDown);
      document.addEventListener("keyup", this.keyUp);
      this.showNotificationForViews([VIEWS.WORKFLOW, VIEWS.NEW_WORKFLOW]);
    },
    async duplicateNodes(nodes) {
      if (!this.editAllowedCheck()) {
        return;
      }
      const workflowData = deepCopy(await this.getNodesToSave(nodes));
      await this.importWorkflowData(workflowData, "duplicate", false);
    },
    getIncomingOutgoingConnections(nodeName) {
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        const nodeEl = document.getElementById(node2.id);
        if (!nodeEl) {
          return { incoming: [], outgoing: [] };
        }
        const outgoing = this.instance?.getConnections({
          source: nodeEl
        });
        const incoming = this.instance?.getConnections({
          target: nodeEl
        });
        return {
          incoming: Array.isArray(incoming) ? incoming : Object.values(incoming),
          outgoing: Array.isArray(outgoing) ? outgoing : Object.values(outgoing)
        };
      }
      return { incoming: [], outgoing: [] };
    },
    onNodeMoved(node2) {
      const { incoming, outgoing } = this.getIncomingOutgoingConnections(node2.name);
      [...incoming, ...outgoing].forEach((connection) => {
        showOrHideMidpointArrow(connection);
        showOrHideItemsLabel(connection);
      });
    },
    onNodeRun({
      name,
      data,
      waiting
    }) {
      const pinData = this.workflowsStore.pinnedWorkflowData;
      if (pinData?.[name]) {
        const { outgoing } = this.getIncomingOutgoingConnections(name);
        outgoing.forEach((connection) => {
          if (connection.__meta?.sourceNodeName === name) {
            const hasRun = this.workflowsStore.getWorkflowResultDataByNodeName(name) !== null;
            addClassesToOverlays({
              connection,
              overlayIds: [OVERLAY_RUN_ITEMS_ID],
              classNames: hasRun ? ["has-run"] : [],
              includeConnector: true
            });
          }
        });
        return;
      }
      const sourceNodeName = name;
      const sourceNode = this.workflowsStore.getNodeByName(sourceNodeName);
      const sourceId = sourceNode !== null ? sourceNode.id : "";
      if (data === null || data.length === 0 || waiting) {
        const sourceElement = document.getElementById(sourceId);
        if (!sourceElement) {
          return;
        }
        const outgoing = this.instance?.getConnections({
          source: sourceElement
        });
        (Array.isArray(outgoing) ? outgoing : Object.values(outgoing)).forEach(
          (connection) => {
            resetConnection(connection);
          }
        );
        const endpoints = getJSPlumbEndpoints(sourceNode, this.instance);
        endpoints.forEach((endpoint) => {
          if (endpoint.endpoint.type === "N8nPlus") {
            endpoint.endpoint.clearSuccessOutput();
          }
        });
        return;
      }
      this.nodeHelpers.setSuccessOutput(data, sourceNode);
    },
    removeNode(nodeName, trackHistory = false, trackBulk = true) {
      if (!this.editAllowedCheck()) {
        return;
      }
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (!node2) {
        return;
      }
      if (trackHistory && trackBulk) {
        this.historyStore.startRecordingUndo();
      }
      const requiredNodeTypes = [];
      if (requiredNodeTypes.includes(node2.type)) {
        let deleteAllowed = false;
        for (const checkNode of this.nodes) {
          if (checkNode.name === node2.name) {
            continue;
          }
          if (requiredNodeTypes.includes(checkNode.type)) {
            deleteAllowed = true;
            break;
          }
        }
        if (!deleteAllowed) {
          return;
        }
      }
      if (node2.type === STICKY_NODE_TYPE) {
        this.$telemetry.track("User deleted workflow note", {
          workflow_id: this.workflowsStore.workflowId
        });
      } else {
        void this.externalHooks.run("node.deleteNode", { node: node2 });
        this.$telemetry.track("User deleted node", {
          node_type: node2.type,
          workflow_id: this.workflowsStore.workflowId
        });
      }
      let waitForNewConnection = false;
      const nodeType = this.nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const workflowNode = workflow.getNode(node2.name);
      let inputs = [];
      let outputs2 = [];
      if (nodeType && workflowNode) {
        inputs = getNodeInputs(workflow, workflowNode, nodeType);
        outputs2 = getNodeOutputs(workflow, workflowNode, nodeType);
      }
      if (outputs2.length === 1 && inputs.length === 1) {
        const { incoming, outgoing } = this.getIncomingOutgoingConnections(node2.name);
        if (incoming.length === 1 && outgoing.length === 1) {
          const conn1 = incoming[0];
          const conn2 = outgoing[0];
          if (conn1.__meta && conn2.__meta) {
            waitForNewConnection = true;
            const sourceNodeName = conn1.__meta.sourceNodeName;
            const sourceNodeOutputIndex = conn1.__meta.sourceOutputIndex;
            const targetNodeName = conn2.__meta.targetNodeName;
            const targetNodeOuputIndex = conn2.__meta.targetOutputIndex;
            setTimeout(() => {
              this.connectTwoNodes(
                sourceNodeName,
                sourceNodeOutputIndex,
                targetNodeName,
                targetNodeOuputIndex,
                NodeConnectionType.Main
              );
              if (waitForNewConnection) {
                this.instance?.setSuspendDrawing(false, true);
                waitForNewConnection = false;
              }
            }, 100);
          }
        }
      }
      void nextTick(() => {
        this.instance?.setSuspendDrawing(true);
        (this.instance?.endpointsByElement[node2.id] || []).flat().forEach((endpoint) => this.instance?.deleteEndpoint(endpoint));
        this.workflowsStore.removeAllNodeConnection(node2);
        this.workflowsStore.removeNode(node2);
        this.workflowsStore.clearNodeExecutionData(node2.name);
        if (!waitForNewConnection) {
          this.instance?.setSuspendDrawing(false, true);
        }
        this.uiStore.removeNodeFromSelection(node2);
        if (trackHistory) {
          this.historyStore.pushCommandToUndo(new RemoveNodeCommand(node2));
        }
      });
      if (trackHistory && trackBulk) {
        const recordingTimeout = waitForNewConnection ? 100 : 0;
        setTimeout(() => {
          this.historyStore.stopRecordingUndo();
        }, recordingTimeout);
      }
    },
    async onSwitchSelectedNode(nodeName) {
      this.nodeSelectedByName(nodeName, true, true);
    },
    async onOpenConnectionNodeCreator(node2, connectionType2) {
      await this.openSelectiveNodeCreator({
        connectiontype: connectionType2,
        node: node2
      });
    },
    async redrawNode(nodeName) {
      const tempName = "x____XXXX____x";
      await this.renameNode(nodeName, tempName);
      await this.renameNode(tempName, nodeName);
    },
    valueChanged(parameterData) {
      if (parameterData.name === "name" && parameterData.oldValue) {
        void this.renameNode(parameterData.oldValue, parameterData.value);
      }
    },
    async renameNodePrompt(currentName) {
      try {
        const promptResponsePromise = this.prompt(
          this.i18n.baseText("nodeView.prompt.newName") + ":",
          this.i18n.baseText("nodeView.prompt.renameNode") + `: ${currentName}`,
          {
            customClass: "rename-prompt",
            confirmButtonText: this.i18n.baseText("nodeView.prompt.rename"),
            cancelButtonText: this.i18n.baseText("nodeView.prompt.cancel"),
            inputErrorMessage: this.i18n.baseText("nodeView.prompt.invalidName"),
            inputValue: currentName,
            inputValidator: (value) => {
              if (!value.trim()) {
                return this.i18n.baseText("nodeView.prompt.invalidName");
              }
              return true;
            }
          }
        );
        await this.$nextTick();
        const nameInput = document.querySelector(".rename-prompt .el-input__inner");
        if (nameInput) {
          nameInput.focus();
          nameInput.select();
        }
        const promptResponse = await promptResponsePromise;
        if (promptResponse?.action !== MODAL_CONFIRM) {
          return;
        }
        await this.renameNode(currentName, promptResponse.value, true);
      } catch (e) {
      }
    },
    async renameNode(currentName, newName, trackHistory = false) {
      if (currentName === newName) {
        return;
      }
      this.suspendRecordingDetachedConnections = true;
      if (trackHistory) {
        this.historyStore.startRecordingUndo();
      }
      const activeNodeName = this.activeNode?.name;
      const isActive = activeNodeName === currentName;
      if (isActive) {
        this.renamingActive = true;
      }
      newName = this.uniqueNodeName(newName);
      const workflow = this.workflowHelpers.getCurrentWorkflow(true);
      workflow.renameNode(currentName, newName);
      if (trackHistory) {
        this.historyStore.pushCommandToUndo(new RenameNodeCommand(currentName, newName));
      }
      this.workflowsStore.renameNodeSelectedAndExecution({ old: currentName, new: newName });
      this.deleteEveryEndpoint();
      this.workflowsStore.removeAllConnections({ setStateDirty: false });
      this.workflowsStore.removeAllNodes({ removePinData: false, setStateDirty: true });
      await this.$nextTick();
      await this.nodeHelpers.addNodes(
        Object.values(workflow.nodes),
        workflow.connectionsBySourceNode,
        false
      );
      this.deselectAllNodes();
      this.nodeSelectedByName(newName);
      if (isActive) {
        this.ndvStore.activeNodeName = newName;
        this.renamingActive = false;
      }
      if (trackHistory) {
        this.historyStore.stopRecordingUndo();
      }
      this.suspendRecordingDetachedConnections = false;
    },
    deleteEveryEndpoint() {
      if (this.instance) {
        this.instance?.reset();
        Object.values(this.instance?.endpointsByElement).flatMap((endpoint) => endpoint).forEach((endpoint) => endpoint.destroy());
        this.instance.deleteEveryConnection({ fireEvent: true });
      }
    },
    async addNodesToWorkflow(data) {
      const nodeNameTable = {};
      const newNodeNames = [];
      if (!data.nodes) {
        throw new Error(this.i18n.baseText("nodeView.noNodesGivenToAdd"));
      }
      const nodeTypesCount = this.workflowHelpers.getNodeTypesMaxCount();
      let oldName;
      let newName;
      const createNodes = [];
      await this.nodeHelpers.loadNodesProperties(
        data.nodes.map((node2) => ({ name: node2.type, version: node2.typeVersion }))
      );
      data.nodes.forEach((node2) => {
        if (nodeTypesCount[node2.type] !== void 0) {
          if (nodeTypesCount[node2.type].exist >= nodeTypesCount[node2.type].max) {
            nodeNameTable[node2.name] = nodeTypesCount[node2.type].nodeNames[0];
            return;
          } else {
            nodeTypesCount[node2.type].exist += 1;
          }
        }
        oldName = node2.name;
        const localized = this.i18n.localizeNodeName(node2.name, node2.type);
        newName = this.uniqueNodeName(localized, newNodeNames);
        newNodeNames.push(newName);
        nodeNameTable[oldName] = newName;
        createNodes.push(node2);
      });
      const newConnections = {};
      const currentConnections = data.connections;
      const createNodeNames = createNodes.map((node2) => node2.name);
      let sourceNode, type, sourceIndex, connectionIndex, connectionData;
      for (sourceNode of Object.keys(currentConnections)) {
        if (!createNodeNames.includes(sourceNode)) {
          continue;
        }
        const connection = {};
        for (type of Object.keys(currentConnections[sourceNode])) {
          connection[type] = [];
          for (sourceIndex = 0; sourceIndex < currentConnections[sourceNode][type].length; sourceIndex++) {
            const nodeSourceConnections = [];
            const connections2 = currentConnections[sourceNode][type][sourceIndex];
            if (connections2) {
              for (connectionIndex = 0; connectionIndex < connections2.length; connectionIndex++) {
                connectionData = connections2[connectionIndex];
                if (!createNodeNames.includes(connectionData.node)) {
                  continue;
                }
                nodeSourceConnections.push(connectionData);
              }
            }
            connection[type].push(nodeSourceConnections);
          }
        }
        newConnections[sourceNode] = connection;
      }
      const tempWorkflow = this.workflowHelpers.getWorkflow(createNodes, newConnections);
      for (oldName in nodeNameTable) {
        if (oldName === nodeNameTable[oldName]) {
          continue;
        }
        tempWorkflow.renameNode(oldName, nodeNameTable[oldName]);
      }
      if (data.pinData) {
        let pinDataSuccess = true;
        for (const nodeName of Object.keys(data.pinData)) {
          if (!pinDataSuccess) {
            this.showError(
              new Error(this.i18n.baseText("ndv.pinData.error.tooLarge.description")),
              this.i18n.baseText("ndv.pinData.error.tooLarge.title")
            );
            continue;
          }
          const node2 = tempWorkflow.nodes[nodeNameTable[nodeName]];
          try {
            const pinnedDataForNode = usePinnedData(node2);
            pinnedDataForNode.setData(data.pinData[nodeName], "add-nodes");
            pinDataSuccess = true;
          } catch (error) {
            pinDataSuccess = false;
            console.error(error);
          }
        }
      }
      this.historyStore.startRecordingUndo();
      await this.nodeHelpers.addNodes(
        Object.values(tempWorkflow.nodes),
        tempWorkflow.connectionsBySourceNode,
        true
      );
      this.historyStore.stopRecordingUndo();
      this.uiStore.stateIsDirty = true;
      return {
        nodes: Object.values(tempWorkflow.nodes),
        connections: tempWorkflow.connectionsBySourceNode
      };
    },
    async getNodesToSave(nodes) {
      const data = {
        nodes: [],
        connections: {},
        pinData: {}
      };
      let nodeData;
      const exportNodeNames = [];
      for (const node2 of nodes) {
        nodeData = this.workflowHelpers.getNodeDataToSave(node2);
        exportNodeNames.push(node2.name);
        data.nodes.push(nodeData);
        const pinDataForNode = this.workflowsStore.pinDataByNodeName(node2.name);
        if (pinDataForNode) {
          data.pinData[node2.name] = pinDataForNode;
        }
        if (nodeData.credentials && this.settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Sharing]) {
          const usedCredentials = this.workflowsStore.usedCredentials;
          nodeData.credentials = Object.fromEntries(
            Object.entries(nodeData.credentials).filter(([_, credential]) => {
              return credential.id && (!usedCredentials[credential.id] || usedCredentials[credential.id]?.currentUserHasAccess);
            })
          );
        }
      }
      let connectionToKeep, connections2, type, connectionIndex, sourceIndex, connectionData, typeConnections;
      data.nodes.forEach((node2) => {
        connections2 = this.workflowsStore.outgoingConnectionsByNodeName(node2.name);
        if (Object.keys(connections2).length === 0) {
          return;
        }
        typeConnections = {};
        for (type of Object.keys(connections2)) {
          for (sourceIndex = 0; sourceIndex < connections2[type].length; sourceIndex++) {
            connectionToKeep = [];
            const connectionsToCheck = connections2[type][sourceIndex];
            if (connectionsToCheck) {
              for (connectionIndex = 0; connectionIndex < connectionsToCheck.length; connectionIndex++) {
                connectionData = connectionsToCheck[connectionIndex];
                if (exportNodeNames.indexOf(connectionData.node) !== -1) {
                  connectionToKeep.push(connectionData);
                }
              }
            }
            if (connectionToKeep.length) {
              if (!typeConnections.hasOwnProperty(type)) {
                typeConnections[type] = [];
              }
              typeConnections[type][sourceIndex] = connectionToKeep;
            }
          }
        }
        if (Object.keys(typeConnections).length) {
          data.connections[node2.name] = typeConnections;
        }
      });
      return data;
    },
    resetWorkspace() {
      this.workflowsStore.resetWorkflow();
      this.onToggleNodeCreator({ createNodeActive: false });
      this.nodeCreatorStore.setShowScrim(false);
      this.canvasStore.resetZoom();
      this.unbindEndpointEventListeners();
      this.deleteEveryEndpoint();
      if (this.executionWaitingForWebhook) {
        try {
          void this.workflowsStore.removeTestWebhook(this.workflowsStore.workflowId);
        } catch (error) {
        }
      }
      this.workflowsStore.resetState();
      this.uiStore.removeActiveAction("workflowRunning");
      this.uiStore.resetSelectedNodes();
      this.uiStore.nodeViewOffsetPosition = [0, 0];
      this.nodeHelpers.credentialsUpdated.value = false;
    },
    async loadActiveWorkflows() {
      await this.workflowsStore.fetchActiveWorkflows();
    },
    async loadNodeTypes() {
      await this.nodeTypesStore.getNodeTypes();
    },
    async loadCredentialTypes() {
      await this.credentialsStore.fetchCredentialTypes(true);
    },
    async loadCredentialsForWorkflow() {
      if (this.settingsStore.isPreviewMode) {
        return;
      }
      const workflow = this.workflowsStore.getWorkflowById(this.currentWorkflow);
      const workflowId = workflow?.id ?? this.$route.params.name;
      let options;
      if (workflowId) {
        options = { workflowId };
      } else {
        const queryParam = typeof this.$route.query?.projectId === "string" ? this.$route.query?.projectId : void 0;
        const projectId = queryParam ?? this.projectsStore.personalProject?.id;
        if (projectId === void 0) {
          throw new Error(
            "Could not find projectId in the query nor could I find the personal project in the project store"
          );
        }
        options = { projectId };
      }
      await this.credentialsStore.fetchAllCredentialsForWorkflow(options);
    },
    async loadVariables() {
      await this.environmentsStore.fetchAllVariables();
    },
    async loadSecrets() {
      await this.externalSecretsStore.fetchAllSecrets();
    },
    async onPostMessageReceived(message) {
      if (!message || typeof message.data !== "string" || !message.data?.includes?.('"command"')) {
        return;
      }
      try {
        const json = JSON.parse(message.data);
        if (json && json.command === "openWorkflow") {
          try {
            await this.importWorkflowExact(json);
            this.canOpenNDV = json.canOpenNDV ?? true;
            this.hideNodeIssues = json.hideNodeIssues ?? false;
            this.isExecutionPreview = false;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: this.i18n.baseText("openWorkflow.workflowImportError")
                }),
                "*"
              );
            }
            this.showMessage({
              title: this.i18n.baseText("openWorkflow.workflowImportError"),
              message: e.message,
              type: "error"
            });
          }
        } else if (json && json.command === "openExecution") {
          try {
            this.nodeHelpers.isProductionExecutionPreview.value = json.executionMode !== "manual";
            await this.openExecution(json.executionId);
            this.canOpenNDV = json.canOpenNDV ?? true;
            this.hideNodeIssues = json.hideNodeIssues ?? false;
            this.isExecutionPreview = true;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: this.i18n.baseText("nodeView.showError.openExecution.title")
                }),
                "*"
              );
            }
            this.showMessage({
              title: this.i18n.baseText("nodeView.showError.openExecution.title"),
              message: e.message,
              type: "error"
            });
          }
        } else if (json?.command === "setActiveExecution") {
          this.executionsStore.activeExecution = await this.executionsStore.fetchExecution(
            json.executionId
          );
        }
      } catch (e) {
      }
    },
    async onImportWorkflowDataEvent(data) {
      await this.importWorkflowData(data.data, "file");
    },
    async onImportWorkflowUrlEvent(data) {
      const workflowData = await this.getWorkflowDataFromUrl(data.url);
      if (workflowData !== void 0) {
        await this.importWorkflowData(workflowData, "url");
      }
    },
    onToggleNodeCreator({ source, createNodeActive, nodeCreatorView }) {
      if (createNodeActive === this.createNodeActive) return;
      if (!nodeCreatorView) {
        nodeCreatorView = this.containsTrigger ? REGULAR_NODE_CREATOR_VIEW : TRIGGER_NODE_CREATOR_VIEW;
      }
      this.nodeCreatorStore.setSelectedView(nodeCreatorView);
      this.createNodeActive = createNodeActive;
      let mode;
      switch (this.nodeCreatorStore.selectedView) {
        case AI_NODE_CREATOR_VIEW:
          mode = "ai";
          break;
        case REGULAR_NODE_CREATOR_VIEW:
          mode = "regular";
          break;
        default:
          mode = "regular";
      }
      if (createNodeActive && source) this.nodeCreatorStore.setOpenSource(source);
      void this.externalHooks.run("nodeView.createNodeActiveChanged", {
        source,
        mode,
        createNodeActive
      });
      if (createNodeActive) {
        this.nodeCreatorStore.onCreatorOpened({
          source,
          mode,
          workflow_id: this.workflowsStore.workflowId
        });
      }
    },
    async onAddNodes({ nodes, connections: connections2 }, dragAndDrop = false, position) {
      let currentPosition = position;
      for (const { type, isAutoAdd, name, openDetail, position: nodePosition } of nodes) {
        await this.addNode(
          type,
          { position: nodePosition ?? currentPosition, dragAndDrop, name },
          openDetail ?? false,
          true,
          isAutoAdd
        );
        const lastAddedNode2 = this.nodes[this.nodes.length - 1];
        currentPosition = [
          lastAddedNode2.position[0] + NODE_SIZE * 2 + GRID_SIZE,
          lastAddedNode2.position[1]
        ];
      }
      const newNodesOffset = this.nodes.length - nodes.length;
      for (const { from, to } of connections2) {
        const fromNode = this.nodes[newNodesOffset + from.nodeIndex];
        const toNode = this.nodes[newNodesOffset + to.nodeIndex];
        this.connectTwoNodes(
          fromNode.name,
          from.outputIndex ?? 0,
          toNode.name,
          to.inputIndex ?? 0,
          from.type ?? NodeConnectionType.Main
        );
      }
      const lastAddedNode = this.nodes[this.nodes.length - 1];
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const lastNodeInputs = workflow.getParentNodesByDepth(lastAddedNode.name, 1);
      if (lastNodeInputs.length > 1) {
        lastNodeInputs.slice(1).forEach((node2, index) => {
          const nodeUi = this.workflowsStore.getNodeByName(node2.name);
          if (!nodeUi) return;
          this.onMoveNode({
            nodeName: nodeUi.name,
            position: [nodeUi.position[0], nodeUi.position[1] + 100 * (index + 1)]
          });
        });
      }
      const lastNodeType = this.nodeTypesStore.getNodeType(lastAddedNode.type);
      const isSubNode = isSubNodeType(lastNodeType);
      if (isSubNode && nodes.length > 1) {
        this.onMoveNode({
          nodeName: lastAddedNode.name,
          position: [
            lastAddedNode.position[0] - NODE_SIZE * 2.5,
            lastAddedNode.position[1] + NODE_SIZE * 1.5
          ]
        });
      }
      this.nodeHelpers.addPinDataConnections(this.workflowsStore.pinnedWorkflowData);
    },
    async saveCurrentWorkflowExternal(callback) {
      await this.workflowHelpers.saveCurrentWorkflow();
      callback?.();
    },
    setSuspendRecordingDetachedConnections(suspend) {
      this.suspendRecordingDetachedConnections = suspend;
    },
    onMoveNode({ nodeName, position }) {
      this.workflowsStore.updateNodeProperties({ name: nodeName, properties: { position } });
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      setTimeout(() => {
        if (node2) {
          this.instance?.repaintEverything();
          this.onNodeMoved(node2);
        }
      }, 0);
    },
    onRevertAddNode({ node: node2 }) {
      this.removeNode(node2.name, false);
    },
    async onRevertRemoveNode({ node: node2 }) {
      const prevNode = this.workflowsStore.workflow.nodes.find((n) => n.id === node2.id);
      if (prevNode) {
        return;
      }
      node2.id = v4();
      await this.nodeHelpers.addNodes([node2]);
    },
    onRevertAddConnection({ connection }) {
      this.suspendRecordingDetachedConnections = true;
      this.nodeHelpers.removeConnection(connection, true);
      this.suspendRecordingDetachedConnections = false;
    },
    async onRevertRemoveConnection({ connection }) {
      this.suspendRecordingDetachedConnections = true;
      this.nodeHelpers.addConnection(connection);
      this.suspendRecordingDetachedConnections = false;
    },
    async onRevertNameChange({ currentName, newName }) {
      await this.renameNode(newName, currentName);
    },
    onRevertEnableToggle({ nodeName }) {
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        this.nodeHelpers.disableNodes([node2]);
      }
    },
    onPageShow(e) {
      if (e.persisted) {
        this.canvasStore.stopLoading();
      }
    },
    async readOnlyEnvRouteCheck() {
      if ((this.readOnlyEnv || !this.projectPermissions.workflow.create) && (this.$route.name === VIEWS.NEW_WORKFLOW || this.$route.name === VIEWS.TEMPLATE_IMPORT)) {
        await this.$nextTick();
        this.resetWorkspace();
        this.uiStore.stateIsDirty = false;
        await this.$router.replace({ name: VIEWS.HOMEPAGE });
      }
    },
    async checkAndInitDebugMode() {
      if (this.$route.name === VIEWS.EXECUTION_DEBUG) {
        this.workflowHelpers.setDocumentTitle(this.workflowName, "DEBUG");
        if (!this.workflowsStore.isInDebugMode) {
          await this.applyExecutionData(this.$route.params.executionId);
          this.workflowsStore.isInDebugMode = true;
        }
      }
    },
    onContextMenu(event) {
      this.contextMenu.open(event, {
        source: "canvas",
        nodeIds: this.uiStore.selectedNodes.map((node2) => node2.id)
      });
    },
    onContextMenuAction(action2, nodeIds) {
      const nodes = nodeIds.map((nodeId) => this.workflowsStore.getNodeById(nodeId)).filter(isPresent);
      switch (action2) {
        case "copy":
          this.copyNodes(nodes);
          break;
        case "delete":
          this.deleteNodes(nodes);
          break;
        case "duplicate":
          void this.duplicateNodes(nodes);
          break;
        case "execute":
          this.onRunNode(nodes[0].name, "NodeView.onContextMenuAction");
          break;
        case "open":
          this.ndvStore.activeNodeName = nodes[0].name;
          break;
        case "rename":
          void this.renameNodePrompt(nodes[0].name);
          break;
        case "toggle_activation":
          this.toggleActivationNodes(nodes);
          break;
        case "toggle_pin":
          this.togglePinNodes(nodes, "context-menu");
          break;
        case "add_node":
          this.onToggleNodeCreator({
            source: NODE_CREATOR_OPEN_SOURCES.CONTEXT_MENU,
            createNodeActive: !this.isReadOnlyRoute && !this.readOnlyEnv && !!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
          });
          break;
        case "add_sticky":
          void this.onAddNodes({ nodes: [{ type: STICKY_NODE_TYPE }], connections: [] });
          break;
        case "select_all":
          this.selectAllNodes();
          break;
        case "deselect_all":
          this.deselectAllNodes();
          break;
      }
    },
    async onSourceControlPull() {
      let workflowId = null;
      if (this.$route.params.name) {
        workflowId = this.$route.params.name.toString();
      }
      try {
        if (workflowId !== null && !this.uiStore.stateIsDirty) {
          const workflow = await this.workflowsStore.fetchWorkflow(workflowId);
          if (workflow) {
            this.workflowHelpers.setDocumentTitle(workflow.name, "IDLE");
            await this.openWorkflow(workflow);
          }
        }
        await Promise.all([
          this.loadVariables(),
          this.tagsStore.fetchAll(),
          this.loadCredentialsForWorkflow()
        ]);
      } catch (error) {
        console.error(error);
      }
    }
  }
});
const content = "_content_w3wnr_123";
const shake = "_shake_w3wnr_131";
const setupCredentialsButtonWrapper$1 = "_setupCredentialsButtonWrapper_w3wnr_149";
const style2 = {
  content,
  shake,
  setupCredentialsButtonWrapper: setupCredentialsButtonWrapper$1
};
const _hoisted_1 = ["textContent"];
const _hoisted_2 = {
  key: 0,
  class: "workflow-execute-wrapper"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CanvasAddButton = resolveComponent("CanvasAddButton");
  const _component_Node = __unplugin_components_0;
  const _component_Sticky = __unplugin_components_1;
  const _component_NodeDetailsView = __unplugin_components_2;
  const _component_LazySetupWorkflowCredentialsButton = resolveComponent("LazySetupWorkflowCredentialsButton");
  const _component_LazyNodeCreation = resolveComponent("LazyNodeCreation");
  const _component_LazyCanvasControls = resolveComponent("LazyCanvasControls");
  const _component_ContextMenu = ContextMenu;
  const _component_n8n_button = resolveComponent("n8n-button");
  const _component_KeyboardShortcutTooltip = KeyboardShortcutTooltip;
  const _component_n8n_icon_button = resolveComponent("n8n-icon-button");
  const _directive_touch = resolveDirective("touch");
  return openBlock(), createElementBlock("div", {
    ref: "nodeViewRootRef",
    class: normalizeClass(_ctx.$style["content"])
  }, [
    createBaseVNode("div", {
      id: "node-view-root",
      class: "node-view-root do-not-select",
      "data-test-id": "node-view-root",
      onDragover: _cache[13] || (_cache[13] = (...args) => _ctx.onDragOver && _ctx.onDragOver(...args)),
      onDrop: _cache[14] || (_cache[14] = (...args) => _ctx.onDrop && _ctx.onDrop(...args))
    }, [
      withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass(["node-view-wrapper", _ctx.workflowClasses]),
        "data-test-id": "node-view-wrapper",
        onTouchstart: _cache[3] || (_cache[3] = (...args) => _ctx.mouseDown && _ctx.mouseDown(...args)),
        onTouchend: _cache[4] || (_cache[4] = (...args) => _ctx.mouseUp && _ctx.mouseUp(...args)),
        onTouchmove: _cache[5] || (_cache[5] = (...args) => _ctx.canvasPanning.onMouseMove && _ctx.canvasPanning.onMouseMove(...args)),
        onMousedown: _cache[6] || (_cache[6] = (...args) => _ctx.mouseDown && _ctx.mouseDown(...args)),
        onMouseup: _cache[7] || (_cache[7] = (...args) => _ctx.mouseUp && _ctx.mouseUp(...args)),
        onContextmenu: _cache[8] || (_cache[8] = (...args) => _ctx.onContextMenu && _ctx.onContextMenu(...args)),
        onWheel: _cache[9] || (_cache[9] = (...args) => _ctx.canvasStore.wheelScroll && _ctx.canvasStore.wheelScroll(...args))
      }, [
        createBaseVNode("div", {
          id: "node-view-background",
          class: "node-view-background",
          style: normalizeStyle(_ctx.backgroundStyle),
          "data-test-id": "node-view-background"
        }, null, 4),
        createBaseVNode("div", {
          id: "node-view",
          ref: "nodeViewRef",
          class: "node-view",
          style: normalizeStyle(_ctx.workflowStyle),
          "data-test-id": "node-view"
        }, [
          withDirectives(createVNode(_component_CanvasAddButton, {
            ref: "canvasAddButton",
            style: normalizeStyle(_ctx.canvasAddButtonStyle),
            "show-tooltip": !_ctx.containsTrigger && _ctx.showTriggerMissingTooltip,
            position: _ctx.canvasStore.canvasAddButtonPosition,
            "data-test-id": "canvas-add-button",
            onClick: _ctx.onCanvasAddButtonCLick,
            "onHook:mounted": _ctx.canvasStore.setRecenteredCanvasAddButtonPosition
          }, null, 8, ["style", "show-tooltip", "position", "onClick", "onHook:mounted"]), [
            [vShow, _ctx.showCanvasAddButton]
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodesToRender, (nodeData) => {
            return openBlock(), createBlock(_component_Node, {
              key: `${nodeData.id}_node`,
              name: nodeData.name,
              "is-read-only": _ctx.isReadOnlyRoute || _ctx.readOnlyEnv || !(_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update),
              instance: _ctx.instance,
              "is-active": !!_ctx.activeNode && _ctx.activeNode.name === nodeData.name,
              "hide-actions": _ctx.pullConnActive,
              "is-production-execution-preview": _ctx.isProductionExecutionPreview,
              workflow: _ctx.currentWorkflowObject,
              "disable-pointer-events": !_ctx.canOpenNDV,
              "hide-node-issues": _ctx.hideNodeIssues,
              onDeselectAllNodes: _ctx.deselectAllNodes,
              onDeselectNode: _ctx.nodeDeselectedByName,
              onNodeSelected: _ctx.nodeSelectedByName,
              onRunWorkflow: _ctx.onRunNode,
              onMoved: _ctx.onNodeMoved,
              onRun: _ctx.onNodeRun,
              onRemoveNode: _cache[0] || (_cache[0] = (name) => _ctx.removeNode(name, true)),
              onToggleDisableNode: _cache[1] || (_cache[1] = (node2) => _ctx.toggleActivationNodes([node2]))
            }, {
              "custom-tooltip": withCtx(() => [
                createBaseVNode("span", {
                  textContent: toDisplayString(_ctx.i18n.baseText("nodeView.canvasAddButton.addATriggerNodeBeforeExecuting"))
                }, null, 8, _hoisted_1)
              ]),
              _: 2
            }, 1032, ["name", "is-read-only", "instance", "is-active", "hide-actions", "is-production-execution-preview", "workflow", "disable-pointer-events", "hide-node-issues", "onDeselectAllNodes", "onDeselectNode", "onNodeSelected", "onRunWorkflow", "onMoved", "onRun"]);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.stickiesToRender, (stickyData) => {
            return openBlock(), createBlock(_component_Sticky, {
              key: `${stickyData.id}_sticky`,
              name: stickyData.name,
              workflow: _ctx.currentWorkflowObject,
              "is-read-only": _ctx.isReadOnlyRoute || _ctx.readOnlyEnv || !(_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update),
              instance: _ctx.instance,
              "is-active": !!_ctx.activeNode && _ctx.activeNode.name === stickyData.name,
              "node-view-scale": _ctx.nodeViewScale,
              "grid-size": _ctx.GRID_SIZE,
              "hide-actions": _ctx.pullConnActive,
              onDeselectAllNodes: _ctx.deselectAllNodes,
              onDeselectNode: _ctx.nodeDeselectedByName,
              onNodeSelected: _ctx.nodeSelectedByName,
              onRemoveNode: _cache[2] || (_cache[2] = (name) => _ctx.removeNode(name, true))
            }, null, 8, ["name", "workflow", "is-read-only", "instance", "is-active", "node-view-scale", "grid-size", "hide-actions", "onDeselectAllNodes", "onDeselectNode", "onNodeSelected"]);
          }), 128))
        ], 4)
      ], 34)), [
        [_directive_touch, _ctx.touchTap, "tap"]
      ]),
      createVNode(_component_NodeDetailsView, {
        "workflow-object": _ctx.currentWorkflowObject,
        "read-only": _ctx.isReadOnlyRoute || _ctx.readOnlyEnv || !(_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update),
        renaming: _ctx.renamingActive,
        "is-production-execution-preview": _ctx.isProductionExecutionPreview,
        onRedrawNode: _ctx.redrawNode,
        onSwitchSelectedNode: _ctx.onSwitchSelectedNode,
        onOpenConnectionNodeCreator: _ctx.onOpenConnectionNodeCreator,
        onValueChanged: _ctx.valueChanged,
        onStopExecution: _ctx.stopExecution,
        onSaveKeyboardShortcut: _ctx.onSaveKeyboardShortcut
      }, null, 8, ["workflow-object", "read-only", "renaming", "is-production-execution-preview", "onRedrawNode", "onSwitchSelectedNode", "onOpenConnectionNodeCreator", "onValueChanged", "onStopExecution", "onSaveKeyboardShortcut"]),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.setupCredentialsButtonWrapper)
          }, [
            createVNode(_component_LazySetupWorkflowCredentialsButton)
          ], 2)
        ]),
        _: 1
      })),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          !_ctx.isReadOnlyRoute && !_ctx.readOnlyEnv && (_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update) ? (openBlock(), createBlock(_component_LazyNodeCreation, {
            key: 0,
            "create-node-active": _ctx.createNodeActive,
            "node-view-scale": _ctx.nodeViewScale,
            onToggleNodeCreator: _ctx.onToggleNodeCreator,
            onAddNodes: _ctx.onAddNodes
          }, null, 8, ["create-node-active", "node-view-scale", "onToggleNodeCreator", "onAddNodes"])) : createCommentVNode("", true)
        ]),
        _: 1
      })),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          createVNode(_component_LazyCanvasControls)
        ]),
        _: 1
      })),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          createVNode(_component_ContextMenu, { onAction: _ctx.onContextMenuAction }, null, 8, ["onAction"])
        ]),
        _: 1
      })),
      !_ctx.isReadOnlyRoute && !_ctx.readOnlyEnv && (_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update) ? (openBlock(), createElementBlock("div", _hoisted_2, [
        !_ctx.isManualChatOnly ? (openBlock(), createElementBlock("span", {
          key: 0,
          onMouseenter: _cache[10] || (_cache[10] = ($event) => _ctx.showTriggerMissingToltip(true)),
          onMouseleave: _cache[11] || (_cache[11] = ($event) => _ctx.showTriggerMissingToltip(false)),
          onClick: _cache[12] || (_cache[12] = (...args) => _ctx.onRunContainerClick && _ctx.onRunContainerClick(...args))
        }, [
          createVNode(_component_KeyboardShortcutTooltip, {
            label: _ctx.runButtonText,
            shortcut: { metaKey: true, keys: ["↵"] }
          }, {
            default: withCtx(() => [
              createVNode(_component_n8n_button, {
                loading: _ctx.workflowRunning,
                label: _ctx.runButtonText,
                size: "large",
                icon: "flask",
                type: "primary",
                disabled: _ctx.isExecutionDisabled,
                "data-test-id": "execute-workflow-button",
                onClick: withModifiers(_ctx.onRunWorkflow, ["stop"])
              }, null, 8, ["loading", "label", "disabled", "onClick"])
            ]),
            _: 1
          }, 8, ["label"])
        ], 32)) : createCommentVNode("", true),
        _ctx.containsChatNodes ? (openBlock(), createBlock(_component_n8n_button, {
          key: 1,
          label: _ctx.isChatOpen ? _ctx.i18n.baseText("chat.hide") : _ctx.i18n.baseText("chat.window.title"),
          size: "large",
          icon: "comment",
          type: _ctx.isChatOpen ? "tertiary" : "primary",
          "data-test-id": "workflow-chat-button",
          onClick: withModifiers(_ctx.onOpenChat, ["stop"])
        }, null, 8, ["label", "type", "onClick"])) : createCommentVNode("", true),
        _ctx.workflowRunning === true && !_ctx.executionWaitingForWebhook ? (openBlock(), createBlock(_component_n8n_icon_button, {
          key: 2,
          icon: "stop",
          size: "large",
          class: "stop-execution",
          type: "secondary",
          title: _ctx.stopExecutionInProgress ? _ctx.i18n.baseText("nodeView.stoppingCurrentExecution") : _ctx.i18n.baseText("nodeView.stopCurrentExecution"),
          loading: _ctx.stopExecutionInProgress,
          "data-test-id": "stop-execution-button",
          onClick: withModifiers(_ctx.stopExecution, ["stop"])
        }, null, 8, ["title", "loading", "onClick"])) : createCommentVNode("", true),
        _ctx.workflowRunning === true && _ctx.executionWaitingForWebhook === true ? (openBlock(), createBlock(_component_n8n_icon_button, {
          key: 3,
          class: "stop-execution",
          icon: "stop",
          size: "large",
          title: _ctx.i18n.baseText("nodeView.stopWaitingForWebhookCall"),
          type: "secondary",
          "data-test-id": "stop-execution-waiting-for-webhook-button",
          onClick: withModifiers(_ctx.stopWaitingForWebhook, ["stop"])
        }, null, 8, ["title", "onClick"])) : createCommentVNode("", true),
        _ctx.workflowExecution && !_ctx.workflowRunning && !_ctx.allTriggersDisabled ? (openBlock(), createBlock(_component_n8n_icon_button, {
          key: 4,
          title: _ctx.i18n.baseText("nodeView.deletesTheCurrentExecutionData"),
          icon: "trash",
          size: "large",
          "data-test-id": "clear-execution-data-button",
          onClick: withModifiers(_ctx.clearExecutionData, ["stop"])
        }, null, 8, ["title", "onClick"])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ], 32)
  ], 2);
}
const cssModules$2 = {
  "$style": style2
};
const NodeViewV1 = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render], ["__cssModules", cssModules$2], ["__scopeId", "data-v-25434fb8"]]);
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "CanvasChatButton",
  props: {
    type: {},
    label: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_N8nButton = resolveComponent("N8nButton");
      return openBlock(), createBlock(_component_N8nButton, {
        label: _ctx.label,
        size: "large",
        icon: "comment",
        type: _ctx.type,
        "data-test-id": "workflow-chat-button"
      }, null, 8, ["label", "type"]);
    };
  }
});
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "WorkflowCanvas",
  props: {
    id: { default: "canvas" },
    workflow: {},
    workflowObject: {},
    fallbackNodes: { default: () => [] },
    showFallbackNodes: { type: Boolean, default: true },
    eventBus: { default: () => createEventBus() },
    readOnly: { type: Boolean },
    executing: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const $style = useCssModule();
    const { onNodesInitialized } = useVueFlow({ id: props.id });
    const workflow = toRef$1(props, "workflow");
    const workflowObject = toRef$1(props, "workflowObject");
    const nodes = computed(() => {
      return props.showFallbackNodes ? [...props.workflow.nodes, ...props.fallbackNodes] : props.workflow.nodes;
    });
    const connections2 = computed(() => props.workflow.connections);
    const { nodes: mappedNodes, connections: mappedConnections } = useCanvasMapping({
      nodes,
      connections: connections2,
      workflowObject
    });
    const initialFitViewDone = ref(false);
    onNodesInitialized(() => {
      if (!initialFitViewDone.value || props.showFallbackNodes) {
        props.eventBus.emit("fitView");
        initialFitViewDone.value = true;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref($style).wrapper),
        "data-test-id": "canvas-wrapper"
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref($style).canvas)
        }, [
          workflow.value ? (openBlock(), createBlock(__unplugin_components_0$1, mergeProps({
            key: 0,
            id: _ctx.id,
            nodes: unref(mappedNodes),
            connections: unref(mappedConnections),
            "event-bus": _ctx.eventBus,
            "read-only": _ctx.readOnly
          }, _ctx.$attrs), null, 16, ["id", "nodes", "connections", "event-bus", "read-only"])) : createCommentVNode("", true)
        ], 2),
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
const wrapper = "_wrapper_17o0o_123";
const canvas = "_canvas_17o0o_131";
const style0$1 = {
  wrapper,
  canvas
};
const cssModules$1 = {
  "$style": style0$1
};
const WorkflowCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__cssModules", cssModules$1]]);
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "CanvasRunWorkflowButton",
  props: {
    waitingForWebhook: { type: Boolean },
    executing: { type: Boolean },
    disabled: { type: Boolean }
  },
  emits: ["mouseenter", "mouseleave", "click"],
  setup(__props) {
    const props = __props;
    const i18n = useI18n();
    const label2 = computed(() => {
      if (!props.executing) {
        return i18n.baseText("nodeView.runButtonText.executeWorkflow");
      }
      if (props.waitingForWebhook) {
        return i18n.baseText("nodeView.runButtonText.waitingForTriggerEvent");
      }
      return i18n.baseText("nodeView.runButtonText.executingWorkflow");
    });
    return (_ctx, _cache) => {
      const _component_N8nButton = resolveComponent("N8nButton");
      return openBlock(), createBlock(KeyboardShortcutTooltip, {
        label: label2.value,
        shortcut: { metaKey: true, keys: ["↵"] }
      }, {
        default: withCtx(() => [
          createVNode(_component_N8nButton, {
            loading: _ctx.executing,
            label: label2.value,
            disabled: _ctx.disabled,
            size: "large",
            icon: "flask",
            type: "primary",
            "data-test-id": "execute-workflow-button",
            onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("mouseenter", $event)),
            onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("mouseleave", $event)),
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("click", $event), ["stop"]))
          }, null, 8, ["loading", "label", "disabled"])
        ]),
        _: 1
      }, 8, ["label"]);
    };
  }
});
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "CanvasStopCurrentExecutionButton",
  props: {
    stopping: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const i18n = useI18n();
    const title2 = computed(
      () => props.stopping ? i18n.baseText("nodeView.stoppingCurrentExecution") : i18n.baseText("nodeView.stopCurrentExecution")
    );
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createBlock(_component_N8nIconButton, {
        icon: "stop",
        size: "large",
        class: "stop-execution",
        type: "secondary",
        title: title2.value,
        loading: _ctx.stopping,
        "data-test-id": "stop-execution-button"
      }, null, 8, ["title", "loading"]);
    };
  }
});
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "CanvasStopWaitingForWebhookButton",
  setup(__props) {
    const i18n = useI18n();
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createBlock(_component_N8nIconButton, {
        class: "stop-execution",
        icon: "stop",
        size: "large",
        title: unref(i18n).baseText("nodeView.stopWaitingForWebhookCall"),
        type: "secondary",
        "data-test-id": "stop-execution-waiting-for-webhook-button"
      }, null, 8, ["title"]);
    };
  }
});
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "CanvasClearExecutionDataButton",
  setup(__props) {
    const i18n = useI18n();
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createBlock(_component_N8nIconButton, {
        title: unref(i18n).baseText("nodeView.deletesTheCurrentExecutionData"),
        icon: "trash",
        size: "large",
        "data-test-id": "clear-execution-data-button"
      }, null, 8, ["title"]);
    };
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "NodeView.v2",
  setup(__props) {
    const LazyNodeCreation2 = defineAsyncComponent(
      async () => await __vitePreload(() => import("./NodeCreation-KBmCqr6_.js").then((n) => n.N), true ? __vite__mapDeps([20,1,2,6,7,8,21]) : void 0)
    );
    const LazyNodeDetailsView = defineAsyncComponent(
      async () => await __vitePreload(() => Promise.resolve().then(() => NodeDetailsView), true ? void 0 : void 0)
    );
    const LazySetupWorkflowCredentialsButton2 = defineAsyncComponent(
      async () => await __vitePreload(() => import("./SetupWorkflowCredentialsButton-Cro6GHxL.js"), true ? __vite__mapDeps([24,1,2]) : void 0)
    );
    const $style = useCssModule();
    const router = useRouter();
    const route = useRoute();
    const i18n = useI18n();
    const telemetry = useTelemetry();
    const externalHooks = useExternalHooks();
    const toast = useToast();
    const message = useMessage();
    const documentTitle = useDocumentTitle();
    const workflowHelpers = useWorkflowHelpers({ router });
    const nodeHelpers = useNodeHelpers();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const workflowsStore = useWorkflowsStore();
    const sourceControlStore = useSourceControlStore();
    const nodeCreatorStore = useNodeCreatorStore();
    const settingsStore = useSettingsStore();
    const credentialsStore = useCredentialsStore();
    const environmentsStore = useEnvironmentsStore();
    const externalSecretsStore = useExternalSecretsStore();
    const rootStore = useRootStore();
    const executionsStore = useExecutionsStore();
    const canvasStore = useCanvasStore();
    const npsSurveyStore = useNpsSurveyStore();
    const historyStore = useHistoryStore();
    const projectsStore = useProjectsStore();
    const usersStore = useUsersStore();
    const tagsStore = useTagsStore();
    const pushConnectionStore = usePushConnectionStore();
    const ndvStore = useNDVStore();
    const templatesStore = useTemplatesStore();
    const posthogStore = usePostHog();
    const canvasEventBus = createEventBus();
    const { addBeforeUnloadEventBindings, removeBeforeUnloadEventBindings } = useBeforeUnload({
      route
    });
    const { registerCustomAction, unregisterCustomAction } = useGlobalLinkActions();
    const { runWorkflow, stopCurrentExecution, stopWaitingForWebhook } = useRunWorkflow({ router });
    const {
      updateNodePosition,
      updateNodesPosition,
      revertUpdateNodePosition,
      renameNode,
      revertRenameNode,
      setNodeActive,
      setNodeSelected,
      toggleNodesDisabled,
      revertToggleNodeDisabled,
      toggleNodesPinned,
      setNodeParameters,
      deleteNode,
      deleteNodes,
      copyNodes,
      cutNodes,
      duplicateNodes,
      revertDeleteNode,
      addNodes,
      revertAddNode,
      createConnection,
      revertCreateConnection,
      deleteConnection,
      revertDeleteConnection,
      revalidateNodeInputConnections,
      revalidateNodeOutputConnections,
      setNodeActiveByName,
      addConnections,
      importWorkflowData,
      fetchWorkflowDataFromUrl,
      resetWorkspace,
      initializeWorkspace,
      openExecution,
      editableWorkflow,
      editableWorkflowObject,
      lastClickPosition
    } = useCanvasOperations({ router });
    const { applyExecutionData } = useExecutionDebugging();
    useClipboard({ onPaste: onClipboardPaste });
    const isLoading = ref(true);
    const isBlankRedirect = ref(false);
    const readOnlyNotification = ref(null);
    const isProductionExecutionPreview = ref(false);
    const isExecutionPreview = ref(false);
    const canOpenNDV = ref(true);
    const hideNodeIssues = ref(false);
    const initializedWorkflowId = ref();
    const workflowId = computed(() => {
      const workflowIdParam = route.params.name;
      return [PLACEHOLDER_EMPTY_WORKFLOW_ID, NEW_WORKFLOW_ID].includes(workflowIdParam) ? void 0 : workflowIdParam;
    });
    const isNewWorkflowRoute = computed(() => route.name === VIEWS.NEW_WORKFLOW || !workflowId.value);
    const isWorkflowRoute = computed(() => !!route?.meta?.nodeView || isDemoRoute.value);
    const isDemoRoute = computed(() => route.name === VIEWS.DEMO);
    const isReadOnlyRoute = computed(() => !!route?.meta?.readOnlyCanvas);
    const isReadOnlyEnvironment = computed(() => {
      return sourceControlStore.preferences.branchReadOnly;
    });
    const isCanvasReadOnly = computed(() => {
      return isDemoRoute.value || isReadOnlyEnvironment.value || !(workflowPermissions.value.update ?? projectPermissions.value.workflow.update);
    });
    const fallbackNodes = computed(
      () => isLoading.value || isCanvasReadOnly.value ? [] : [
        {
          id: CanvasNodeRenderType.AddNodes,
          name: CanvasNodeRenderType.AddNodes,
          type: CanvasNodeRenderType.AddNodes,
          typeVersion: 1,
          position: [0, 0],
          parameters: {}
        }
      ]
    );
    const showFallbackNodes = computed(() => triggerNodes.value.length === 0);
    const keyBindingsEnabled = computed(() => {
      return !ndvStore.activeNode && uiStore.activeModals.length === 0;
    });
    const isChatOpen = computed(() => workflowsStore.isChatPanelOpen);
    async function initializeData() {
      const loadPromises = (() => {
        if (settingsStore.isPreviewMode && isDemoRoute.value) return [];
        const promises = [
          workflowsStore.fetchActiveWorkflows(),
          credentialsStore.fetchAllCredentials(),
          credentialsStore.fetchCredentialTypes(true)
        ];
        if (settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Variables]) {
          promises.push(environmentsStore.fetchAllVariables());
        }
        if (settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.ExternalSecrets]) {
          promises.push(externalSecretsStore.fetchAllSecrets());
        }
        return promises;
      })();
      if (nodeTypesStore.allNodeTypes.length === 0) {
        loadPromises.push(nodeTypesStore.getNodeTypes());
      }
      try {
        await Promise.all(loadPromises);
      } catch (error) {
        toast.showError(
          error,
          i18n.baseText("nodeView.showError.mounted1.title"),
          i18n.baseText("nodeView.showError.mounted1.message") + ":"
        );
        return;
      }
    }
    async function initializeRoute(force = false) {
      if (route.query.action === "workflowSave") {
        uiStore.stateIsDirty = false;
        await router.replace({
          query: { ...route.query, action: void 0 }
        });
        return;
      }
      const isAlreadyInitialized = !force && initializedWorkflowId.value && [NEW_WORKFLOW_ID, workflowId.value].includes(initializedWorkflowId.value);
      if (isBlankRedirect.value) {
        isBlankRedirect.value = false;
      } else if (route.name === VIEWS.TEMPLATE_IMPORT) {
        const templateId = route.params.id;
        const loadWorkflowFromJSON = route.query.fromJson === "true";
        if (loadWorkflowFromJSON) {
          const isAiCreditsExperimentEnabled = posthogStore.getVariant(AI_CREDITS_EXPERIMENT.name) === AI_CREDITS_EXPERIMENT.variant;
          const easyAiWorkflowJson = getEasyAiWorkflowJson({
            isInstanceInAiFreeCreditsExperiment: isAiCreditsExperimentEnabled,
            withOpenAiFreeCredits: settingsStore.aiCreditsQuota
          });
          await openTemplateFromWorkflowJSON(easyAiWorkflowJson);
        } else {
          await openWorkflowTemplate(templateId.toString());
        }
      } else if (isWorkflowRoute.value) {
        if (!isAlreadyInitialized) {
          historyStore.reset();
          if (!isDemoRoute.value) {
            await loadCredentials();
          }
          if (isNewWorkflowRoute.value || !workflowId.value) {
            if (route.meta?.nodeView === true) {
              await initializeWorkspaceForNewWorkflow();
            }
            return;
          }
          await initializeWorkspaceForExistingWorkflow(workflowId.value);
          void nextTick(() => {
            nodeHelpers.updateNodesInputIssues();
            nodeHelpers.updateNodesCredentialsIssues();
            nodeHelpers.updateNodesParameterIssues();
          });
        }
        if (route.name === VIEWS.EXECUTION_DEBUG) {
          await initializeDebugMode();
        }
      }
    }
    async function initializeWorkspaceForNewWorkflow() {
      resetWorkspace();
      await workflowsStore.getNewWorkflowData(void 0, projectsStore.currentProjectId);
      workflowsStore.makeNewWorkflowShareable();
      uiStore.nodeViewInitialized = true;
      initializedWorkflowId.value = NEW_WORKFLOW_ID;
    }
    async function initializeWorkspaceForExistingWorkflow(id) {
      try {
        const workflowData = await workflowsStore.fetchWorkflow(id);
        openWorkflow(workflowData);
        if (workflowData.meta?.onboardingId) {
          trackOpenWorkflowFromOnboardingTemplate();
        }
        await projectsStore.setProjectNavActiveIdByWorkflowHomeProject(workflowData.homeProject);
      } catch (error) {
        toast.showError(error, i18n.baseText("openWorkflow.workflowNotFoundError"));
        void router.push({
          name: VIEWS.NEW_WORKFLOW
        });
      } finally {
        uiStore.nodeViewInitialized = true;
        initializedWorkflowId.value = workflowId.value;
      }
    }
    function openWorkflow(data) {
      resetWorkspace();
      workflowHelpers.setDocumentTitle(data.name, "IDLE");
      initializeWorkspace(data);
      void externalHooks.run("workflow.open", {
        workflowId: data.id,
        workflowName: data.name
      });
      fitView();
    }
    function trackOpenWorkflowFromOnboardingTemplate() {
      telemetry.track(
        `User opened workflow from onboarding template with ID ${editableWorkflow.value.meta?.onboardingId}`,
        {
          workflow_id: workflowId.value
        },
        {
          withPostHog: true
        }
      );
    }
    async function openTemplateFromWorkflowJSON(workflow) {
      if (!workflow.nodes || !workflow.connections) {
        toast.showError(
          new Error(i18n.baseText("nodeView.couldntLoadWorkflow.invalidWorkflowObject")),
          i18n.baseText("nodeView.couldntImportWorkflow")
        );
        await router.replace({ name: VIEWS.NEW_WORKFLOW });
        return;
      }
      resetWorkspace();
      canvasStore.startLoading();
      canvasStore.setLoadingText(i18n.baseText("nodeView.loadingTemplate"));
      workflowsStore.currentWorkflowExecutions = [];
      executionsStore.activeExecution = null;
      isBlankRedirect.value = true;
      await router.replace({
        name: VIEWS.NEW_WORKFLOW,
        query: { templateId: workflow.meta.templateId }
      });
      const convertedNodes = workflow.nodes.map(workflowsStore.convertTemplateNodeToNodeUi);
      workflowsStore.setConnections(workflow.connections);
      await addNodes(convertedNodes);
      await workflowsStore.getNewWorkflowData(workflow.name, projectsStore.currentProjectId);
      uiStore.stateIsDirty = true;
      canvasStore.stopLoading();
      fitView();
    }
    async function openWorkflowTemplate(templateId) {
      resetWorkspace();
      canvasStore.startLoading();
      canvasStore.setLoadingText(i18n.baseText("nodeView.loadingTemplate"));
      workflowsStore.currentWorkflowExecutions = [];
      executionsStore.activeExecution = null;
      let data;
      try {
        void externalHooks.run("template.requested", { templateId });
        data = await templatesStore.getFixedWorkflowTemplate(templateId);
        if (!data) {
          throw new Error(
            i18n.baseText("nodeView.workflowTemplateWithIdCouldNotBeFound", {
              interpolate: { templateId }
            })
          );
        }
      } catch (error) {
        toast.showError(error, i18n.baseText("nodeView.couldntImportWorkflow"));
        await router.replace({ name: VIEWS.NEW_WORKFLOW });
        return;
      }
      trackOpenWorkflowTemplate(templateId);
      isBlankRedirect.value = true;
      await router.replace({ name: VIEWS.NEW_WORKFLOW, query: { templateId } });
      const convertedNodes = data.workflow.nodes.map(workflowsStore.convertTemplateNodeToNodeUi);
      workflowsStore.setConnections(data.workflow.connections);
      await addNodes(convertedNodes);
      await workflowsStore.getNewWorkflowData(data.name, projectsStore.currentProjectId);
      workflowsStore.addToWorkflowMetadata({ templateId });
      uiStore.stateIsDirty = true;
      canvasStore.stopLoading();
      void externalHooks.run("template.open", {
        templateId,
        templateName: data.name,
        workflow: data.workflow
      });
      fitView();
    }
    function trackOpenWorkflowTemplate(templateId) {
      telemetry.track(
        "User inserted workflow template",
        {
          source: "workflow",
          template_id: tryToParseNumber(templateId),
          wf_template_repo_session_id: templatesStore.previousSessionId
        },
        {
          withPostHog: true
        }
      );
    }
    const triggerNodes = computed(() => {
      return editableWorkflow.value.nodes.filter(
        (node2) => node2.type === START_NODE_TYPE || nodeTypesStore.isTriggerNode(node2.type)
      );
    });
    const containsTriggerNodes = computed(() => triggerNodes.value.length > 0);
    const allTriggerNodesDisabled = computed(() => {
      const disabledTriggerNodes = triggerNodes.value.filter((node2) => node2.disabled);
      return disabledTriggerNodes.length === triggerNodes.value.length;
    });
    function onUpdateNodesPosition(events) {
      updateNodesPosition(events, { trackHistory: true });
    }
    function onUpdateNodePosition(id, position) {
      updateNodePosition(id, position, { trackHistory: true });
    }
    function onRevertNodePosition({ nodeName, position }) {
      revertUpdateNodePosition(nodeName, { x: position[0], y: position[1] });
    }
    function onDeleteNode(id) {
      deleteNode(id, { trackHistory: true });
    }
    function onDeleteNodes(ids) {
      deleteNodes(ids);
    }
    function onRevertDeleteNode({ node: node2 }) {
      revertDeleteNode(node2);
    }
    function onToggleNodeDisabled(id) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      toggleNodesDisabled([id]);
    }
    function onRevertToggleNodeDisabled({ nodeName }) {
      revertToggleNodeDisabled(nodeName);
    }
    function onToggleNodesDisabled(ids) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      toggleNodesDisabled(ids);
    }
    function onSetNodeActive(id) {
      setNodeActive(id);
    }
    function onSetNodeSelected(id) {
      setNodeSelected(id);
    }
    async function onCopyNodes(ids) {
      await copyNodes(ids);
      toast.showMessage({ title: i18n.baseText("generic.copiedToClipboard"), type: "success" });
    }
    async function onClipboardPaste(plainTextData) {
      if (getNodeViewTab(route) !== MAIN_HEADER_TABS.WORKFLOW || !keyBindingsEnabled.value || !checkIfEditingIsAllowed()) {
        return;
      }
      let workflowData = null;
      if (plainTextData.match(VALID_WORKFLOW_IMPORT_URL_REGEX)) {
        const importConfirm = await message.confirm(
          i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.message", {
            interpolate: { plainTextData }
          }),
          i18n.baseText("nodeView.confirmMessage.onClipboardPasteEvent.headline"),
          {
            type: "warning",
            confirmButtonText: i18n.baseText(
              "nodeView.confirmMessage.onClipboardPasteEvent.confirmButtonText"
            ),
            cancelButtonText: i18n.baseText(
              "nodeView.confirmMessage.onClipboardPasteEvent.cancelButtonText"
            )
          }
        );
        if (importConfirm !== MODAL_CONFIRM) {
          return;
        }
        workflowData = await fetchWorkflowDataFromUrl(plainTextData);
      } else {
        workflowData = jsonParse(plainTextData, { fallbackValue: null });
      }
      if (!workflowData) {
        return;
      }
      const result = await importWorkflowData(workflowData, "paste", false);
      selectNodes(result.nodes?.map((node2) => node2.id) ?? []);
    }
    async function onCutNodes(ids) {
      if (isCanvasReadOnly.value) {
        await copyNodes(ids);
      } else {
        await cutNodes(ids);
      }
    }
    async function onDuplicateNodes(ids) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      const newIds = await duplicateNodes(ids);
      selectNodes(newIds);
    }
    function onPinNodes(ids, source) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      toggleNodesPinned(ids, source);
    }
    async function onSaveWorkflow() {
      const workflowIsSaved = !uiStore.stateIsDirty;
      if (workflowIsSaved) {
        return;
      }
      const saved = await workflowHelpers.saveCurrentWorkflow();
      if (saved) {
        canvasEventBus.emit("saved:workflow");
      }
    }
    function addWorkflowSavedEventBindings() {
      canvasEventBus.on("saved:workflow", npsSurveyStore.fetchPromptsData);
      canvasEventBus.on("saved:workflow", onSaveFromWithinNDV);
    }
    function removeWorkflowSavedEventBindings() {
      canvasEventBus.off("saved:workflow", npsSurveyStore.fetchPromptsData);
      canvasEventBus.off("saved:workflow", onSaveFromWithinNDV);
      canvasEventBus.off("saved:workflow", onSaveFromWithinExecutionDebug);
    }
    async function onSaveFromWithinNDV() {
      if (ndvStore.activeNodeName) {
        toast.showMessage({
          title: i18n.baseText("generic.workflowSaved"),
          type: "success"
        });
      }
    }
    async function onCreateWorkflow() {
      await router.push({ name: VIEWS.NEW_WORKFLOW });
    }
    function onRenameNode(parameterData) {
      if (parameterData.name === "name" && parameterData.oldValue) {
        void renameNode(parameterData.oldValue, parameterData.value);
      }
    }
    async function onOpenRenameNodeModal(id) {
      const currentName = workflowsStore.getNodeById(id)?.name ?? "";
      try {
        const promptResponsePromise = message.prompt(
          i18n.baseText("nodeView.prompt.newName") + ":",
          i18n.baseText("nodeView.prompt.renameNode") + `: ${currentName}`,
          {
            customClass: "rename-prompt",
            confirmButtonText: i18n.baseText("nodeView.prompt.rename"),
            cancelButtonText: i18n.baseText("nodeView.prompt.cancel"),
            inputErrorMessage: i18n.baseText("nodeView.prompt.invalidName"),
            inputValue: currentName,
            inputValidator: (value) => {
              if (!value.trim()) {
                return i18n.baseText("nodeView.prompt.invalidName");
              }
              return true;
            }
          }
        );
        await nextTick();
        const nameInput = document.querySelector(".rename-prompt .el-input__inner");
        nameInput?.focus();
        nameInput?.select();
        const promptResponse = await promptResponsePromise;
        if (promptResponse.action === MODAL_CONFIRM) {
          await renameNode(currentName, promptResponse.value, { trackHistory: true });
        }
      } catch (e) {
      }
    }
    async function onRevertRenameNode({
      currentName,
      newName
    }) {
      await revertRenameNode(currentName, newName);
    }
    function onUpdateNodeParameters(id, parameters) {
      setNodeParameters(id, parameters);
    }
    function onUpdateNodeInputs(id) {
      revalidateNodeInputConnections(id);
    }
    function onUpdateNodeOutputs(id) {
      revalidateNodeOutputConnections(id);
    }
    function onClickNodeAdd(source, sourceHandle) {
      nodeCreatorStore.openNodeCreatorForConnectingNode({
        connection: {
          source,
          sourceHandle
        },
        eventSource: NODE_CREATOR_OPEN_SOURCES.PLUS_ENDPOINT
      });
    }
    async function loadCredentials() {
      let options;
      if (workflowId.value) {
        options = { workflowId: workflowId.value };
      } else {
        const queryParam = typeof route.query?.projectId === "string" ? route.query?.projectId : void 0;
        const projectId = queryParam ?? projectsStore.personalProject?.id;
        if (projectId === void 0) {
          throw new Error(
            "Could not find projectId in the query nor could I find the personal project in the project store"
          );
        }
        options = { projectId };
      }
      await credentialsStore.fetchAllCredentialsForWorkflow(options);
    }
    function onCreateConnection(connection) {
      createConnection(connection, { trackHistory: true });
    }
    function onRevertCreateConnection({ connection }) {
      revertCreateConnection(connection);
    }
    function onCreateConnectionCancelled(event, position, mouseEvent) {
      const preventDefault2 = (mouseEvent?.target).classList?.contains("clickable");
      if (preventDefault2) {
        return;
      }
      uiStore.lastInteractedWithNodeId = event.nodeId;
      uiStore.lastInteractedWithNodeHandle = event.handleId;
      uiStore.lastCancelledConnectionPosition = [position.x, position.y];
      setTimeout(() => {
        if (!event.nodeId) return;
        nodeCreatorStore.openNodeCreatorForConnectingNode({
          connection: {
            source: event.nodeId,
            sourceHandle: event.handleId
          },
          eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_DROP
        });
      });
    }
    function onDeleteConnection(connection) {
      deleteConnection(connection, { trackHistory: true });
    }
    function onRevertDeleteConnection({ connection }) {
      revertDeleteConnection(connection);
    }
    async function importWorkflowExact({ workflow: workflowData }) {
      if (!workflowData.nodes || !workflowData.connections) {
        throw new Error("Invalid workflow object");
      }
      resetWorkspace();
      await initializeData();
      initializeWorkspace({
        ...workflowData,
        nodes: getFixedNodesList(workflowData.nodes)
      });
      fitView();
    }
    async function onImportWorkflowDataEvent(data) {
      const workflowData = data.data;
      await importWorkflowData(workflowData, "file");
      fitView();
      selectNodes(workflowData.nodes?.map((node2) => node2.id) ?? []);
    }
    async function onImportWorkflowUrlEvent(data) {
      const workflowData = await fetchWorkflowDataFromUrl(data.url);
      if (!workflowData) {
        return;
      }
      await importWorkflowData(workflowData, "url");
      fitView();
      selectNodes(workflowData.nodes?.map((node2) => node2.id) ?? []);
    }
    function addImportEventBindings() {
      nodeViewEventBus.on("importWorkflowData", onImportWorkflowDataEvent);
      nodeViewEventBus.on("importWorkflowUrl", onImportWorkflowUrlEvent);
      nodeViewEventBus.on("openChat", onOpenChat);
    }
    function removeImportEventBindings() {
      nodeViewEventBus.off("importWorkflowData", onImportWorkflowDataEvent);
      nodeViewEventBus.off("importWorkflowUrl", onImportWorkflowUrlEvent);
      nodeViewEventBus.off("openChat", onOpenChat);
    }
    async function onAddNodesAndConnections({ nodes, connections: connections2 }, dragAndDrop = false, position) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      const addedNodes = await addNodes(nodes, {
        dragAndDrop,
        position,
        trackHistory: true,
        telemetry: true
      });
      const offsetIndex = editableWorkflow.value.nodes.length - nodes.length;
      const mappedConnections = connections2.map(({ from, to }) => {
        const fromNode = editableWorkflow.value.nodes[offsetIndex + from.nodeIndex];
        const toNode = editableWorkflow.value.nodes[offsetIndex + to.nodeIndex];
        const type = from.type ?? to.type ?? NodeConnectionType.Main;
        return {
          source: fromNode.id,
          sourceHandle: createCanvasConnectionHandleString({
            mode: CanvasConnectionMode.Output,
            type: isValidNodeConnectionType(type) ? type : NodeConnectionType.Main,
            index: from.outputIndex ?? 0
          }),
          target: toNode.id,
          targetHandle: createCanvasConnectionHandleString({
            mode: CanvasConnectionMode.Input,
            type: isValidNodeConnectionType(type) ? type : NodeConnectionType.Main,
            index: to.inputIndex ?? 0
          }),
          data: {
            source: {
              index: from.outputIndex ?? 0,
              type
            },
            target: {
              index: to.inputIndex ?? 0,
              type
            }
          }
        };
      });
      await addConnections(mappedConnections);
      uiStore.resetLastInteractedWith();
      if (addedNodes.length > 0) {
        selectNodes([addedNodes[addedNodes.length - 1].id]);
      }
    }
    async function onRevertAddNode({ node: node2 }) {
      await revertAddNode(node2.name);
    }
    async function onSwitchActiveNode(nodeName) {
      const node2 = workflowsStore.getNodeByName(nodeName);
      if (!node2) return;
      setNodeActiveByName(nodeName);
      selectNodes([node2.id]);
    }
    async function onOpenSelectiveNodeCreator(node2, connectionType2) {
      nodeCreatorStore.openSelectiveNodeCreator({ node: node2, connectionType: connectionType2 });
    }
    async function onOpenNodeCreatorForTriggerNodes(source) {
      nodeCreatorStore.openNodeCreatorForTriggerNodes(source);
    }
    function onOpenNodeCreatorFromCanvas(source) {
      onToggleNodeCreator({ createNodeActive: true, source });
    }
    function onToggleNodeCreator(options) {
      nodeCreatorStore.setNodeCreatorState(options);
      if (!options.createNodeActive && !options.hasAddedNodes) {
        uiStore.resetLastInteractedWith();
      }
    }
    function onCreateSticky() {
      void onAddNodesAndConnections({ nodes: [{ type: STICKY_NODE_TYPE }], connections: [] });
    }
    function onClickConnectionAdd(connection) {
      nodeCreatorStore.openNodeCreatorForConnectingNode({
        connection,
        eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_ACTION
      });
    }
    const workflowPermissions = computed(() => {
      return workflowId.value ? getResourcePermissions(workflowsStore.getWorkflowById(workflowId.value)?.scopes).workflow : {};
    });
    const projectPermissions = computed(() => {
      const project = route.query?.projectId ? projectsStore.myProjects.find((p) => p.id === route.query.projectId) : projectsStore.currentProject ?? projectsStore.personalProject;
      return getResourcePermissions(project?.scopes);
    });
    const isStoppingExecution = ref(false);
    const isWorkflowRunning = computed(() => workflowsStore.isWorkflowRunning);
    const isExecutionWaitingForWebhook = computed(() => workflowsStore.executionWaitingForWebhook);
    const isExecutionDisabled = computed(() => {
      if (containsChatTriggerNodes.value && isOnlyChatTriggerNodeActive.value && !chatTriggerNodePinnedData.value) {
        return true;
      }
      return !containsTriggerNodes.value || allTriggerNodesDisabled.value;
    });
    const isRunWorkflowButtonVisible = computed(
      () => !isOnlyChatTriggerNodeActive.value || chatTriggerNodePinnedData.value
    );
    const isStopExecutionButtonVisible = computed(
      () => isWorkflowRunning.value && !isExecutionWaitingForWebhook.value
    );
    const isStopWaitingForWebhookButtonVisible = computed(
      () => isWorkflowRunning.value && isExecutionWaitingForWebhook.value
    );
    const isClearExecutionButtonVisible = computed(
      () => !isReadOnlyRoute.value && !isReadOnlyEnvironment.value && !isWorkflowRunning.value && !allTriggerNodesDisabled.value && workflowExecutionData.value
    );
    const workflowExecutionData = computed(() => workflowsStore.workflowExecutionData);
    async function onRunWorkflow() {
      trackRunWorkflow();
      void runWorkflow({});
    }
    function trackRunWorkflow() {
      void workflowHelpers.getWorkflowDataToSave().then((workflowData) => {
        const telemetryPayload = {
          workflow_id: workflowId.value,
          node_graph_string: JSON.stringify(
            generateNodesGraph(
              workflowData,
              workflowHelpers.getNodeTypes(),
              { isCloudDeployment: settingsStore.isCloudDeployment }
            ).nodeGraph
          )
        };
        telemetry.track("User clicked execute workflow button", telemetryPayload);
        void externalHooks.run("nodeView.onRunWorkflow", telemetryPayload);
      });
    }
    async function onRunWorkflowToNode(id) {
      const node2 = workflowsStore.getNodeById(id);
      if (!node2) return;
      trackRunWorkflowToNode(node2);
      void runWorkflow({ destinationNode: node2.name, source: "Node.executeNode" });
    }
    function trackRunWorkflowToNode(node2) {
      const telemetryPayload = {
        node_type: node2.type,
        workflow_id: workflowsStore.workflowId,
        source: "canvas",
        push_ref: ndvStore.pushRef
      };
      telemetry.track("User clicked execute node button", telemetryPayload);
      void externalHooks.run("nodeView.onRunNode", telemetryPayload);
    }
    async function onOpenExecution(executionId) {
      canvasStore.startLoading();
      resetWorkspace();
      await initializeData();
      const data = await openExecution(executionId);
      if (!data) {
        return;
      }
      canvasStore.stopLoading();
      fitView();
      canvasEventBus.emit("open:execution", data);
      void externalHooks.run("execution.open", {
        workflowId: data.workflowData.id,
        workflowName: data.workflowData.name,
        executionId
      });
      telemetry.track("User opened read-only execution", {
        workflow_id: data.workflowData.id,
        execution_mode: data.mode,
        execution_finished: data.finished
      });
    }
    function onExecutionOpenedWithError(data) {
      if (!data.finished && data.data?.resultData?.error) {
        let nodeErrorFound = false;
        if (data.data.resultData.runData) {
          const runData = data.data.resultData.runData;
          errorCheck: for (const nodeName of Object.keys(runData)) {
            for (const taskData of runData[nodeName]) {
              if (taskData.error) {
                nodeErrorFound = true;
                break errorCheck;
              }
            }
          }
        }
        if (!nodeErrorFound && (data.data.resultData.error.stack ?? data.data.resultData.error.message)) {
          console.error(`Execution ${data.id} error:`);
          console.error(data.data.resultData.error.stack);
          toast.showMessage({
            title: i18n.baseText("nodeView.showError.workflowError"),
            message: data.data.resultData.error.message,
            type: "error",
            duration: 0
          });
        }
      }
    }
    function onExecutionOpenedWithWaitTill(data) {
      if (data.waitTill) {
        toast.showMessage({
          title: i18n.baseText("nodeView.thisExecutionHasntFinishedYet"),
          message: h(_sfc_main$9),
          type: "warning",
          duration: 0
        });
      }
    }
    function addExecutionOpenedEventBindings() {
      canvasEventBus.on("open:execution", onExecutionOpenedWithError);
      canvasEventBus.on("open:execution", onExecutionOpenedWithWaitTill);
    }
    function removeExecutionOpenedEventBindings() {
      canvasEventBus.off("open:execution", onExecutionOpenedWithError);
      canvasEventBus.off("open:execution", onExecutionOpenedWithWaitTill);
    }
    async function onStopExecution() {
      isStoppingExecution.value = true;
      await stopCurrentExecution();
      isStoppingExecution.value = false;
    }
    async function onStopWaitingForWebhook() {
      await stopWaitingForWebhook();
    }
    async function onClearExecutionData() {
      workflowsStore.workflowExecutionData = null;
      nodeHelpers.updateNodesExecutionIssues();
    }
    function onRunWorkflowButtonMouseEnter() {
      nodeViewEventBus.emit("runWorkflowButton:mouseenter");
    }
    function onRunWorkflowButtonMouseLeave() {
      nodeViewEventBus.emit("runWorkflowButton:mouseleave");
    }
    const chatTriggerNode = computed(() => {
      return editableWorkflow.value.nodes.find((node2) => node2.type === CHAT_TRIGGER_NODE_TYPE);
    });
    const containsChatTriggerNodes = computed(() => {
      return !isExecutionWaitingForWebhook.value && !!editableWorkflow.value.nodes.find(
        (node2) => [MANUAL_CHAT_TRIGGER_NODE_TYPE, CHAT_TRIGGER_NODE_TYPE].includes(node2.type) && node2.disabled !== true
      );
    });
    const isOnlyChatTriggerNodeActive = computed(() => {
      return triggerNodes.value.every((node2) => node2.disabled || node2.type === CHAT_TRIGGER_NODE_TYPE);
    });
    const chatTriggerNodePinnedData = computed(() => {
      if (!chatTriggerNode.value) return null;
      return workflowsStore.pinDataByNodeName(chatTriggerNode.value.name);
    });
    async function onOpenChat() {
      workflowsStore.setPanelOpen("chat", !workflowsStore.isChatPanelOpen);
      const payload = {
        workflow_id: workflowId.value
      };
      void externalHooks.run("nodeView.onOpenChat", payload);
      telemetry.track("User clicked chat open button", payload);
    }
    function addUndoRedoEventBindings() {
      historyBus.on("nodeMove", onRevertNodePosition);
      historyBus.on("revertAddNode", onRevertAddNode);
      historyBus.on("revertRemoveNode", onRevertDeleteNode);
      historyBus.on("revertAddConnection", onRevertCreateConnection);
      historyBus.on("revertRemoveConnection", onRevertDeleteConnection);
      historyBus.on("revertRenameNode", onRevertRenameNode);
      historyBus.on("enableNodeToggle", onRevertToggleNodeDisabled);
    }
    function removeUndoRedoEventBindings() {
      historyBus.off("nodeMove", onRevertNodePosition);
      historyBus.off("revertAddNode", onRevertAddNode);
      historyBus.off("revertRemoveNode", onRevertDeleteNode);
      historyBus.off("revertAddConnection", onRevertCreateConnection);
      historyBus.off("revertRemoveConnection", onRevertDeleteConnection);
      historyBus.off("revertRenameNode", onRevertRenameNode);
      historyBus.off("enableNodeToggle", onRevertToggleNodeDisabled);
    }
    async function onSourceControlPull() {
      try {
        await Promise.all([
          environmentsStore.fetchAllVariables(),
          tagsStore.fetchAll(),
          loadCredentials()
        ]);
        if (workflowId.value && !uiStore.stateIsDirty) {
          const workflowData = await workflowsStore.fetchWorkflow(workflowId.value);
          if (workflowData) {
            workflowHelpers.setDocumentTitle(workflowData.name, "IDLE");
            openWorkflow(workflowData);
          }
        }
      } catch (error) {
        console.error(error);
      }
    }
    function addSourceControlEventBindings() {
      sourceControlEventBus.on("pull", onSourceControlPull);
    }
    function removeSourceControlEventBindings() {
      sourceControlEventBus.off("pull", onSourceControlPull);
    }
    function addPostMessageEventBindings() {
      window.addEventListener("message", onPostMessageReceived);
    }
    function removePostMessageEventBindings() {
      window.removeEventListener("message", onPostMessageReceived);
    }
    function emitPostMessageReady() {
      if (window.parent) {
        window.parent.postMessage(
          JSON.stringify({ command: "n8nReady", version: rootStore.versionCli }),
          "*"
        );
      }
    }
    async function onPostMessageReceived(messageEvent) {
      if (!messageEvent || typeof messageEvent.data !== "string" || !messageEvent.data?.includes?.('"command"')) {
        return;
      }
      try {
        const json = JSON.parse(messageEvent.data);
        if (json && json.command === "openWorkflow") {
          try {
            await importWorkflowExact(json);
            canOpenNDV.value = json.canOpenNDV ?? true;
            hideNodeIssues.value = json.hideNodeIssues ?? false;
            isExecutionPreview.value = false;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: i18n.baseText("openWorkflow.workflowImportError")
                }),
                "*"
              );
            }
            toast.showError(e, i18n.baseText("openWorkflow.workflowImportError"));
          }
        } else if (json && json.command === "openExecution") {
          try {
            isProductionExecutionPreview.value = json.executionMode !== "manual" && json.executionMode !== "evaluation";
            await onOpenExecution(json.executionId);
            canOpenNDV.value = json.canOpenNDV ?? true;
            hideNodeIssues.value = json.hideNodeIssues ?? false;
            isExecutionPreview.value = true;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: i18n.baseText("nodeView.showError.openExecution.title")
                }),
                "*"
              );
            }
            toast.showMessage({
              title: i18n.baseText("nodeView.showError.openExecution.title"),
              message: e.message,
              type: "error"
            });
          }
        } else if (json?.command === "setActiveExecution") {
          executionsStore.activeExecution = await executionsStore.fetchExecution(
            json.executionId
          );
        }
      } catch (e) {
      }
    }
    function checkIfEditingIsAllowed() {
      if (!initializedWorkflowId.value) {
        return true;
      }
      if (readOnlyNotification.value?.visible) {
        return false;
      }
      if (isReadOnlyRoute.value || isReadOnlyEnvironment.value) {
        const messageContext = isReadOnlyRoute.value ? "executions" : "workflows";
        readOnlyNotification.value = toast.showMessage({
          title: i18n.baseText(
            isReadOnlyEnvironment.value ? `readOnlyEnv.showMessage.${messageContext}.title` : "readOnly.showMessage.executions.title"
          ),
          message: i18n.baseText(
            isReadOnlyEnvironment.value ? `readOnlyEnv.showMessage.${messageContext}.message` : "readOnly.showMessage.executions.message"
          ),
          type: "info"
        });
        return false;
      }
      return true;
    }
    function checkIfRouteIsAllowed() {
      if (isReadOnlyEnvironment.value && [VIEWS.NEW_WORKFLOW, VIEWS.TEMPLATE_IMPORT].find((view) => view === route.name)) {
        void nextTick(async () => {
          resetWorkspace();
          uiStore.stateIsDirty = false;
          await router.replace({ name: VIEWS.HOMEPAGE });
        });
      }
    }
    async function initializeDebugMode() {
      workflowHelpers.setDocumentTitle(workflowsStore.workflowName, "DEBUG");
      if (!workflowsStore.isInDebugMode) {
        await applyExecutionData(route.params.executionId);
        workflowsStore.isInDebugMode = true;
      }
      canvasEventBus.on("saved:workflow", onSaveFromWithinExecutionDebug);
    }
    async function onSaveFromWithinExecutionDebug() {
      if (route.name !== VIEWS.EXECUTION_DEBUG) return;
      await router.replace({
        name: VIEWS.WORKFLOW,
        params: { name: workflowId.value }
      });
    }
    const viewportTransform = ref({ x: 0, y: 0, zoom: 1 });
    function onViewportChange(event) {
      viewportTransform.value = event;
      uiStore.nodeViewOffsetPosition = [event.x, event.y];
    }
    function fitView() {
      setTimeout(() => canvasEventBus.emit("fitView"));
    }
    function selectNodes(ids) {
      setTimeout(() => canvasEventBus.emit("nodes:select", { ids }));
    }
    function onClickPane(position) {
      lastClickPosition.value = [position.x, position.y];
      nodeCreatorStore.isCreateNodeActive = false;
      setNodeSelected();
    }
    async function onDragAndDrop(position, event) {
      if (!event.dataTransfer) {
        return;
      }
      const dropData = jsonParse(
        event.dataTransfer.getData(DRAG_EVENT_DATA_KEY)
      );
      if (dropData) {
        const insertNodePosition = [position.x, position.y];
        await onAddNodesAndConnections(dropData, true, insertNodePosition);
        onToggleNodeCreator({ createNodeActive: false, hasAddedNodes: true });
      }
    }
    function registerCustomActions() {
      registerCustomAction({
        key: "openNodeDetail",
        action: ({ node: node2 }) => {
          setNodeActiveByName(node2);
        }
      });
      registerCustomAction({
        key: "openSelectiveNodeCreator",
        action: ({
          creatorview: creatorView,
          connectiontype: connectionType2,
          node: node2
        }) => {
          nodeCreatorStore.openSelectiveNodeCreator({ node: node2, connectionType: connectionType2, creatorView });
        }
      });
      registerCustomAction({
        key: "showNodeCreator",
        action: () => {
          ndvStore.activeNodeName = null;
          void nextTick(() => {
            void onOpenNodeCreatorForTriggerNodes(NODE_CREATOR_OPEN_SOURCES.TAB);
          });
        }
      });
    }
    function unregisterCustomActions() {
      unregisterCustomAction("openNodeDetail");
      unregisterCustomAction("openSelectiveNodeCreator");
      unregisterCustomAction("showNodeCreator");
    }
    function showAddFirstStepIfEnabled() {
      if (uiStore.addFirstStepOnLoad) {
        void onOpenNodeCreatorForTriggerNodes(NODE_CREATOR_OPEN_SOURCES.TRIGGER_PLACEHOLDER_BUTTON);
        uiStore.addFirstStepOnLoad = false;
      }
    }
    watch(
      () => route.name,
      async (newRouteName, oldRouteName) => {
        const force = newRouteName === VIEWS.NEW_WORKFLOW && oldRouteName === VIEWS.WORKFLOW;
        await initializeRoute(force);
      }
    );
    onBeforeMount(() => {
      if (!isDemoRoute.value) {
        pushConnectionStore.pushConnect();
      }
      addPostMessageEventBindings();
    });
    onMounted(() => {
      canvasStore.startLoading();
      documentTitle.reset();
      resetWorkspace();
      void initializeData().then(() => {
        void initializeRoute().then(() => {
          toast.showNotificationForViews([VIEWS.WORKFLOW, VIEWS.NEW_WORKFLOW]);
        }).finally(() => {
          isLoading.value = false;
          canvasStore.stopLoading();
          void externalHooks.run("nodeView.mount").catch(() => {
          });
          emitPostMessageReady();
        });
        void usersStore.showPersonalizationSurvey();
        checkIfRouteIsAllowed();
      });
      addSourceControlEventBindings();
      addWorkflowSavedEventBindings();
      addBeforeUnloadEventBindings();
      addImportEventBindings();
      addExecutionOpenedEventBindings();
      registerCustomActions();
    });
    onActivated(async () => {
      addUndoRedoEventBindings();
      showAddFirstStepIfEnabled();
    });
    onDeactivated(() => {
      removeUndoRedoEventBindings();
    });
    onBeforeUnmount(() => {
      removeSourceControlEventBindings();
      removePostMessageEventBindings();
      removeWorkflowSavedEventBindings();
      removeBeforeUnloadEventBindings();
      removeImportEventBindings();
      removeExecutionOpenedEventBindings();
      unregisterCustomActions();
      if (!isDemoRoute.value) {
        pushConnectionStore.pushDisconnect();
      }
    });
    return (_ctx, _cache) => {
      const _component_CanvasChatButton = _sfc_main$7;
      return unref(editableWorkflow) && unref(editableWorkflowObject) && !isLoading.value ? (openBlock(), createBlock(WorkflowCanvas, {
        key: 0,
        id: unref(editableWorkflow).id,
        workflow: unref(editableWorkflow),
        "workflow-object": unref(editableWorkflowObject),
        "fallback-nodes": fallbackNodes.value,
        "show-fallback-nodes": showFallbackNodes.value,
        "event-bus": unref(canvasEventBus),
        "read-only": isCanvasReadOnly.value,
        executing: isWorkflowRunning.value,
        "key-bindings": keyBindingsEnabled.value,
        "onUpdate:nodes:position": onUpdateNodesPosition,
        "onUpdate:node:position": onUpdateNodePosition,
        "onUpdate:node:active": onSetNodeActive,
        "onUpdate:node:selected": onSetNodeSelected,
        "onUpdate:node:enabled": onToggleNodeDisabled,
        "onUpdate:node:name": onOpenRenameNodeModal,
        "onUpdate:node:parameters": onUpdateNodeParameters,
        "onUpdate:node:inputs": onUpdateNodeInputs,
        "onUpdate:node:outputs": onUpdateNodeOutputs,
        "onClick:node:add": onClickNodeAdd,
        "onRun:node": onRunWorkflowToNode,
        "onDelete:node": onDeleteNode,
        "onCreate:connection": onCreateConnection,
        "onCreate:connection:cancelled": onCreateConnectionCancelled,
        "onDelete:connection": onDeleteConnection,
        "onClick:connection:add": onClickConnectionAdd,
        "onClick:pane": onClickPane,
        "onCreate:node": onOpenNodeCreatorFromCanvas,
        "onCreate:sticky": onCreateSticky,
        "onDelete:nodes": onDeleteNodes,
        "onUpdate:nodes:enabled": onToggleNodesDisabled,
        "onUpdate:nodes:pin": onPinNodes,
        "onDuplicate:nodes": onDuplicateNodes,
        "onCopy:nodes": onCopyNodes,
        "onCut:nodes": onCutNodes,
        "onRun:workflow": onRunWorkflow,
        "onSave:workflow": onSaveWorkflow,
        "onCreate:workflow": onCreateWorkflow,
        onViewportChange,
        onDragAndDrop
      }, {
        default: withCtx(() => [
          (openBlock(), createBlock(Suspense, null, {
            default: withCtx(() => [
              createVNode(unref(LazySetupWorkflowCredentialsButton2), {
                class: normalizeClass(unref($style).setupCredentialsButtonWrapper)
              }, null, 8, ["class"])
            ]),
            _: 1
          })),
          !isCanvasReadOnly.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref($style).executionButtons)
          }, [
            isRunWorkflowButtonVisible.value ? (openBlock(), createBlock(_sfc_main$5, {
              key: 0,
              "waiting-for-webhook": isExecutionWaitingForWebhook.value,
              disabled: isExecutionDisabled.value,
              executing: isWorkflowRunning.value,
              onMouseenter: onRunWorkflowButtonMouseEnter,
              onMouseleave: onRunWorkflowButtonMouseLeave,
              onClick: onRunWorkflow
            }, null, 8, ["waiting-for-webhook", "disabled", "executing"])) : createCommentVNode("", true),
            containsChatTriggerNodes.value ? (openBlock(), createBlock(_component_CanvasChatButton, {
              key: 1,
              type: isChatOpen.value ? "tertiary" : "primary",
              label: isChatOpen.value ? unref(i18n).baseText("chat.hide") : unref(i18n).baseText("chat.window.title"),
              onClick: onOpenChat
            }, null, 8, ["type", "label"])) : createCommentVNode("", true),
            isStopExecutionButtonVisible.value ? (openBlock(), createBlock(_sfc_main$4, {
              key: 2,
              stopping: isStoppingExecution.value,
              onClick: onStopExecution
            }, null, 8, ["stopping"])) : createCommentVNode("", true),
            isStopWaitingForWebhookButtonVisible.value ? (openBlock(), createBlock(_sfc_main$3, {
              key: 3,
              onClick: onStopWaitingForWebhook
            })) : createCommentVNode("", true),
            isClearExecutionButtonVisible.value ? (openBlock(), createBlock(_sfc_main$2, {
              key: 4,
              onClick: onClearExecutionData
            })) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true),
          isReadOnlyEnvironment.value ? (openBlock(), createBlock(unref(N8nCallout), {
            key: 1,
            theme: "warning",
            icon: "lock",
            class: normalizeClass(unref($style).readOnlyEnvironmentNotification)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(i18n).baseText("readOnlyEnv.cantEditOrRun")), 1)
            ]),
            _: 1
          }, 8, ["class"])) : createCommentVNode("", true),
          (openBlock(), createBlock(Suspense, null, {
            default: withCtx(() => [
              !isCanvasReadOnly.value ? (openBlock(), createBlock(unref(LazyNodeCreation2), {
                key: 0,
                "create-node-active": unref(nodeCreatorStore).isCreateNodeActive,
                "node-view-scale": viewportTransform.value.zoom,
                onToggleNodeCreator,
                onAddNodes: onAddNodesAndConnections
              }, null, 8, ["create-node-active", "node-view-scale"])) : createCommentVNode("", true)
            ]),
            _: 1
          })),
          (openBlock(), createBlock(Suspense, null, {
            default: withCtx(() => [
              createVNode(unref(LazyNodeDetailsView), {
                "workflow-object": unref(editableWorkflowObject),
                "read-only": isCanvasReadOnly.value,
                "is-production-execution-preview": isProductionExecutionPreview.value,
                renaming: false,
                onValueChanged: onRenameNode,
                onStopExecution,
                onSwitchSelectedNode: onSwitchActiveNode,
                onOpenConnectionNodeCreator: onOpenSelectiveNodeCreator,
                onSaveKeyboardShortcut: onSaveWorkflow
              }, null, 8, ["workflow-object", "read-only", "is-production-execution-preview"])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["id", "workflow", "workflow-object", "fallback-nodes", "show-fallback-nodes", "event-bus", "read-only", "executing", "key-bindings"])) : createCommentVNode("", true);
    };
  }
});
const executionButtons = "_executionButtons_8gz1l_123";
const setupCredentialsButtonWrapper = "_setupCredentialsButtonWrapper_8gz1l_161";
const readOnlyEnvironmentNotification = "_readOnlyEnvironmentNotification_8gz1l_167";
const style0 = {
  executionButtons,
  setupCredentialsButtonWrapper,
  readOnlyEnvironmentNotification
};
const cssModules = {
  "$style": style0
};
const NodeViewV2 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__cssModules", cssModules]]);
function useNodeViewVersionSwitcher() {
  const ndvStore = useNDVStore();
  const workflowsStore = useWorkflowsStore();
  const telemetry = useTelemetry();
  const settingsStore = useSettingsStore();
  const isNewUser = computed(() => workflowsStore.activeWorkflows.length === 0);
  const defaultVersion = settingsStore.isCanvasV2Enabled ? "2" : "1";
  const nodeViewVersion = useLocalStorage("NodeView.version", defaultVersion);
  const nodeViewVersionMigrated = useLocalStorage("NodeView.migrated.release", false);
  function setNodeViewSwitcherDropdownOpened(visible2) {
    if (!visible2) {
      setNodeViewSwitcherDiscovered();
    }
  }
  const nodeViewSwitcherDiscovered = useLocalStorage("NodeView.switcher.discovered.beta", false);
  function setNodeViewSwitcherDiscovered() {
    nodeViewSwitcherDiscovered.value = true;
  }
  const isNodeViewDiscoveryTooltipVisible = computed(
    () => !isNewUser.value && !ndvStore.activeNodeName && nodeViewVersion.value === "2" && !nodeViewSwitcherDiscovered.value
  );
  function switchNodeViewVersion() {
    const toVersion = nodeViewVersion.value === "2" ? "1" : "2";
    if (!nodeViewVersionMigrated.value) {
      nodeViewVersionMigrated.value = true;
    }
    telemetry.track("User switched canvas version", {
      to_version: toVersion
    });
    nodeViewVersion.value = toVersion;
  }
  function migrateToNewNodeViewVersion() {
    if (nodeViewVersionMigrated.value || nodeViewVersion.value === "2") {
      return;
    }
    switchNodeViewVersion();
  }
  return {
    isNewUser,
    nodeViewVersion,
    nodeViewVersionMigrated,
    nodeViewSwitcherDiscovered,
    isNodeViewDiscoveryTooltipVisible,
    setNodeViewSwitcherDropdownOpened,
    setNodeViewSwitcherDiscovered,
    switchNodeViewVersion,
    migrateToNewNodeViewVersion
  };
}
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "NodeViewSwitcher",
  setup(__props) {
    const workflowsStore = useWorkflowsStore();
    const sourceControlStore = useSourceControlStore();
    const router = useRouter();
    const route = useRoute();
    const workflowHelpers = useWorkflowHelpers({ router });
    const { nodeViewVersion, migrateToNewNodeViewVersion } = useNodeViewVersionSwitcher();
    const workflowId = computed(() => route.params.name);
    const isReadOnlyEnvironment = computed(() => {
      return sourceControlStore.preferences.branchReadOnly;
    });
    onMounted(() => {
      migrateToNewNodeViewVersion();
    });
    watch(nodeViewVersion, () => {
      router.go(0);
    });
    onBeforeRouteLeave(async (to, from, next) => {
      const toNodeViewTab = getNodeViewTab(to);
      if (toNodeViewTab === MAIN_HEADER_TABS.EXECUTIONS || from.name === VIEWS.TEMPLATE_IMPORT || toNodeViewTab === MAIN_HEADER_TABS.WORKFLOW && from.name === VIEWS.EXECUTION_DEBUG || isReadOnlyEnvironment.value) {
        next();
        return;
      }
      await workflowHelpers.promptSaveUnsavedWorkflowChanges(next, {
        async confirm() {
          if (from.name === VIEWS.NEW_WORKFLOW) {
            await router.replace({
              name: VIEWS.WORKFLOW,
              params: { name: workflowId.value }
            });
            await router.push(to);
            return false;
          }
          workflowsStore.setWorkflowId(PLACEHOLDER_EMPTY_WORKFLOW_ID);
          return true;
        }
      });
    });
    return (_ctx, _cache) => {
      return unref(nodeViewVersion) === "2" ? (openBlock(), createBlock(NodeViewV2, { key: 0 })) : (openBlock(), createBlock(NodeViewV1, { key: 1 }));
    };
  }
});
const NodeViewSwitcher = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _sfc_main
}, Symbol.toStringTag, { value: "Module" }));
export {
  NodeViewSwitcher as N,
  VueJsonPretty as V
};
