"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkflowHooksIntegrated = getWorkflowHooksIntegrated;
exports.getWorkflowHooksWorkerExecuter = getWorkflowHooksWorkerExecuter;
exports.getWorkflowHooksWorkerMain = getWorkflowHooksWorkerMain;
exports.getWorkflowHooksMain = getWorkflowHooksMain;
const di_1 = require("@n8n/di");
const flatted_1 = require("flatted");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const execution_repository_1 = require("../databases/repositories/execution.repository");
const event_service_1 = require("../events/event.service");
const external_hooks_1 = require("../external-hooks");
const push_1 = require("../push");
const workflow_statistics_service_1 = require("../services/workflow-statistics.service");
const utils_1 = require("../utils");
const workflow_static_data_service_1 = require("../workflows/workflow-static-data.service");
const execute_error_workflow_1 = require("./execute-error-workflow");
const restore_binary_data_id_1 = require("./restore-binary-data-id");
const save_execution_progress_1 = require("./save-execution-progress");
const shared_hook_functions_1 = require("./shared/shared-hook-functions");
const to_save_settings_1 = require("./to-save-settings");
function mergeHookFunctions(...hookFunctions) {
    const result = {
        nodeExecuteBefore: [],
        nodeExecuteAfter: [],
        workflowExecuteBefore: [],
        workflowExecuteAfter: [],
        sendResponse: [],
        nodeFetchedData: [],
    };
    for (const hooks of hookFunctions) {
        for (const key in hooks) {
            if (!result[key] || !hooks[key])
                continue;
            result[key].push(...hooks[key]);
        }
    }
    return result;
}
function hookFunctionsWorkflowEvents(userId) {
    const eventService = di_1.Container.get(event_service_1.EventService);
    return {
        workflowExecuteBefore: [
            async function () {
                const { executionId, workflowData } = this;
                eventService.emit('workflow-pre-execute', { executionId, data: workflowData });
            },
        ],
        workflowExecuteAfter: [
            async function (runData) {
                const { executionId, workflowData: workflow } = this;
                eventService.emit('workflow-post-execute', { executionId, runData, workflow, userId });
            },
        ],
    };
}
function hookFunctionsNodeEvents() {
    const eventService = di_1.Container.get(event_service_1.EventService);
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                const { executionId, workflowData: workflow } = this;
                eventService.emit('node-pre-execute', { executionId, workflow, nodeName });
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName) {
                const { executionId, workflowData: workflow } = this;
                eventService.emit('node-post-execute', { executionId, workflow, nodeName });
            },
        ],
    };
}
function hookFunctionsPush() {
    const logger = di_1.Container.get(n8n_core_1.Logger);
    const pushInstance = di_1.Container.get(push_1.Push);
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                const { pushRef, executionId } = this;
                if (pushRef === undefined) {
                    return;
                }
                logger.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId,
                    pushRef,
                    workflowId: this.workflowData.id,
                });
                pushInstance.send({ type: 'nodeExecuteBefore', data: { executionId, nodeName } }, pushRef);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data) {
                const { pushRef, executionId } = this;
                if (pushRef === undefined) {
                    return;
                }
                logger.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId,
                    pushRef,
                    workflowId: this.workflowData.id,
                });
                pushInstance.send({ type: 'nodeExecuteAfter', data: { executionId, nodeName, data } }, pushRef);
            },
        ],
        workflowExecuteBefore: [
            async function (_workflow, data) {
                const { pushRef, executionId } = this;
                const { id: workflowId, name: workflowName } = this.workflowData;
                logger.debug('Executing hook (hookFunctionsPush)', {
                    executionId,
                    pushRef,
                    workflowId,
                });
                if (pushRef === undefined) {
                    return;
                }
                pushInstance.send({
                    type: 'executionStarted',
                    data: {
                        executionId,
                        mode: this.mode,
                        startedAt: new Date(),
                        retryOf: this.retryOf,
                        workflowId,
                        workflowName,
                        flattedRunData: data?.resultData.runData
                            ? (0, flatted_1.stringify)(data.resultData.runData)
                            : (0, flatted_1.stringify)({}),
                    },
                }, pushRef);
            },
        ],
        workflowExecuteAfter: [
            async function (fullRunData) {
                const { pushRef, executionId } = this;
                if (pushRef === undefined)
                    return;
                const { id: workflowId } = this.workflowData;
                logger.debug('Executing hook (hookFunctionsPush)', {
                    executionId,
                    pushRef,
                    workflowId,
                });
                const { status } = fullRunData;
                if (status === 'waiting') {
                    pushInstance.send({ type: 'executionWaiting', data: { executionId } }, pushRef);
                }
                else {
                    const rawData = (0, flatted_1.stringify)(fullRunData.data);
                    pushInstance.send({ type: 'executionFinished', data: { executionId, workflowId, status, rawData } }, pushRef);
                }
            },
        ],
    };
}
function hookFunctionsPreExecute() {
    const externalHooks = di_1.Container.get(external_hooks_1.ExternalHooks);
    return {
        workflowExecuteBefore: [
            async function (workflow) {
                await externalHooks.run('workflow.preExecute', [workflow, this.mode]);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data, executionData) {
                await (0, save_execution_progress_1.saveExecutionProgress)(this.workflowData, this.executionId, nodeName, data, executionData, this.pushRef);
            },
        ],
    };
}
function hookFunctionsFinalizeExecutionStatus() {
    return {
        workflowExecuteAfter: [
            async function (fullRunData) {
                fullRunData.status = (0, shared_hook_functions_1.determineFinalExecutionStatus)(fullRunData);
            },
        ],
    };
}
function hookFunctionsSave() {
    const logger = di_1.Container.get(n8n_core_1.Logger);
    const workflowStatisticsService = di_1.Container.get(workflow_statistics_service_1.WorkflowStatisticsService);
    return {
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                logger.debug('Executing hook (hookFunctionsSave)', {
                    executionId: this.executionId,
                    workflowId: this.workflowData.id,
                });
                await (0, restore_binary_data_id_1.restoreBinaryDataId)(fullRunData, this.executionId, this.mode);
                const isManualMode = this.mode === 'manual';
                try {
                    if (!isManualMode && (0, utils_1.isWorkflowIdValid)(this.workflowData.id) && newStaticData) {
                        try {
                            await di_1.Container.get(workflow_static_data_service_1.WorkflowStaticDataService).saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            di_1.Container.get(n8n_core_1.ErrorReporter).error(e);
                            logger.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (hookFunctionsSave)`, { executionId: this.executionId, workflowId: this.workflowData.id });
                        }
                    }
                    const saveSettings = (0, to_save_settings_1.toSaveSettings)(this.workflowData.settings);
                    if (isManualMode && !saveSettings.manual && !fullRunData.waitTill) {
                        await di_1.Container.get(execution_repository_1.ExecutionRepository).softDelete(this.executionId);
                        return;
                    }
                    const shouldNotSave = (fullRunData.status === 'success' && !saveSettings.success) ||
                        (fullRunData.status !== 'success' && !saveSettings.error);
                    if (shouldNotSave && !fullRunData.waitTill && !isManualMode) {
                        (0, execute_error_workflow_1.executeErrorWorkflow)(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                        await di_1.Container.get(execution_repository_1.ExecutionRepository).hardDelete({
                            workflowId: this.workflowData.id,
                            executionId: this.executionId,
                        });
                        return;
                    }
                    const fullExecutionData = (0, shared_hook_functions_1.prepareExecutionDataForDbUpdate)({
                        runData: fullRunData,
                        workflowData: this.workflowData,
                        workflowStatusFinal: fullRunData.status,
                        retryOf: this.retryOf,
                    });
                    if (fullRunData.waitTill && isManualMode) {
                        fullExecutionData.data.pushRef = this.pushRef;
                    }
                    await (0, shared_hook_functions_1.updateExistingExecution)({
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        executionData: fullExecutionData,
                    });
                    if (!isManualMode) {
                        (0, execute_error_workflow_1.executeErrorWorkflow)(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                }
                finally {
                    workflowStatisticsService.emit('workflowExecutionCompleted', {
                        workflowData: this.workflowData,
                        fullRunData,
                    });
                }
            },
        ],
        nodeFetchedData: [
            async (workflowId, node) => {
                workflowStatisticsService.emit('nodeFetchedData', { workflowId, node });
            },
        ],
    };
}
function hookFunctionsSaveWorker() {
    const logger = di_1.Container.get(n8n_core_1.Logger);
    const workflowStatisticsService = di_1.Container.get(workflow_statistics_service_1.WorkflowStatisticsService);
    return {
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                logger.debug('Executing hook (hookFunctionsSaveWorker)', {
                    executionId: this.executionId,
                    workflowId: this.workflowData.id,
                });
                const isManualMode = this.mode === 'manual';
                try {
                    if (!isManualMode && (0, utils_1.isWorkflowIdValid)(this.workflowData.id) && newStaticData) {
                        try {
                            await di_1.Container.get(workflow_static_data_service_1.WorkflowStaticDataService).saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            di_1.Container.get(n8n_core_1.ErrorReporter).error(e);
                            logger.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (workflowExecuteAfter)`, { pushRef: this.pushRef, workflowId: this.workflowData.id });
                        }
                    }
                    if (!isManualMode &&
                        fullRunData.status !== 'success' &&
                        fullRunData.status !== 'waiting') {
                        (0, execute_error_workflow_1.executeErrorWorkflow)(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                    const fullExecutionData = (0, shared_hook_functions_1.prepareExecutionDataForDbUpdate)({
                        runData: fullRunData,
                        workflowData: this.workflowData,
                        workflowStatusFinal: fullRunData.status,
                        retryOf: this.retryOf,
                    });
                    if (fullRunData.waitTill && isManualMode) {
                        fullExecutionData.data.pushRef = this.pushRef;
                    }
                    await (0, shared_hook_functions_1.updateExistingExecution)({
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        executionData: fullExecutionData,
                    });
                }
                finally {
                    workflowStatisticsService.emit('workflowExecutionCompleted', {
                        workflowData: this.workflowData,
                        fullRunData,
                    });
                }
            },
            async function (fullRunData) {
                const externalHooks = di_1.Container.get(external_hooks_1.ExternalHooks);
                try {
                    await externalHooks.run('workflow.postExecute', [
                        fullRunData,
                        this.workflowData,
                        this.executionId,
                    ]);
                }
                catch { }
            },
        ],
        nodeFetchedData: [
            async (workflowId, node) => {
                workflowStatisticsService.emit('nodeFetchedData', { workflowId, node });
            },
        ],
    };
}
function getWorkflowHooksIntegrated(mode, executionId, workflowData, userId) {
    const hookFunctions = mergeHookFunctions(hookFunctionsWorkflowEvents(userId), hookFunctionsNodeEvents(), hookFunctionsFinalizeExecutionStatus(), hookFunctionsSave(), hookFunctionsPreExecute());
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData);
}
function getWorkflowHooksWorkerExecuter(mode, executionId, workflowData, optionalParameters = {}) {
    const toMerge = [
        hookFunctionsNodeEvents(),
        hookFunctionsFinalizeExecutionStatus(),
        hookFunctionsSaveWorker(),
        hookFunctionsPreExecute(),
    ];
    if (mode === 'manual' && di_1.Container.get(n8n_core_1.InstanceSettings).isWorker) {
        toMerge.push(hookFunctionsPush());
    }
    const hookFunctions = mergeHookFunctions(...toMerge);
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
function getWorkflowHooksWorkerMain(mode, executionId, workflowData, optionalParameters = {}) {
    const hookFunctions = mergeHookFunctions(hookFunctionsWorkflowEvents(), hookFunctionsPreExecute(), hookFunctionsFinalizeExecutionStatus(), {
        workflowExecuteAfter: [
            async function (fullRunData) {
                if (!fullRunData.finished)
                    return;
                const saveSettings = (0, to_save_settings_1.toSaveSettings)(this.workflowData.settings);
                const isManualMode = this.mode === 'manual';
                if (isManualMode && !saveSettings.manual && !fullRunData.waitTill) {
                    await di_1.Container.get(execution_repository_1.ExecutionRepository).softDelete(this.executionId);
                    return;
                }
                const shouldNotSave = (fullRunData.status === 'success' && !saveSettings.success) ||
                    (fullRunData.status !== 'success' && !saveSettings.error);
                if (!isManualMode && shouldNotSave && !fullRunData.waitTill) {
                    await di_1.Container.get(execution_repository_1.ExecutionRepository).hardDelete({
                        workflowId: this.workflowData.id,
                        executionId: this.executionId,
                    });
                }
            },
        ],
    });
    hookFunctions.nodeExecuteBefore = [];
    hookFunctions.nodeExecuteAfter = [];
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
function getWorkflowHooksMain(data, executionId) {
    const hookFunctions = mergeHookFunctions(hookFunctionsWorkflowEvents(), hookFunctionsNodeEvents(), hookFunctionsFinalizeExecutionStatus(), hookFunctionsSave(), hookFunctionsPush(), hookFunctionsPreExecute());
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, data.executionMode, executionId, data.workflowData, {
        pushRef: data.pushRef,
        retryOf: data.retryOf,
    });
}
//# sourceMappingURL=execution-lifecycle-hooks.js.map