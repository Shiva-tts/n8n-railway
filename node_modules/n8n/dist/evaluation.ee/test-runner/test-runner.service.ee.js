"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRunnerService = void 0;
const di_1 = require("@n8n/di");
const flatted_1 = require("flatted");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const node_assert_1 = __importDefault(require("node:assert"));
const active_executions_1 = require("../../active-executions");
const execution_repository_1 = require("../../databases/repositories/execution.repository");
const test_metric_repository_ee_1 = require("../../databases/repositories/test-metric.repository.ee");
const test_run_repository_ee_1 = require("../../databases/repositories/test-run.repository.ee");
const workflow_repository_1 = require("../../databases/repositories/workflow.repository");
const node_types_1 = require("../../node-types");
const workflow_execute_additional_data_1 = require("../../workflow-execute-additional-data");
const workflow_runner_1 = require("../../workflow-runner");
const evaluation_metrics_ee_1 = require("./evaluation-metrics.ee");
const utils_ee_1 = require("./utils.ee");
let TestRunnerService = class TestRunnerService {
    constructor(logger, workflowRepository, workflowRunner, executionRepository, activeExecutions, testRunRepository, testMetricRepository, nodeTypes, errorReporter) {
        this.logger = logger;
        this.workflowRepository = workflowRepository;
        this.workflowRunner = workflowRunner;
        this.executionRepository = executionRepository;
        this.activeExecutions = activeExecutions;
        this.testRunRepository = testRunRepository;
        this.testMetricRepository = testMetricRepository;
        this.nodeTypes = nodeTypes;
        this.errorReporter = errorReporter;
        this.abortControllers = new Map();
    }
    getStartNodesData(workflow, pastExecutionData) {
        const workflowInstance = new n8n_workflow_1.Workflow({
            nodes: workflow.nodes,
            connections: workflow.connections,
            active: false,
            nodeTypes: this.nodeTypes,
        });
        const pastExecutionTriggerNode = (0, utils_ee_1.getPastExecutionTriggerNode)(pastExecutionData);
        (0, node_assert_1.default)(pastExecutionTriggerNode, 'Could not find the trigger node of the past execution');
        const triggerNodeData = pastExecutionData.resultData.runData[pastExecutionTriggerNode][0];
        (0, node_assert_1.default)(triggerNodeData, 'Trigger node data not found');
        const triggerToStartFrom = {
            name: pastExecutionTriggerNode,
            data: triggerNodeData,
        };
        const startNodes = workflowInstance
            .getChildNodes(pastExecutionTriggerNode, "main", 1)
            .map((nodeName) => ({
            name: nodeName,
            sourceData: { previousNode: pastExecutionTriggerNode },
        }));
        return {
            startNodes,
            triggerToStartFrom,
        };
    }
    async runTestCase(workflow, pastExecutionData, pastExecutionWorkflowData, mockedNodes, userId, abortSignal) {
        if (abortSignal.aborted) {
            return;
        }
        const pinData = (0, utils_ee_1.createPinData)(workflow, mockedNodes, pastExecutionData, pastExecutionWorkflowData);
        const data = {
            ...this.getStartNodesData(workflow, pastExecutionData),
            executionMode: 'evaluation',
            runData: {},
            pinData,
            workflowData: { ...workflow, pinData },
            userId,
            partialExecutionVersion: '1',
        };
        const executionId = await this.workflowRunner.run(data);
        (0, node_assert_1.default)(executionId);
        abortSignal.addEventListener('abort', () => {
            this.activeExecutions.stopExecution(executionId);
        });
        const executePromise = this.activeExecutions.getPostExecutePromise(executionId);
        return await executePromise;
    }
    async runTestCaseEvaluation(evaluationWorkflow, expectedData, actualData, abortSignal, testRunId) {
        if (abortSignal.aborted) {
            return;
        }
        const evaluationInputData = {
            json: {
                originalExecution: expectedData,
                newExecution: actualData,
            },
        };
        const data = await (0, workflow_execute_additional_data_1.getRunData)(evaluationWorkflow, [evaluationInputData]);
        if (testRunId && data.executionData) {
            data.executionData.resultData.metadata = {
                testRunId,
            };
        }
        data.executionMode = 'evaluation';
        const executionId = await this.workflowRunner.run(data);
        (0, node_assert_1.default)(executionId);
        abortSignal.addEventListener('abort', () => {
            this.activeExecutions.stopExecution(executionId);
        });
        const executePromise = this.activeExecutions.getPostExecutePromise(executionId);
        return await executePromise;
    }
    extractEvaluationResult(execution) {
        const lastNodeExecuted = execution.data.resultData.lastNodeExecuted;
        (0, node_assert_1.default)(lastNodeExecuted, 'Could not find the last node executed in evaluation workflow');
        const lastNodeTaskData = execution.data.resultData.runData[lastNodeExecuted]?.[0];
        const mainConnectionData = lastNodeTaskData?.data?.main?.[0];
        return mainConnectionData?.[0]?.json ?? {};
    }
    async getTestMetricNames(testDefinitionId) {
        const metrics = await this.testMetricRepository.find({
            where: {
                testDefinition: {
                    id: testDefinitionId,
                },
            },
        });
        return new Set(metrics.map((m) => m.name));
    }
    async runTest(user, test) {
        this.logger.debug('Starting new test run', { testId: test.id });
        const workflow = await this.workflowRepository.findById(test.workflowId);
        (0, node_assert_1.default)(workflow, 'Workflow not found');
        const evaluationWorkflow = await this.workflowRepository.findById(test.evaluationWorkflowId);
        (0, node_assert_1.default)(evaluationWorkflow, 'Evaluation workflow not found');
        const testRun = await this.testRunRepository.createTestRun(test.id);
        (0, node_assert_1.default)(testRun, 'Unable to create a test run');
        const abortController = new AbortController();
        this.abortControllers.set(testRun.id, abortController);
        const abortSignal = abortController.signal;
        try {
            const pastExecutions = await this.executionRepository
                .createQueryBuilder('execution')
                .select('execution.id')
                .leftJoin('execution.annotation', 'annotation')
                .leftJoin('annotation.tags', 'annotationTag')
                .where('annotationTag.id = :tagId', { tagId: test.annotationTagId })
                .andWhere('execution.workflowId = :workflowId', { workflowId: test.workflowId })
                .getMany();
            this.logger.debug('Found past executions', { count: pastExecutions.length });
            const testMetricNames = await this.getTestMetricNames(test.id);
            await this.testRunRepository.markAsRunning(testRun.id, pastExecutions.length);
            const metrics = new evaluation_metrics_ee_1.EvaluationMetrics(testMetricNames);
            for (const { id: pastExecutionId } of pastExecutions) {
                if (abortSignal.aborted) {
                    this.logger.debug('Test run was cancelled', {
                        testId: test.id,
                        stoppedOn: pastExecutionId,
                    });
                    break;
                }
                this.logger.debug('Running test case', { pastExecutionId });
                try {
                    const pastExecution = await this.executionRepository.findOne({
                        where: { id: pastExecutionId },
                        relations: ['executionData', 'metadata'],
                    });
                    (0, node_assert_1.default)(pastExecution, 'Execution not found');
                    const executionData = (0, flatted_1.parse)(pastExecution.executionData.data);
                    const testCaseExecution = await this.runTestCase(workflow, executionData, pastExecution.executionData.workflowData, test.mockedNodes, user.id, abortSignal);
                    this.logger.debug('Test case execution finished', { pastExecutionId });
                    if (!testCaseExecution) {
                        await this.testRunRepository.incrementFailed(testRun.id);
                        continue;
                    }
                    const testCaseRunData = testCaseExecution.data.resultData.runData;
                    const originalRunData = executionData.resultData.runData;
                    const evalExecution = await this.runTestCaseEvaluation(evaluationWorkflow, originalRunData, testCaseRunData, abortSignal, testRun.id);
                    (0, node_assert_1.default)(evalExecution);
                    this.logger.debug('Evaluation execution finished', { pastExecutionId });
                    metrics.addResults(this.extractEvaluationResult(evalExecution));
                    if (evalExecution.data.resultData.error) {
                        await this.testRunRepository.incrementFailed(testRun.id);
                    }
                    else {
                        await this.testRunRepository.incrementPassed(testRun.id);
                    }
                }
                catch (e) {
                    await this.testRunRepository.incrementFailed(testRun.id);
                    this.errorReporter.error(e);
                }
            }
            if (abortSignal.aborted) {
                await this.testRunRepository.markAsCancelled(testRun.id);
            }
            else {
                const aggregatedMetrics = metrics.getAggregatedMetrics();
                await this.testRunRepository.markAsCompleted(testRun.id, aggregatedMetrics);
                this.logger.debug('Test run finished', { testId: test.id });
            }
        }
        catch (e) {
            if (e instanceof n8n_workflow_1.ExecutionCancelledError) {
                this.logger.debug('Evaluation execution was cancelled. Cancelling test run', {
                    testRunId: testRun.id,
                    stoppedOn: e.extra?.executionId,
                });
                await this.testRunRepository.markAsCancelled(testRun.id);
            }
            else {
                throw e;
            }
        }
        finally {
            this.abortControllers.delete(testRun.id);
        }
    }
    canBeCancelled(testRun) {
        return testRun.status !== 'running' && testRun.status !== 'new';
    }
    async cancelTestRun(testRunId) {
        const abortController = this.abortControllers.get(testRunId);
        if (abortController) {
            abortController.abort();
            this.abortControllers.delete(testRunId);
        }
        else {
            await this.testRunRepository.markAsCancelled(testRunId);
        }
    }
};
exports.TestRunnerService = TestRunnerService;
exports.TestRunnerService = TestRunnerService = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [n8n_core_1.Logger,
        workflow_repository_1.WorkflowRepository,
        workflow_runner_1.WorkflowRunner,
        execution_repository_1.ExecutionRepository,
        active_executions_1.ActiveExecutions,
        test_run_repository_ee_1.TestRunRepository,
        test_metric_repository_ee_1.TestMetricRepository,
        node_types_1.NodeTypes,
        n8n_core_1.ErrorReporter])
], TestRunnerService);
//# sourceMappingURL=test-runner.service.ee.js.map